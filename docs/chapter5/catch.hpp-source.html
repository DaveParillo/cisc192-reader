<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title><title><no title></title></title>
  <meta http-equiv="content-type" content="text/html; charset=None">
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css">
</head>
<body>
<h2><title><no title></title></h2>

<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> *  Catch v2.13.7</span>
<span class="cm"> *  Generated: 2021-07-28 20:29:27.753164</span>
<span class="cm"> *  ----------------------------------------------------------</span>
<span class="cm"> *  This file has been merged from multiple headers. Please don&#39;t edit it directly</span>
<span class="cm"> *  Copyright (c) 2021 Two Blue Cubes Ltd. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Distributed under the Boost Software License, Version 1.0. (See accompanying</span>
<span class="cm"> *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="cm"> */</span>
<span class="cp">#ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED</span>
<span class="cp">#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED</span>
<span class="c1">// start catch.hpp</span>


<span class="cp">#define CATCH_VERSION_MAJOR 2</span>
<span class="cp">#define CATCH_VERSION_MINOR 13</span>
<span class="cp">#define CATCH_VERSION_PATCH 7</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#    pragma clang system_header</span>
<span class="cp">#elif defined __GNUC__</span>
<span class="cp">#    pragma GCC system_header</span>
<span class="cp">#endif</span>

<span class="c1">// start catch_suppress_warnings.h</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#   ifdef __ICC </span><span class="c1">// icpc defines the __clang__ macro</span>
<span class="cp">#       pragma warning(push)</span>
<span class="cp">#       pragma warning(disable: 161 1682)</span>
<span class="cp">#   else </span><span class="c1">// __ICC</span>
<span class="cp">#       pragma clang diagnostic push</span>
<span class="cp">#       pragma clang diagnostic ignored &quot;-Wpadded&quot;</span>
<span class="cp">#       pragma clang diagnostic ignored &quot;-Wswitch-enum&quot;</span>
<span class="cp">#       pragma clang diagnostic ignored &quot;-Wcovered-switch-default&quot;</span>
<span class="cp">#    endif</span>
<span class="cp">#elif defined __GNUC__</span>
     <span class="c1">// Because REQUIREs trigger GCC&#39;s -Wparentheses, and because still</span>
     <span class="c1">// supported version of g++ have only buggy support for _Pragmas,</span>
     <span class="c1">// Wparentheses have to be suppressed globally.</span>
<span class="cp">#    pragma GCC diagnostic ignored &quot;-Wparentheses&quot; </span><span class="c1">// See #674 for details</span>

<span class="cp">#    pragma GCC diagnostic push</span>
<span class="cp">#    pragma GCC diagnostic ignored &quot;-Wunused-variable&quot;</span>
<span class="cp">#    pragma GCC diagnostic ignored &quot;-Wpadded&quot;</span>
<span class="cp">#endif</span>
<span class="c1">// end catch_suppress_warnings.h</span>
<span class="cp">#if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)</span>
<span class="cp">#  define CATCH_IMPL</span>
<span class="cp">#  define CATCH_CONFIG_ALL_PARTS</span>
<span class="cp">#endif</span>

<span class="c1">// In the impl file, we want to have access to all parts of the headers</span>
<span class="c1">// Can also be used to sanely support PCHs</span>
<span class="cp">#if defined(CATCH_CONFIG_ALL_PARTS)</span>
<span class="cp">#  define CATCH_CONFIG_EXTERNAL_INTERFACES</span>
<span class="cp">#  if defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#    undef CATCH_CONFIG_DISABLE_MATCHERS</span>
<span class="cp">#  endif</span>
<span class="cp">#  if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)</span>
<span class="cp">#    define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER</span>
<span class="cp">#  endif</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(CATCH_CONFIG_IMPL_ONLY)</span>
<span class="c1">// start catch_platform.h</span>

<span class="c1">// See e.g.:</span>
<span class="c1">// https://opensource.apple.com/source/CarbonHeaders/CarbonHeaders-18.1/TargetConditionals.h.auto.html</span>
<span class="cp">#ifdef __APPLE__</span>
<span class="cp">#  include &lt;TargetConditionals.h&gt;</span>
<span class="cp">#  if (defined(TARGET_OS_OSX) &amp;&amp; TARGET_OS_OSX == 1) || \</span>
<span class="cp">      (defined(TARGET_OS_MAC) &amp;&amp; TARGET_OS_MAC == 1)</span>
<span class="cp">#    define CATCH_PLATFORM_MAC</span>
<span class="cp">#  elif (defined(TARGET_OS_IPHONE) &amp;&amp; TARGET_OS_IPHONE == 1)</span>
<span class="cp">#    define CATCH_PLATFORM_IPHONE</span>
<span class="cp">#  endif</span>

<span class="cp">#elif defined(linux) || defined(__linux) || defined(__linux__)</span>
<span class="cp">#  define CATCH_PLATFORM_LINUX</span>

<span class="cp">#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)</span>
<span class="cp">#  define CATCH_PLATFORM_WINDOWS</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_platform.h</span>

<span class="cp">#ifdef CATCH_IMPL</span>
<span class="cp">#  ifndef CLARA_CONFIG_MAIN</span>
<span class="cp">#    define CLARA_CONFIG_MAIN_NOT_DEFINED</span>
<span class="cp">#    define CLARA_CONFIG_MAIN</span>
<span class="cp">#  endif</span>
<span class="cp">#endif</span>

<span class="c1">// start catch_user_interfaces.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rngSeed</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// end catch_user_interfaces.h</span>
<span class="c1">// start catch_tag_alias_autoregistrar.h</span>

<span class="c1">// start catch_common.h</span>

<span class="c1">// start catch_compiler_capabilities.h</span>

<span class="c1">// Detect a number of compiler features - by compiler</span>
<span class="c1">// The following features are defined:</span>
<span class="c1">//</span>
<span class="c1">// CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?</span>
<span class="c1">// CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?</span>
<span class="c1">// CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?</span>
<span class="c1">// CATCH_CONFIG_DISABLE_EXCEPTIONS : Are exceptions enabled?</span>
<span class="c1">// ****************</span>
<span class="c1">// Note to maintainers: if new toggles are added please document them</span>
<span class="c1">// in configuration.md, too</span>
<span class="c1">// ****************</span>

<span class="c1">// In general each macro has a _NO_&lt;feature name&gt; form</span>
<span class="c1">// (e.g. CATCH_CONFIG_NO_POSIX_SIGNALS) which disables the feature.</span>
<span class="c1">// Many features, at point of detection, define an _INTERNAL_ macro, so they</span>
<span class="c1">// can be combined, en-mass, with the _NO_ forms later.</span>

<span class="cp">#ifdef __cplusplus</span>

<span class="cp">#  if (__cplusplus &gt;= 201402L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201402L)</span>
<span class="cp">#    define CATCH_CPP14_OR_GREATER</span>
<span class="cp">#  endif</span>

<span class="cp">#  if (__cplusplus &gt;= 201703L) || (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt;= 201703L)</span>
<span class="cp">#    define CATCH_CPP17_OR_GREATER</span>
<span class="cp">#  endif</span>

<span class="cp">#endif</span>

<span class="c1">// Only GCC compiler should be used in this block, so other compilers trying to</span>
<span class="c1">// mask themselves as GCC should be ignored.</span>
<span class="cp">#if defined(__GNUC__) &amp;&amp; !defined(__clang__) &amp;&amp; !defined(__ICC) &amp;&amp; !defined(__CUDACC__) &amp;&amp; !defined(__LCC__)</span>
<span class="cp">#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( &quot;GCC diagnostic push&quot; )</span>
<span class="cp">#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( &quot;GCC diagnostic pop&quot; )</span>

<span class="cp">#    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)</span>

<span class="cp">#endif</span>

<span class="cp">#if defined(__clang__)</span>

<span class="cp">#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( &quot;clang diagnostic push&quot; )</span>
<span class="cp">#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( &quot;clang diagnostic pop&quot; )</span>

<span class="c1">// As of this writing, IBM XL&#39;s implementation of __builtin_constant_p has a bug</span>
<span class="c1">// which results in calls to destructors being emitted for each temporary,</span>
<span class="c1">// without a matching initialization. In practice, this can result in something</span>
<span class="c1">// like `std::string::~string` being called on an uninitialized value.</span>
<span class="c1">//</span>
<span class="c1">// For example, this code will likely segfault under IBM XL:</span>
<span class="c1">// ```</span>
<span class="c1">// REQUIRE(std::string(&quot;12&quot;) + &quot;34&quot; == &quot;1234&quot;)</span>
<span class="c1">// ```</span>
<span class="c1">//</span>
<span class="c1">// Therefore, `CATCH_INTERNAL_IGNORE_BUT_WARN` is not implemented.</span>
<span class="cp">#  if !defined(__ibmxl__) &amp;&amp; !defined(__CUDACC__)</span>
<span class="cp">#    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__) </span><span class="cm">/* NOLINT(cppcoreguidelines-pro-type-vararg, hicpp-vararg) */</span><span class="cp"></span>
<span class="cp">#  endif</span>

<span class="cp">#    define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">         _Pragma( &quot;clang diagnostic ignored \&quot;-Wexit-time-destructors\&quot;&quot; ) \</span>
<span class="cp">         _Pragma( &quot;clang diagnostic ignored \&quot;-Wglobal-constructors\&quot;&quot;)</span>

<span class="cp">#    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \</span>
<span class="cp">         _Pragma( &quot;clang diagnostic ignored \&quot;-Wparentheses\&quot;&quot; )</span>

<span class="cp">#    define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \</span>
<span class="cp">         _Pragma( &quot;clang diagnostic ignored \&quot;-Wunused-variable\&quot;&quot; )</span>

<span class="cp">#    define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \</span>
<span class="cp">         _Pragma( &quot;clang diagnostic ignored \&quot;-Wgnu-zero-variadic-macro-arguments\&quot;&quot; )</span>

<span class="cp">#    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \</span>
<span class="cp">         _Pragma( &quot;clang diagnostic ignored \&quot;-Wunused-template\&quot;&quot; )</span>

<span class="cp">#endif </span><span class="c1">// __clang__</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Assume that non-Windows platforms support posix signals by default</span>
<span class="cp">#if !defined(CATCH_PLATFORM_WINDOWS)</span>
    <span class="cp">#define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS</span>
<span class="cp">#endif</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// We know some environments not to support full POSIX signals</span>
<span class="cp">#if defined(__CYGWIN__) || defined(__QNX__) || defined(__EMSCRIPTEN__) || defined(__DJGPP__)</span>
    <span class="cp">#define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __OS400__</span>
<span class="cp">#       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS</span>
<span class="cp">#       define CATCH_CONFIG_COLOUR_NONE</span>
<span class="cp">#endif</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Android somehow still does not support std::to_string</span>
<span class="cp">#if defined(__ANDROID__)</span>
<span class="cp">#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING</span>
<span class="cp">#    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE</span>
<span class="cp">#endif</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Not all Windows environments support SEH properly</span>
<span class="cp">#if defined(__MINGW32__)</span>
<span class="cp">#    define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH</span>
<span class="cp">#endif</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// PS4</span>
<span class="cp">#if defined(__ORBIS__)</span>
<span class="cp">#    define CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE</span>
<span class="cp">#endif</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Cygwin</span>
<span class="cp">#ifdef __CYGWIN__</span>

<span class="c1">// Required for some versions of Cygwin to declare gettimeofday</span>
<span class="c1">// see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin</span>
<span class="cp">#   define _BSD_SOURCE</span>
<span class="c1">// some versions of cygwin (most) do not support std::to_string. Use the libstd check.</span>
<span class="c1">// https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813</span>
<span class="cp"># if !((__cplusplus &gt;= 201103L) &amp;&amp; defined(_GLIBCXX_USE_C99) \</span>
<span class="cp">           &amp;&amp; !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))</span>

<span class="cp">#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING</span>

<span class="cp"># endif</span>
<span class="cp">#endif </span><span class="c1">// __CYGWIN__</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Visual C++</span>
<span class="cp">#if defined(_MSC_VER)</span>

<span class="cp">#  define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION __pragma( warning(push) )</span>
<span class="cp">#  define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  __pragma( warning(pop) )</span>

<span class="c1">// Universal Windows platform does not support SEH</span>
<span class="c1">// Or console colours (or console at all...)</span>
<span class="cp">#  if defined(WINAPI_FAMILY) &amp;&amp; (WINAPI_FAMILY == WINAPI_FAMILY_APP)</span>
<span class="cp">#    define CATCH_CONFIG_COLOUR_NONE</span>
<span class="cp">#  else</span>
<span class="cp">#    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH</span>
<span class="cp">#  endif</span>

<span class="c1">// MSVC traditional preprocessor needs some workaround for __VA_ARGS__</span>
<span class="c1">// _MSVC_TRADITIONAL == 0 means new conformant preprocessor</span>
<span class="c1">// _MSVC_TRADITIONAL == 1 means old traditional non-conformant preprocessor</span>
<span class="cp">#  if !defined(__clang__) </span><span class="c1">// Handle Clang masquerading for msvc</span>
<span class="cp">#    if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) &amp;&amp; _MSVC_TRADITIONAL)</span>
<span class="cp">#      define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
<span class="cp">#    endif </span><span class="c1">// MSVC_TRADITIONAL</span>
<span class="cp">#  endif </span><span class="c1">// __clang__</span>

<span class="cp">#endif </span><span class="c1">// _MSC_VER</span>

<span class="cp">#if defined(_REENTRANT) || defined(_MSC_VER)</span>
<span class="c1">// Enable async processing, as -pthread is specified or no additional linking is required</span>
<span class="cp"># define CATCH_INTERNAL_CONFIG_USE_ASYNC</span>
<span class="cp">#endif </span><span class="c1">// _MSC_VER</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Check if we are compiled with -fno-exceptions or equivalent</span>
<span class="cp">#if defined(__EXCEPTIONS) || defined(__cpp_exceptions) || defined(_CPPUNWIND)</span>
<span class="cp">#  define CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED</span>
<span class="cp">#endif</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// DJGPP</span>
<span class="cp">#ifdef __DJGPP__</span>
<span class="cp">#  define CATCH_INTERNAL_CONFIG_NO_WCHAR</span>
<span class="cp">#endif </span><span class="c1">// __DJGPP__</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Embarcadero C++Build</span>
<span class="cp">#if defined(__BORLANDC__)</span>
    <span class="cp">#define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN</span>
<span class="cp">#endif</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Use of __COUNTER__ is suppressed during code analysis in</span>
<span class="c1">// CLion/AppCode 2017.2.x and former, because __COUNTER__ is not properly</span>
<span class="c1">// handled by it.</span>
<span class="c1">// Otherwise all supported compilers support COUNTER macro,</span>
<span class="c1">// but user still might want to turn it off</span>
<span class="cp">#if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ &gt;= 20170300L )</span>
    <span class="cp">#define CATCH_INTERNAL_CONFIG_COUNTER</span>
<span class="cp">#endif</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// RTX is a special version of Windows that is real time.</span>
<span class="c1">// This means that it is detected as Windows, but does not provide</span>
<span class="c1">// the same set of capabilities as real Windows does.</span>
<span class="cp">#if defined(UNDER_RTSS) || defined(RTX64_BUILD)</span>
    <span class="cp">#define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH</span>
    <span class="cp">#define CATCH_INTERNAL_CONFIG_NO_ASYNC</span>
    <span class="cp">#define CATCH_CONFIG_COLOUR_NONE</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(_GLIBCXX_USE_C99_MATH_TR1)</span>
<span class="cp">#define CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER</span>
<span class="cp">#endif</span>

<span class="c1">// Various stdlib support checks that require __has_include</span>
<span class="cp">#if defined(__has_include)</span>
  <span class="c1">// Check if string_view is available and usable</span>
  <span class="cp">#if __has_include(&lt;string_view&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)</span>
  <span class="cp">#    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW</span>
  <span class="cp">#endif</span>

  <span class="c1">// Check if optional is available and usable</span>
  <span class="cp">#  if __has_include(&lt;optional&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)</span>
  <span class="cp">#    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL</span>
  <span class="cp">#  endif </span><span class="c1">// __has_include(&lt;optional&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)</span>

  <span class="c1">// Check if byte is available and usable</span>
  <span class="cp">#  if __has_include(&lt;cstddef&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)</span>
  <span class="cp">#    include &lt;cstddef&gt;</span>
  <span class="cp">#    if defined(__cpp_lib_byte) &amp;&amp; (__cpp_lib_byte &gt; 0)</span>
  <span class="cp">#      define CATCH_INTERNAL_CONFIG_CPP17_BYTE</span>
  <span class="cp">#    endif</span>
  <span class="cp">#  endif </span><span class="c1">// __has_include(&lt;cstddef&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)</span>

  <span class="c1">// Check if variant is available and usable</span>
  <span class="cp">#  if __has_include(&lt;variant&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)</span>
  <span class="cp">#    if defined(__clang__) &amp;&amp; (__clang_major__ &lt; 8)</span>
         <span class="c1">// work around clang bug with libstdc++ https://bugs.llvm.org/show_bug.cgi?id=31852</span>
         <span class="c1">// fix should be in clang 8, workaround in libstdc++ 8.2</span>
  <span class="cp">#      include &lt;ciso646&gt;</span>
  <span class="cp">#      if defined(__GLIBCXX__) &amp;&amp; defined(_GLIBCXX_RELEASE) &amp;&amp; (_GLIBCXX_RELEASE &lt; 9)</span>
  <span class="cp">#        define CATCH_CONFIG_NO_CPP17_VARIANT</span>
  <span class="cp">#      else</span>
  <span class="cp">#        define CATCH_INTERNAL_CONFIG_CPP17_VARIANT</span>
  <span class="cp">#      endif </span><span class="c1">// defined(__GLIBCXX__) &amp;&amp; defined(_GLIBCXX_RELEASE) &amp;&amp; (_GLIBCXX_RELEASE &lt; 9)</span>
  <span class="cp">#    else</span>
  <span class="cp">#      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT</span>
  <span class="cp">#    endif </span><span class="c1">// defined(__clang__) &amp;&amp; (__clang_major__ &lt; 8)</span>
  <span class="cp">#  endif </span><span class="c1">// __has_include(&lt;variant&gt;) &amp;&amp; defined(CATCH_CPP17_OR_GREATER)</span>
<span class="cp">#endif </span><span class="c1">// defined(__has_include)</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_COUNTER) &amp;&amp; !defined(CATCH_CONFIG_NO_COUNTER) &amp;&amp; !defined(CATCH_CONFIG_COUNTER)</span>
<span class="cp">#   define CATCH_CONFIG_COUNTER</span>
<span class="cp">#endif</span>
<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) &amp;&amp; !defined(CATCH_CONFIG_NO_WINDOWS_SEH) &amp;&amp; !defined(CATCH_CONFIG_WINDOWS_SEH) &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH)</span>
<span class="cp">#   define CATCH_CONFIG_WINDOWS_SEH</span>
<span class="cp">#endif</span>
<span class="c1">// This is set by default, because we assume that unix compilers are posix-signal-compatible by default.</span>
<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) &amp;&amp; !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) &amp;&amp; !defined(CATCH_CONFIG_POSIX_SIGNALS)</span>
<span class="cp">#   define CATCH_CONFIG_POSIX_SIGNALS</span>
<span class="cp">#endif</span>
<span class="c1">// This is set by default, because we assume that compilers with no wchar_t support are just rare exceptions.</span>
<span class="cp">#if !defined(CATCH_INTERNAL_CONFIG_NO_WCHAR) &amp;&amp; !defined(CATCH_CONFIG_NO_WCHAR) &amp;&amp; !defined(CATCH_CONFIG_WCHAR)</span>
<span class="cp">#   define CATCH_CONFIG_WCHAR</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP11_TO_STRING) &amp;&amp; !defined(CATCH_CONFIG_CPP11_TO_STRING)</span>
<span class="cp">#    define CATCH_CONFIG_CPP11_TO_STRING</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_OPTIONAL) &amp;&amp; !defined(CATCH_CONFIG_CPP17_OPTIONAL)</span>
<span class="cp">#  define CATCH_CONFIG_CPP17_OPTIONAL</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) &amp;&amp; !defined(CATCH_CONFIG_CPP17_STRING_VIEW)</span>
<span class="cp">#  define CATCH_CONFIG_CPP17_STRING_VIEW</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_CPP17_VARIANT) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_VARIANT) &amp;&amp; !defined(CATCH_CONFIG_CPP17_VARIANT)</span>
<span class="cp">#  define CATCH_CONFIG_CPP17_VARIANT</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_CPP17_BYTE) &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_BYTE) &amp;&amp; !defined(CATCH_CONFIG_CPP17_BYTE)</span>
<span class="cp">#  define CATCH_CONFIG_CPP17_BYTE</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)</span>
<span class="cp">#  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_NEW_CAPTURE) &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE) &amp;&amp; !defined(CATCH_CONFIG_NO_NEW_CAPTURE) &amp;&amp; !defined(CATCH_CONFIG_NEW_CAPTURE)</span>
<span class="cp">#  define CATCH_CONFIG_NEW_CAPTURE</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED) &amp;&amp; !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
<span class="cp">#  define CATCH_CONFIG_DISABLE_EXCEPTIONS</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN) &amp;&amp; !defined(CATCH_CONFIG_NO_POLYFILL_ISNAN) &amp;&amp; !defined(CATCH_CONFIG_POLYFILL_ISNAN)</span>
<span class="cp">#  define CATCH_CONFIG_POLYFILL_ISNAN</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_USE_ASYNC)  &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_NO_ASYNC) &amp;&amp; !defined(CATCH_CONFIG_NO_USE_ASYNC) &amp;&amp; !defined(CATCH_CONFIG_USE_ASYNC)</span>
<span class="cp">#  define CATCH_CONFIG_USE_ASYNC</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE) &amp;&amp; !defined(CATCH_CONFIG_NO_ANDROID_LOGWRITE) &amp;&amp; !defined(CATCH_CONFIG_ANDROID_LOGWRITE)</span>
<span class="cp">#  define CATCH_CONFIG_ANDROID_LOGWRITE</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER) &amp;&amp; !defined(CATCH_CONFIG_NO_GLOBAL_NEXTAFTER) &amp;&amp; !defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)</span>
<span class="cp">#  define CATCH_CONFIG_GLOBAL_NEXTAFTER</span>
<span class="cp">#endif</span>

<span class="c1">// Even if we do not think the compiler has that warning, we still have</span>
<span class="c1">// to provide a macro that can be used by the code.</span>
<span class="cp">#if !defined(CATCH_INTERNAL_START_WARNINGS_SUPPRESSION)</span>
<span class="cp">#   define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined(CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION)</span>
<span class="cp">#   define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)</span>
<span class="cp">#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)</span>
<span class="cp">#   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS)</span>
<span class="cp">#   define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)</span>
<span class="cp">#   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS</span>
<span class="cp">#endif</span>

<span class="c1">// The goal of this macro is to avoid evaluation of the arguments, but</span>
<span class="c1">// still have the compiler warn on problems inside...</span>
<span class="cp">#if !defined(CATCH_INTERNAL_IGNORE_BUT_WARN)</span>
<span class="cp">#   define CATCH_INTERNAL_IGNORE_BUT_WARN(...)</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(__APPLE__) &amp;&amp; defined(__apple_build_version__) &amp;&amp; (__clang_major__ &lt; 10)</span>
<span class="cp">#   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS</span>
<span class="cp">#elif defined(__clang__) &amp;&amp; (__clang_major__ &lt; 5)</span>
<span class="cp">#   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS)</span>
<span class="cp">#   define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
<span class="cp">#define CATCH_TRY if ((true))</span>
<span class="cp">#define CATCH_CATCH_ALL if ((false))</span>
<span class="cp">#define CATCH_CATCH_ANON(type) if ((false))</span>
<span class="cp">#else</span>
<span class="cp">#define CATCH_TRY try</span>
<span class="cp">#define CATCH_CATCH_ALL catch (...)</span>
<span class="cp">#define CATCH_CATCH_ANON(type) catch (type)</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR) &amp;&amp; !defined(CATCH_CONFIG_NO_TRADITIONAL_MSVC_PREPROCESSOR) &amp;&amp; !defined(CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR)</span>
<span class="cp">#define CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_compiler_capabilities.h</span>
<span class="cp">#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line</span>
<span class="cp">#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )</span>
<span class="cp">#ifdef CATCH_CONFIG_COUNTER</span>
<span class="cp">#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )</span>
<span class="cp">#else</span>
<span class="cp">#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )</span>
<span class="cp">#endif</span>

<span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>

<span class="c1">// We need a dummy global operator&lt;&lt; so we can bring it into Catch namespace later</span>
<span class="k">struct</span> <span class="nc">Catch_global_namespace_dummy</span> <span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Catch_global_namespace_dummy</span><span class="p">);</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">CaseSensitive</span> <span class="p">{</span> <span class="k">enum</span> <span class="nc">Choice</span> <span class="p">{</span>
        <span class="n">Yes</span><span class="p">,</span>
        <span class="n">No</span>
    <span class="p">};</span> <span class="p">};</span>

    <span class="k">class</span> <span class="nc">NonCopyable</span> <span class="p">{</span>
        <span class="n">NonCopyable</span><span class="p">(</span> <span class="n">NonCopyable</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span>              <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">NonCopyable</span><span class="p">(</span> <span class="n">NonCopyable</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>                  <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">NonCopyable</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">NonCopyable</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>     <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="k">protected</span><span class="o">:</span>
        <span class="n">NonCopyable</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">NonCopyable</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">SourceLineInfo</span> <span class="p">{</span>

        <span class="n">SourceLineInfo</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">SourceLineInfo</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">_file</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">_line</span> <span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span>   <span class="n">file</span><span class="p">(</span> <span class="n">_file</span> <span class="p">),</span>
            <span class="n">line</span><span class="p">(</span> <span class="n">_line</span> <span class="p">)</span>
        <span class="p">{}</span>

        <span class="n">SourceLineInfo</span><span class="p">(</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span>            <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">SourceLineInfo</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span>     <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">SourceLineInfo</span><span class="p">(</span> <span class="n">SourceLineInfo</span><span class="o">&amp;&amp;</span> <span class="p">)</span>              <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">SourceLineInfo</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">SourceLineInfo</span><span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">file</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

        <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">line</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span> <span class="p">);</span>

    <span class="c1">// Bring in operator&lt;&lt; from global namespace into Catch namespace</span>
    <span class="c1">// This is necessary because the overload of operator&lt;&lt; above makes</span>
    <span class="c1">// lookup stop at namespace Catch</span>
    <span class="k">using</span> <span class="o">::</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">;</span>

    <span class="c1">// Use this in variadic streaming macros to allow</span>
    <span class="c1">//    &gt;&gt; +StreamEndStop</span>
    <span class="c1">// as well as</span>
    <span class="c1">//    &gt;&gt; stuff +StreamEndStop</span>
    <span class="k">struct</span> <span class="nc">StreamEndStop</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">operator</span><span class="o">+</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">StreamEndStop</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define CATCH_INTERNAL_LINEINFO \</span>
<span class="cp">    ::Catch::SourceLineInfo( __FILE__, static_cast&lt;std::size_t&gt;( __LINE__ ) )</span>

<span class="c1">// end catch_common.h</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">RegistrarForTagAliases</span> <span class="p">{</span>
        <span class="n">RegistrarForTagAliases</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">alias</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">tag</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">);</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \</span>
<span class="cp">    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">    namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); } \</span>
<span class="cp">    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION</span>

<span class="c1">// end catch_tag_alias_autoregistrar.h</span>
<span class="c1">// start catch_test_registry.h</span>

<span class="c1">// start catch_interfaces_testcase.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">TestSpec</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">ITestInvoker</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">invoke</span> <span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">ITestInvoker</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">TestCase</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IConfig</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">ITestCaseRegistry</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">ITestCaseRegistry</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getAllTests</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getAllTestsSorted</span><span class="p">(</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">bool</span> <span class="nf">isThrowSafe</span><span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">matchTest</span><span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span><span class="p">,</span> <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">filterTests</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCases</span><span class="p">,</span> <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getAllTestCasesSorted</span><span class="p">(</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>

<span class="p">}</span>

<span class="c1">// end catch_interfaces_testcase.h</span>
<span class="c1">// start catch_stringref.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="c1">/// A non-owning string class (similar to the forthcoming std::string_view)</span>
    <span class="c1">/// Note that, because a StringRef may be a substring of another string,</span>
    <span class="c1">/// it may not be null terminated.</span>
    <span class="k">class</span> <span class="nc">StringRef</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span> <span class="n">s_empty</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

        <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">m_start</span> <span class="o">=</span> <span class="n">s_empty</span><span class="p">;</span>
        <span class="n">size_type</span> <span class="n">m_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span> <span class="c1">// construction</span>
        <span class="k">constexpr</span> <span class="n">StringRef</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="n">StringRef</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">rawChars</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

        <span class="k">constexpr</span> <span class="nf">StringRef</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">rawChars</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">size</span> <span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span>   <span class="n">m_start</span><span class="p">(</span> <span class="n">rawChars</span> <span class="p">),</span>
            <span class="n">m_size</span><span class="p">(</span> <span class="n">size</span> <span class="p">)</span>
        <span class="p">{}</span>

        <span class="n">StringRef</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stdString</span> <span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span>   <span class="n">m_start</span><span class="p">(</span> <span class="n">stdString</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="p">),</span>
            <span class="n">m_size</span><span class="p">(</span> <span class="n">stdString</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span>
        <span class="p">{}</span>

        <span class="k">explicit</span> <span class="k">operator</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">m_start</span><span class="p">,</span> <span class="n">m_size</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span> <span class="c1">// operators</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">!=</span> <span class="p">(</span><span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">other</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="p">[]</span> <span class="p">(</span> <span class="n">size_type</span> <span class="n">index</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_size</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">m_start</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
        <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span> <span class="c1">// named queries</span>
        <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">size_type</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_size</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Returns the current start pointer. If the StringRef is not</span>
        <span class="c1">// null-terminated, throws std::domain_exception</span>
        <span class="k">auto</span> <span class="n">c_str</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span> <span class="c1">// substrings and searches</span>
        <span class="c1">// Returns a substring of [start, start + length).</span>
        <span class="c1">// If start + length &gt; size(), then the substring is [start, size()).</span>
        <span class="c1">// If start &gt; size(), then the substring is empty.</span>
        <span class="k">auto</span> <span class="n">substr</span><span class="p">(</span> <span class="n">size_type</span> <span class="n">start</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">length</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">StringRef</span><span class="p">;</span>

        <span class="c1">// Returns the current start pointer. May not be null-terminated.</span>
        <span class="k">auto</span> <span class="nf">data</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">;</span>

        <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">isNullTerminated</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_start</span><span class="p">[</span><span class="n">m_size</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span> <span class="c1">// iterators</span>
        <span class="k">constexpr</span> <span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_start</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">constexpr</span> <span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_start</span> <span class="o">+</span> <span class="n">m_size</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="k">operator</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sr</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">;</span>
    <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sr</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span> <span class="s">&quot;&quot;</span> <span class="n">_sr</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">rawChars</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">StringRef</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">StringRef</span><span class="p">(</span> <span class="n">rawChars</span><span class="p">,</span> <span class="n">size</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span> <span class="s">&quot;&quot;</span> <span class="n">_catch_sr</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">rawChars</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">Catch</span><span class="o">::</span><span class="n">StringRef</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Catch</span><span class="o">::</span><span class="n">StringRef</span><span class="p">(</span> <span class="n">rawChars</span><span class="p">,</span> <span class="n">size</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// end catch_stringref.h</span>
<span class="c1">// start catch_preprocessor.hpp</span>


<span class="cp">#define CATCH_RECURSION_LEVEL0(...) __VA_ARGS__</span>
<span class="cp">#define CATCH_RECURSION_LEVEL1(...) CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(__VA_ARGS__)))</span>
<span class="cp">#define CATCH_RECURSION_LEVEL2(...) CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(__VA_ARGS__)))</span>
<span class="cp">#define CATCH_RECURSION_LEVEL3(...) CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(__VA_ARGS__)))</span>
<span class="cp">#define CATCH_RECURSION_LEVEL4(...) CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(__VA_ARGS__)))</span>
<span class="cp">#define CATCH_RECURSION_LEVEL5(...) CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(__VA_ARGS__)))</span>

<span class="cp">#ifdef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
<span class="cp">#define INTERNAL_CATCH_EXPAND_VARGS(...) __VA_ARGS__</span>
<span class="c1">// MSVC needs more evaluations</span>
<span class="cp">#define CATCH_RECURSION_LEVEL6(...) CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(__VA_ARGS__)))</span>
<span class="cp">#define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL6(CATCH_RECURSION_LEVEL6(__VA_ARGS__))</span>
<span class="cp">#else</span>
<span class="cp">#define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL5(__VA_ARGS__)</span>
<span class="cp">#endif</span>

<span class="cp">#define CATCH_REC_END(...)</span>
<span class="cp">#define CATCH_REC_OUT</span>

<span class="cp">#define CATCH_EMPTY()</span>
<span class="cp">#define CATCH_DEFER(id) id CATCH_EMPTY()</span>

<span class="cp">#define CATCH_REC_GET_END2() 0, CATCH_REC_END</span>
<span class="cp">#define CATCH_REC_GET_END1(...) CATCH_REC_GET_END2</span>
<span class="cp">#define CATCH_REC_GET_END(...) CATCH_REC_GET_END1</span>
<span class="cp">#define CATCH_REC_NEXT0(test, next, ...) next CATCH_REC_OUT</span>
<span class="cp">#define CATCH_REC_NEXT1(test, next) CATCH_DEFER ( CATCH_REC_NEXT0 ) ( test, next, 0)</span>
<span class="cp">#define CATCH_REC_NEXT(test, next)  CATCH_REC_NEXT1(CATCH_REC_GET_END test, next)</span>

<span class="cp">#define CATCH_REC_LIST0(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_REC_LIST1(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0) ) ( f, peek, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_REC_LIST2(f, x, peek, ...)   f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )</span>

<span class="cp">#define CATCH_REC_LIST0_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_REC_LIST1_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0_UD) ) ( f, userdata, peek, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_REC_LIST2_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )</span>

<span class="c1">// Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,</span>
<span class="c1">// and passes userdata as the first parameter to each invocation,</span>
<span class="c1">// e.g. CATCH_REC_LIST_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)</span>
<span class="cp">#define CATCH_REC_LIST_UD(f, userdata, ...) CATCH_RECURSE(CATCH_REC_LIST2_UD(f, userdata, __VA_ARGS__, ()()(), ()()(), ()()(), 0))</span>

<span class="cp">#define CATCH_REC_LIST(f, ...) CATCH_RECURSE(CATCH_REC_LIST2(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))</span>

<span class="cp">#define INTERNAL_CATCH_EXPAND1(param) INTERNAL_CATCH_EXPAND2(param)</span>
<span class="cp">#define INTERNAL_CATCH_EXPAND2(...) INTERNAL_CATCH_NO## __VA_ARGS__</span>
<span class="cp">#define INTERNAL_CATCH_DEF(...) INTERNAL_CATCH_DEF __VA_ARGS__</span>
<span class="cp">#define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF</span>
<span class="cp">#define INTERNAL_CATCH_STRINGIZE(...) INTERNAL_CATCH_STRINGIZE2(__VA_ARGS__)</span>
<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
<span class="cp">#define INTERNAL_CATCH_STRINGIZE2(...) #__VA_ARGS__</span>
<span class="cp">#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param))</span>
<span class="cp">#else</span>
<span class="c1">// MSVC is adding extra space and needs another indirection to expand INTERNAL_CATCH_NOINTERNAL_CATCH_DEF</span>
<span class="cp">#define INTERNAL_CATCH_STRINGIZE2(...) INTERNAL_CATCH_STRINGIZE3(__VA_ARGS__)</span>
<span class="cp">#define INTERNAL_CATCH_STRINGIZE3(...) #__VA_ARGS__</span>
<span class="cp">#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)</span>
<span class="cp">#endif</span>

<span class="cp">#define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__</span>
<span class="cp">#define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)</span>

<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS(...) INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF __VA_ARGS__)</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
<span class="cp">#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)&gt;())</span>
<span class="cp">#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))</span>
<span class="cp">#else</span>
<span class="cp">#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)&gt;()))</span>
<span class="cp">#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))</span>
<span class="cp">#endif</span>

<span class="cp">#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\</span>
<span class="cp">    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)</span>

<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _3, _4, _5, _6)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)</span>

<span class="cp">#define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N</span>

<span class="cp">#define INTERNAL_CATCH_TYPE_GEN\</span>
<span class="cp">    template&lt;typename...&gt; struct TypeList {};\</span>
<span class="cp">    template&lt;typename...Ts&gt;\</span>
<span class="cp">    constexpr auto get_wrapper() noexcept -&gt; TypeList&lt;Ts...&gt; { return {}; }\</span>
<span class="cp">    template&lt;template&lt;typename...&gt; class...&gt; struct TemplateTypeList{};\</span>
<span class="cp">    template&lt;template&lt;typename...&gt; class...Cs&gt;\</span>
<span class="cp">    constexpr auto get_wrapper() noexcept -&gt; TemplateTypeList&lt;Cs...&gt; { return {}; }\</span>
<span class="cp">    template&lt;typename...&gt;\</span>
<span class="cp">    struct append;\</span>
<span class="cp">    template&lt;typename...&gt;\</span>
<span class="cp">    struct rewrap;\</span>
<span class="cp">    template&lt;template&lt;typename...&gt; class, typename...&gt;\</span>
<span class="cp">    struct create;\</span>
<span class="cp">    template&lt;template&lt;typename...&gt; class, typename&gt;\</span>
<span class="cp">    struct convert;\</span>
<span class="cp">    \</span>
<span class="cp">    template&lt;typename T&gt; \</span>
<span class="cp">    struct append&lt;T&gt; { using type = T; };\</span>
<span class="cp">    template&lt; template&lt;typename...&gt; class L1, typename...E1, template&lt;typename...&gt; class L2, typename...E2, typename...Rest&gt;\</span>
<span class="cp">    struct append&lt;L1&lt;E1...&gt;, L2&lt;E2...&gt;, Rest...&gt; { using type = typename append&lt;L1&lt;E1...,E2...&gt;, Rest...&gt;::type; };\</span>
<span class="cp">    template&lt; template&lt;typename...&gt; class L1, typename...E1, typename...Rest&gt;\</span>
<span class="cp">    struct append&lt;L1&lt;E1...&gt;, TypeList&lt;mpl_::na&gt;, Rest...&gt; { using type = L1&lt;E1...&gt;; };\</span>
<span class="cp">    \</span>
<span class="cp">    template&lt; template&lt;typename...&gt; class Container, template&lt;typename...&gt; class List, typename...elems&gt;\</span>
<span class="cp">    struct rewrap&lt;TemplateTypeList&lt;Container&gt;, List&lt;elems...&gt;&gt; { using type = TypeList&lt;Container&lt;elems...&gt;&gt;; };\</span>
<span class="cp">    template&lt; template&lt;typename...&gt; class Container, template&lt;typename...&gt; class List, class...Elems, typename...Elements&gt;\</span>
<span class="cp">    struct rewrap&lt;TemplateTypeList&lt;Container&gt;, List&lt;Elems...&gt;, Elements...&gt; { using type = typename append&lt;TypeList&lt;Container&lt;Elems...&gt;&gt;, typename rewrap&lt;TemplateTypeList&lt;Container&gt;, Elements...&gt;::type&gt;::type; };\</span>
<span class="cp">    \</span>
<span class="cp">    template&lt;template &lt;typename...&gt; class Final, template&lt; typename...&gt; class...Containers, typename...Types&gt;\</span>
<span class="cp">    struct create&lt;Final, TemplateTypeList&lt;Containers...&gt;, TypeList&lt;Types...&gt;&gt; { using type = typename append&lt;Final&lt;&gt;, typename rewrap&lt;TemplateTypeList&lt;Containers&gt;, Types...&gt;::type...&gt;::type; };\</span>
<span class="cp">    template&lt;template &lt;typename...&gt; class Final, template &lt;typename...&gt; class List, typename...Ts&gt;\</span>
<span class="cp">    struct convert&lt;Final, List&lt;Ts...&gt;&gt; { using type = typename append&lt;Final&lt;&gt;,TypeList&lt;Ts&gt;...&gt;::type; };</span>

<span class="cp">#define INTERNAL_CATCH_NTTP_1(signature, ...)\</span>
<span class="cp">    template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; struct Nttp{};\</span>
<span class="cp">    template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\</span>
<span class="cp">    constexpr auto get_wrapper() noexcept -&gt; Nttp&lt;__VA_ARGS__&gt; { return {}; } \</span>
<span class="cp">    template&lt;template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class...&gt; struct NttpTemplateTypeList{};\</span>
<span class="cp">    template&lt;template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class...Cs&gt;\</span>
<span class="cp">    constexpr auto get_wrapper() noexcept -&gt; NttpTemplateTypeList&lt;Cs...&gt; { return {}; } \</span>
<span class="cp">    \</span>
<span class="cp">    template&lt; template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class Container, template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class List, INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\</span>
<span class="cp">    struct rewrap&lt;NttpTemplateTypeList&lt;Container&gt;, List&lt;__VA_ARGS__&gt;&gt; { using type = TypeList&lt;Container&lt;__VA_ARGS__&gt;&gt;; };\</span>
<span class="cp">    template&lt; template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class Container, template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements&gt;\</span>
<span class="cp">    struct rewrap&lt;NttpTemplateTypeList&lt;Container&gt;, List&lt;__VA_ARGS__&gt;, Elements...&gt; { using type = typename append&lt;TypeList&lt;Container&lt;__VA_ARGS__&gt;&gt;, typename rewrap&lt;NttpTemplateTypeList&lt;Container&gt;, Elements...&gt;::type&gt;::type; };\</span>
<span class="cp">    template&lt;template &lt;typename...&gt; class Final, template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; class...Containers, typename...Types&gt;\</span>
<span class="cp">    struct create&lt;Final, NttpTemplateTypeList&lt;Containers...&gt;, TypeList&lt;Types...&gt;&gt; { using type = typename append&lt;Final&lt;&gt;, typename rewrap&lt;NttpTemplateTypeList&lt;Containers&gt;, Types...&gt;::type...&gt;::type; };</span>

<span class="cp">#define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)</span>
<span class="cp">#define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\</span>
<span class="cp">    template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\</span>
<span class="cp">    static void TestName()</span>
<span class="cp">#define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\</span>
<span class="cp">    template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\</span>
<span class="cp">    static void TestName()</span>

<span class="cp">#define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)</span>
<span class="cp">#define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\</span>
<span class="cp">    template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\</span>
<span class="cp">    static void TestName()</span>
<span class="cp">#define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\</span>
<span class="cp">    template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\</span>
<span class="cp">    static void TestName()</span>

<span class="cp">#define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\</span>
<span class="cp">    template&lt;typename Type&gt;\</span>
<span class="cp">    void reg_test(TypeList&lt;Type&gt;, Catch::NameAndTags nameAndTags)\</span>
<span class="cp">    {\</span>
<span class="cp">        Catch::AutoReg( Catch::makeTestInvoker(&amp;TestFunc&lt;Type&gt;), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\</span>
<span class="cp">    }</span>

<span class="cp">#define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\</span>
<span class="cp">    template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\</span>
<span class="cp">    void reg_test(Nttp&lt;__VA_ARGS__&gt;, Catch::NameAndTags nameAndTags)\</span>
<span class="cp">    {\</span>
<span class="cp">        Catch::AutoReg( Catch::makeTestInvoker(&amp;TestFunc&lt;__VA_ARGS__&gt;), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\</span>
<span class="cp">    }</span>

<span class="cp">#define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\</span>
<span class="cp">    template&lt;typename Type&gt;\</span>
<span class="cp">    void reg_test(TypeList&lt;Type&gt;, Catch::StringRef className, Catch::NameAndTags nameAndTags)\</span>
<span class="cp">    {\</span>
<span class="cp">        Catch::AutoReg( Catch::makeTestInvoker(&amp;TestName&lt;Type&gt;::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\</span>
<span class="cp">    }</span>

<span class="cp">#define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\</span>
<span class="cp">    template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt;\</span>
<span class="cp">    void reg_test(Nttp&lt;__VA_ARGS__&gt;, Catch::StringRef className, Catch::NameAndTags nameAndTags)\</span>
<span class="cp">    {\</span>
<span class="cp">        Catch::AutoReg( Catch::makeTestInvoker(&amp;TestName&lt;__VA_ARGS__&gt;::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\</span>
<span class="cp">    }</span>

<span class="cp">#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)</span>
<span class="cp">#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\</span>
<span class="cp">    template&lt;typename TestType&gt; \</span>
<span class="cp">    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)&lt;TestType&gt; { \</span>
<span class="cp">        void test();\</span>
<span class="cp">    }</span>

<span class="cp">#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\</span>
<span class="cp">    template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; \</span>
<span class="cp">    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)&lt;__VA_ARGS__&gt; { \</span>
<span class="cp">        void test();\</span>
<span class="cp">    }</span>

<span class="cp">#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)</span>
<span class="cp">#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\</span>
<span class="cp">    template&lt;typename TestType&gt; \</span>
<span class="cp">    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName&lt;TestType&gt;::test()</span>
<span class="cp">#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\</span>
<span class="cp">    template&lt;INTERNAL_CATCH_REMOVE_PARENS(signature)&gt; \</span>
<span class="cp">    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName&lt;__VA_ARGS__&gt;::test()</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
<span class="cp">#define INTERNAL_CATCH_NTTP_0</span>
<span class="cp">#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)</span>
<span class="cp">#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)</span>
<span class="cp">#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)</span>
<span class="cp">#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)</span>
<span class="cp">#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)</span>
<span class="cp">#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)</span>
<span class="cp">#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)</span>
<span class="cp">#else</span>
<span class="cp">#define INTERNAL_CATCH_NTTP_0(signature)</span>
<span class="cp">#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))</span>
<span class="cp">#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))</span>
<span class="cp">#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))</span>
<span class="cp">#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))</span>
<span class="cp">#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))</span>
<span class="cp">#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))</span>
<span class="cp">#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( &quot;dummy&quot;, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))</span>
<span class="cp">#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_preprocessor.hpp</span>
<span class="c1">// start catch_meta.hpp</span>


<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">always_false</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">true_given</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span>
    <span class="k">struct</span> <span class="nc">is_callable_tester</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
        <span class="n">true_given</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">()...))</span><span class="o">&gt;</span> <span class="k">static</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="k">static</span> <span class="n">test</span><span class="p">(...);</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">is_callable</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">is_callable</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span> <span class="o">:</span> <span class="k">decltype</span><span class="p">(</span><span class="n">is_callable_tester</span><span class="o">::</span><span class="n">test</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{};</span>

<span class="cp">#if defined(__cpp_lib_is_invocable) &amp;&amp; __cpp_lib_is_invocable &gt;= 201703</span>
    <span class="c1">// std::result_of is deprecated in C++17 and removed in C++20. Hence, it is</span>
    <span class="c1">// replaced with std::invoke_result here.</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Func</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">FunctionReturnType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_cv_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">Func</span><span class="p">,</span> <span class="n">U</span><span class="p">...</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="c1">// Keep ::type here because we still support C++11</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Func</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">FunctionReturnType</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">remove_cv</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">Func</span><span class="p">(</span><span class="n">U</span><span class="p">...)</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="k">namespace</span> <span class="n">mpl_</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">na</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// end catch_meta.hpp</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TestInvokerAsMethod</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ITestInvoker</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="n">m_testAsMethod</span><span class="p">)();</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TestInvokerAsMethod</span><span class="p">(</span> <span class="kt">void</span> <span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="n">testAsMethod</span><span class="p">)()</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">m_testAsMethod</span><span class="p">(</span> <span class="n">testAsMethod</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">invoke</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">C</span> <span class="n">obj</span><span class="p">;</span>
        <span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">m_testAsMethod</span><span class="p">)();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="nf">makeTestInvoker</span><span class="p">(</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">testAsFunction</span><span class="p">)()</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">ITestInvoker</span><span class="o">*</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">C</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">makeTestInvoker</span><span class="p">(</span> <span class="kt">void</span> <span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="n">testAsMethod</span><span class="p">)()</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">ITestInvoker</span><span class="o">*</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="n">TestInvokerAsMethod</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">testAsMethod</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">NameAndTags</span> <span class="p">{</span>
    <span class="n">NameAndTags</span><span class="p">(</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name_</span> <span class="o">=</span> <span class="n">StringRef</span><span class="p">(),</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tags_</span> <span class="o">=</span> <span class="n">StringRef</span><span class="p">()</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">StringRef</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">StringRef</span> <span class="n">tags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">AutoReg</span> <span class="o">:</span> <span class="n">NonCopyable</span> <span class="p">{</span>
    <span class="n">AutoReg</span><span class="p">(</span> <span class="n">ITestInvoker</span><span class="o">*</span> <span class="n">invoker</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">classOrMethod</span><span class="p">,</span> <span class="n">NameAndTags</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndTags</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="o">~</span><span class="n">AutoReg</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#if defined(CATCH_CONFIG_DISABLE)</span>
    <span class="cp">#define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \</span>
<span class="cp">        static void TestName()</span>
    <span class="cp">#define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \</span>
<span class="cp">        namespace{                        \</span>
<span class="cp">            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \</span>
<span class="cp">                void test();              \</span>
<span class="cp">            };                            \</span>
<span class="cp">        }                                 \</span>
<span class="cp">        void TestName::test()</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \</span>
<span class="cp">        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \</span>
<span class="cp">        namespace{                                                                                  \</span>
<span class="cp">            namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \</span>
<span class="cp">            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\</span>
<span class="cp">        }                                                                                           \</span>
<span class="cp">        }                                                                                           \</span>
<span class="cp">        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))</span>

    <span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
        <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \</span>
<span class="cp">            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )</span>
    <span class="cp">#else</span>
        <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \</span>
<span class="cp">            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )</span>
    <span class="cp">#endif</span>

    <span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
        <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \</span>
<span class="cp">            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )</span>
    <span class="cp">#else</span>
        <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \</span>
<span class="cp">            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )</span>
    <span class="cp">#endif</span>

    <span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
        <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \</span>
<span class="cp">            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )</span>
    <span class="cp">#else</span>
        <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \</span>
<span class="cp">            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )</span>
    <span class="cp">#endif</span>

    <span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
        <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \</span>
<span class="cp">            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )</span>
    <span class="cp">#else</span>
        <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \</span>
<span class="cp">            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )</span>
    <span class="cp">#endif</span>
<span class="cp">#endif</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
    <span class="cp">#define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \</span>
<span class="cp">        static void TestName(); \</span>
<span class="cp">        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &amp;TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } </span><span class="cm">/* NOLINT */</span><span class="cp"> \</span>
<span class="cp">        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \</span>
<span class="cp">        static void TestName()</span>
    <span class="cp">#define INTERNAL_CATCH_TESTCASE( ... ) \</span>
<span class="cp">        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
    <span class="cp">#define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \</span>
<span class="cp">        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &amp;QualifiedMethod ), CATCH_INTERNAL_LINEINFO, &quot;&amp;&quot; #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } </span><span class="cm">/* NOLINT */</span><span class="cp"> \</span>
<span class="cp">        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
    <span class="cp">#define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\</span>
<span class="cp">        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">        namespace{ \</span>
<span class="cp">            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \</span>
<span class="cp">                void test(); \</span>
<span class="cp">            }; \</span>
<span class="cp">            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &amp;TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ __VA_ARGS__ } ); </span><span class="cm">/* NOLINT */</span><span class="cp"> \</span>
<span class="cp">        } \</span>
<span class="cp">        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \</span>
<span class="cp">        void TestName::test()</span>
    <span class="cp">#define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \</span>
<span class="cp">        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
    <span class="cp">#define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \</span>
<span class="cp">        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">        Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); </span><span class="cm">/* NOLINT */</span><span class="cp"> \</span>
<span class="cp">        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\</span>
<span class="cp">        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \</span>
<span class="cp">        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\</span>
<span class="cp">        namespace {\</span>
<span class="cp">        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\</span>
<span class="cp">            INTERNAL_CATCH_TYPE_GEN\</span>
<span class="cp">            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\</span>
<span class="cp">            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\</span>
<span class="cp">            template&lt;typename...Types&gt; \</span>
<span class="cp">            struct TestName{\</span>
<span class="cp">                TestName(){\</span>
<span class="cp">                    int index = 0;                                    \</span>
<span class="cp">                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\</span>
<span class="cp">                    using expander = int[];\</span>
<span class="cp">                    (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index]), Tags } ), index++)... };</span><span class="cm">/* NOLINT */</span><span class="cp"> \</span>
<span class="cp">                }\</span>
<span class="cp">            };\</span>
<span class="cp">            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\</span>
<span class="cp">            TestName&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)&gt;();\</span>
<span class="cp">            return 0;\</span>
<span class="cp">        }();\</span>
<span class="cp">        }\</span>
<span class="cp">        }\</span>
<span class="cp">        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \</span>
<span class="cp">        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \</span>
<span class="cp">        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )</span>
<span class="cp">#else</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \</span>
<span class="cp">        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \</span>
<span class="cp">        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )</span>
<span class="cp">#else</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \</span>
<span class="cp">        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )</span>
<span class="cp">#endif</span>

    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \</span>
<span class="cp">        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS              \</span>
<span class="cp">        template&lt;typename TestType&gt; static void TestFuncName();       \</span>
<span class="cp">        namespace {\</span>
<span class="cp">        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \</span>
<span class="cp">            INTERNAL_CATCH_TYPE_GEN                                                  \</span>
<span class="cp">            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \</span>
<span class="cp">            template&lt;typename... Types&gt;                               \</span>
<span class="cp">            struct TestName {                                         \</span>
<span class="cp">                void reg_tests() {                                          \</span>
<span class="cp">                    int index = 0;                                    \</span>
<span class="cp">                    using expander = int[];                           \</span>
<span class="cp">                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\</span>
<span class="cp">                    constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\</span>
<span class="cp">                    constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\</span>
<span class="cp">                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestFuncName&lt;Types&gt; ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index / num_types]) + &quot;&lt;&quot; + std::string(types_list[index % num_types]) + &quot;&gt;&quot;, Tags } ), index++)... };</span><span class="cm">/* NOLINT */</span><span class="cp">\</span>
<span class="cp">                }                                                     \</span>
<span class="cp">            };                                                        \</span>
<span class="cp">            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \</span>
<span class="cp">                using TestInit = typename create&lt;TestName, decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)&gt;()), TypeList&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))&gt;&gt;::type; \</span>
<span class="cp">                TestInit t;                                           \</span>
<span class="cp">                t.reg_tests();                                        \</span>
<span class="cp">                return 0;                                             \</span>
<span class="cp">            }();                                                      \</span>
<span class="cp">        }                                                             \</span>
<span class="cp">        }                                                             \</span>
<span class="cp">        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \</span>
<span class="cp">        template&lt;typename TestType&gt;                                   \</span>
<span class="cp">        static void TestFuncName()</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\</span>
<span class="cp">        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)</span>
<span class="cp">#else</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\</span>
<span class="cp">        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\</span>
<span class="cp">        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)</span>
<span class="cp">#else</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\</span>
<span class="cp">        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )</span>
<span class="cp">#endif</span>

    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\</span>
<span class="cp">        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \</span>
<span class="cp">        template&lt;typename TestType&gt; static void TestFunc();       \</span>
<span class="cp">        namespace {\</span>
<span class="cp">        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\</span>
<span class="cp">        INTERNAL_CATCH_TYPE_GEN\</span>
<span class="cp">        template&lt;typename... Types&gt;                               \</span>
<span class="cp">        struct TestName {                                         \</span>
<span class="cp">            void reg_tests() {                                          \</span>
<span class="cp">                int index = 0;                                    \</span>
<span class="cp">                using expander = int[];                           \</span>
<span class="cp">                (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestFunc&lt;Types&gt; ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name &quot; - &quot; + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + &quot; - &quot; + std::to_string(index), Tags } ), index++)... };</span><span class="cm">/* NOLINT */</span><span class="cp">\</span>
<span class="cp">            }                                                     \</span>
<span class="cp">        };\</span>
<span class="cp">        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \</span>
<span class="cp">                using TestInit = typename convert&lt;TestName, TmplList&gt;::type; \</span>
<span class="cp">                TestInit t;                                           \</span>
<span class="cp">                t.reg_tests();                                        \</span>
<span class="cp">                return 0;                                             \</span>
<span class="cp">            }();                                                      \</span>
<span class="cp">        }}\</span>
<span class="cp">        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \</span>
<span class="cp">        template&lt;typename TestType&gt;                                   \</span>
<span class="cp">        static void TestFunc()</span>

    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \</span>
<span class="cp">        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, TmplList )</span>

    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \</span>
<span class="cp">        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \</span>
<span class="cp">        namespace {\</span>
<span class="cp">        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \</span>
<span class="cp">            INTERNAL_CATCH_TYPE_GEN\</span>
<span class="cp">            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\</span>
<span class="cp">            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\</span>
<span class="cp">            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\</span>
<span class="cp">            template&lt;typename...Types&gt; \</span>
<span class="cp">            struct TestNameClass{\</span>
<span class="cp">                TestNameClass(){\</span>
<span class="cp">                    int index = 0;                                    \</span>
<span class="cp">                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\</span>
<span class="cp">                    using expander = int[];\</span>
<span class="cp">                    (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index]), Tags } ), index++)... };</span><span class="cm">/* NOLINT */</span><span class="cp"> \</span>
<span class="cp">                }\</span>
<span class="cp">            };\</span>
<span class="cp">            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\</span>
<span class="cp">                TestNameClass&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)&gt;();\</span>
<span class="cp">                return 0;\</span>
<span class="cp">        }();\</span>
<span class="cp">        }\</span>
<span class="cp">        }\</span>
<span class="cp">        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \</span>
<span class="cp">        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \</span>
<span class="cp">        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )</span>
<span class="cp">#else</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \</span>
<span class="cp">        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \</span>
<span class="cp">        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )</span>
<span class="cp">#else</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \</span>
<span class="cp">        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )</span>
<span class="cp">#endif</span>

    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\</span>
<span class="cp">        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \</span>
<span class="cp">        template&lt;typename TestType&gt; \</span>
<span class="cp">            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName &lt;TestType&gt;) { \</span>
<span class="cp">                void test();\</span>
<span class="cp">            };\</span>
<span class="cp">        namespace {\</span>
<span class="cp">        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\</span>
<span class="cp">            INTERNAL_CATCH_TYPE_GEN                  \</span>
<span class="cp">            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\</span>
<span class="cp">            template&lt;typename...Types&gt;\</span>
<span class="cp">            struct TestNameClass{\</span>
<span class="cp">                void reg_tests(){\</span>
<span class="cp">                    int index = 0;\</span>
<span class="cp">                    using expander = int[];\</span>
<span class="cp">                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\</span>
<span class="cp">                    constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\</span>
<span class="cp">                    constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\</span>
<span class="cp">                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestName&lt;Types&gt;::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name &quot; - &quot; + std::string(tmpl_types[index / num_types]) + &quot;&lt;&quot; + std::string(types_list[index % num_types]) + &quot;&gt;&quot;, Tags } ), index++)... };</span><span class="cm">/* NOLINT */</span><span class="cp"> \</span>
<span class="cp">                }\</span>
<span class="cp">            };\</span>
<span class="cp">            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\</span>
<span class="cp">                using TestInit = typename create&lt;TestNameClass, decltype(get_wrapper&lt;INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)&gt;()), TypeList&lt;INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))&gt;&gt;::type;\</span>
<span class="cp">                TestInit t;\</span>
<span class="cp">                t.reg_tests();\</span>
<span class="cp">                return 0;\</span>
<span class="cp">            }(); \</span>
<span class="cp">        }\</span>
<span class="cp">        }\</span>
<span class="cp">        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \</span>
<span class="cp">        template&lt;typename TestType&gt; \</span>
<span class="cp">        void TestName&lt;TestType&gt;::test()</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\</span>
<span class="cp">        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )</span>
<span class="cp">#else</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\</span>
<span class="cp">        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\</span>
<span class="cp">        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )</span>
<span class="cp">#else</span>
    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\</span>
<span class="cp">        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )</span>
<span class="cp">#endif</span>

    <span class="cp">#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \</span>
<span class="cp">        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \</span>
<span class="cp">        template&lt;typename TestType&gt; \</span>
<span class="cp">        struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName &lt;TestType&gt;) { \</span>
<span class="cp">            void test();\</span>
<span class="cp">        };\</span>
<span class="cp">        namespace {\</span>
<span class="cp">        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \</span>
<span class="cp">            INTERNAL_CATCH_TYPE_GEN\</span>
<span class="cp">            template&lt;typename...Types&gt;\</span>
<span class="cp">            struct TestNameClass{\</span>
<span class="cp">                void reg_tests(){\</span>
<span class="cp">                    int index = 0;\</span>
<span class="cp">                    using expander = int[];\</span>
<span class="cp">                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &amp;TestName&lt;Types&gt;::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name &quot; - &quot; + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + &quot; - &quot; + std::to_string(index), Tags } ), index++)... };</span><span class="cm">/* NOLINT */</span><span class="cp"> \</span>
<span class="cp">                }\</span>
<span class="cp">            };\</span>
<span class="cp">            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\</span>
<span class="cp">                using TestInit = typename convert&lt;TestNameClass, TmplList&gt;::type;\</span>
<span class="cp">                TestInit t;\</span>
<span class="cp">                t.reg_tests();\</span>
<span class="cp">                return 0;\</span>
<span class="cp">            }(); \</span>
<span class="cp">        }}\</span>
<span class="cp">        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \</span>
<span class="cp">        template&lt;typename TestType&gt; \</span>
<span class="cp">        void TestName&lt;TestType&gt;::test()</span>

<span class="cp">#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \</span>
<span class="cp">        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, TmplList )</span>

<span class="c1">// end catch_test_registry.h</span>
<span class="c1">// start catch_capture.hpp</span>

<span class="c1">// start catch_assertionhandler.h</span>

<span class="c1">// start catch_assertioninfo.h</span>

<span class="c1">// start catch_result_type.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="c1">// ResultWas::OfType enum</span>
    <span class="k">struct</span> <span class="nc">ResultWas</span> <span class="p">{</span> <span class="k">enum</span> <span class="nc">OfType</span> <span class="p">{</span>
        <span class="n">Unknown</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">,</span>
        <span class="n">Ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">Info</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">Warning</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

        <span class="n">FailureBit</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>

        <span class="n">ExpressionFailed</span> <span class="o">=</span> <span class="n">FailureBit</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">ExplicitFailure</span> <span class="o">=</span> <span class="n">FailureBit</span> <span class="o">|</span> <span class="mi">2</span><span class="p">,</span>

        <span class="n">Exception</span> <span class="o">=</span> <span class="mh">0x100</span> <span class="o">|</span> <span class="n">FailureBit</span><span class="p">,</span>

        <span class="n">ThrewException</span> <span class="o">=</span> <span class="n">Exception</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">DidntThrowException</span> <span class="o">=</span> <span class="n">Exception</span> <span class="o">|</span> <span class="mi">2</span><span class="p">,</span>

        <span class="n">FatalErrorCondition</span> <span class="o">=</span> <span class="mh">0x200</span> <span class="o">|</span> <span class="n">FailureBit</span>

    <span class="p">};</span> <span class="p">};</span>

    <span class="kt">bool</span> <span class="nf">isOk</span><span class="p">(</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span> <span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">isJustInfo</span><span class="p">(</span> <span class="kt">int</span> <span class="n">flags</span> <span class="p">);</span>

    <span class="c1">// ResultDisposition::Flags enum</span>
    <span class="k">struct</span> <span class="nc">ResultDisposition</span> <span class="p">{</span> <span class="k">enum</span> <span class="nc">Flags</span> <span class="p">{</span>
        <span class="n">Normal</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>

        <span class="n">ContinueOnFailure</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>   <span class="c1">// Failures fail test, but execution continues</span>
        <span class="n">FalseTest</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>           <span class="c1">// Prefix expression with !</span>
        <span class="n">SuppressFail</span> <span class="o">=</span> <span class="mh">0x08</span>         <span class="c1">// Failures are reported but do not fail the test</span>
    <span class="p">};</span> <span class="p">};</span>

    <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Flags</span> <span class="k">operator</span> <span class="o">|</span> <span class="p">(</span> <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Flags</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Flags</span> <span class="n">rhs</span> <span class="p">);</span>

    <span class="kt">bool</span> <span class="nf">shouldContinueOnFailure</span><span class="p">(</span> <span class="kt">int</span> <span class="n">flags</span> <span class="p">);</span>
    <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">isFalseTest</span><span class="p">(</span> <span class="kt">int</span> <span class="n">flags</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">FalseTest</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">shouldSuppressFailure</span><span class="p">(</span> <span class="kt">int</span> <span class="n">flags</span> <span class="p">);</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_result_type.h</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">AssertionInfo</span>
    <span class="p">{</span>
        <span class="n">StringRef</span> <span class="n">macroName</span><span class="p">;</span>
        <span class="n">SourceLineInfo</span> <span class="n">lineInfo</span><span class="p">;</span>
        <span class="n">StringRef</span> <span class="n">capturedExpression</span><span class="p">;</span>
        <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Flags</span> <span class="n">resultDisposition</span><span class="p">;</span>

        <span class="c1">// We want to delete this constructor but a compiler bug in 4.8 means</span>
        <span class="c1">// the struct is then treated as non-aggregate</span>
        <span class="c1">//AssertionInfo() = delete;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_assertioninfo.h</span>
<span class="c1">// start catch_decomposer.h</span>

<span class="c1">// start catch_tostring.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="c1">// start catch_stream.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">cerr</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">clog</span><span class="p">();</span>

    <span class="k">class</span> <span class="nc">StringRef</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">IStream</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IStream</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">auto</span> <span class="nf">makeStream</span><span class="p">(</span> <span class="n">StringRef</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">filename</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IStream</span> <span class="k">const</span><span class="o">*</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">ReusableStringStream</span> <span class="o">:</span> <span class="n">NonCopyable</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_index</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">m_oss</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">ReusableStringStream</span><span class="p">();</span>
        <span class="o">~</span><span class="n">ReusableStringStream</span><span class="p">();</span>

        <span class="k">auto</span> <span class="nf">str</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ReusableStringStream</span><span class="o">&amp;</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">m_oss</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="n">get</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">m_oss</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// end catch_stream.h</span>
<span class="c1">// start catch_interfaces_enum_values_registry.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">EnumInfo</span> <span class="p">{</span>
            <span class="n">StringRef</span> <span class="n">m_name</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">StringRef</span><span class="o">&gt;&gt;</span> <span class="n">m_values</span><span class="p">;</span>

            <span class="o">~</span><span class="n">EnumInfo</span><span class="p">();</span>

            <span class="n">StringRef</span> <span class="nf">lookup</span><span class="p">(</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span> <span class="c1">// namespace Detail</span>

    <span class="k">struct</span> <span class="nc">IMutableEnumValuesRegistry</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IMutableEnumValuesRegistry</span><span class="p">();</span>

        <span class="k">virtual</span> <span class="n">Detail</span><span class="o">::</span><span class="n">EnumInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">registerEnum</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">enumName</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">allEnums</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">values</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">E</span><span class="o">&gt;</span>
        <span class="n">Detail</span><span class="o">::</span><span class="n">EnumInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">registerEnum</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">enumName</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">allEnums</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">values</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="s">&quot;Cannot serialize enum to int&quot;</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intValues</span><span class="p">;</span>
            <span class="n">intValues</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="nl">enumValue</span> <span class="p">:</span> <span class="n">values</span> <span class="p">)</span>
                <span class="n">intValues</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">enumValue</span> <span class="p">)</span> <span class="p">);</span>
            <span class="k">return</span> <span class="nf">registerEnum</span><span class="p">(</span> <span class="n">enumName</span><span class="p">,</span> <span class="n">allEnums</span><span class="p">,</span> <span class="n">intValues</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// Catch</span>

<span class="c1">// end catch_interfaces_enum_values_registry.h</span>

<span class="cp">#ifdef CATCH_CONFIG_CPP17_STRING_VIEW</span>
<span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __OBJC__</span>
<span class="c1">// start catch_objc_arc.hpp</span>

<span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="cp">#ifdef __has_feature</span>
<span class="cp">#define CATCH_ARC_ENABLED __has_feature(objc_arc)</span>
<span class="cp">#else</span>
<span class="cp">#define CATCH_ARC_ENABLED 0</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">arcSafeRelease</span><span class="p">(</span> <span class="n">NSObject</span><span class="o">*</span> <span class="n">obj</span> <span class="p">);</span>
<span class="n">id</span> <span class="nf">performOptionalSelector</span><span class="p">(</span> <span class="n">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">sel</span> <span class="p">);</span>

<span class="cp">#if !CATCH_ARC_ENABLED</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">arcSafeRelease</span><span class="p">(</span> <span class="n">NSObject</span><span class="o">*</span> <span class="n">obj</span> <span class="p">)</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">obj</span> <span class="n">release</span><span class="p">];</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="n">id</span> <span class="n">performOptionalSelector</span><span class="p">(</span> <span class="n">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">sel</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="p">[</span><span class="n">obj</span> <span class="nl">respondsToSelector</span><span class="p">:</span> <span class="n">sel</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">obj</span> <span class="nl">performSelector</span><span class="p">:</span> <span class="n">sel</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">nil</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define CATCH_UNSAFE_UNRETAINED</span>
<span class="cp">#define CATCH_ARC_STRONG</span>
<span class="cp">#else</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">arcSafeRelease</span><span class="p">(</span> <span class="n">NSObject</span><span class="o">*</span> <span class="p">){}</span>
<span class="kr">inline</span> <span class="n">id</span> <span class="n">performOptionalSelector</span><span class="p">(</span> <span class="n">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">sel</span> <span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic push</span>
<span class="cp">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span>
<span class="cp">#endif</span>
    <span class="k">if</span><span class="p">(</span> <span class="p">[</span><span class="n">obj</span> <span class="nl">respondsToSelector</span><span class="p">:</span> <span class="n">sel</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">obj</span> <span class="nl">performSelector</span><span class="p">:</span> <span class="n">sel</span><span class="p">];</span>
<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic pop</span>
<span class="cp">#endif</span>
    <span class="k">return</span> <span class="n">nil</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained</span>
<span class="cp">#define CATCH_ARC_STRONG __strong</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_objc_arc.hpp</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef _MSC_VER</span>
<span class="cp">#pragma warning(push)</span>
<span class="cp">#pragma warning(disable:4180) </span><span class="c1">// We attempt to stream a function (address) by const&amp;, which MSVC complains about but is harmless</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>

        <span class="k">extern</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">unprintableString</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rawMemoryToString</span><span class="p">(</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span> <span class="p">);</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rawMemoryToString</span><span class="p">(</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">object</span> <span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nf">rawMemoryToString</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">object</span><span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">class</span> <span class="nc">IsStreamInsertable</span> <span class="p">{</span>
            <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Stream</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="o">&gt;</span>
            <span class="k">static</span> <span class="k">auto</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
                <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Stream</span><span class="o">&amp;&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">());</span>

            <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span> <span class="k">typename</span><span class="o">&gt;</span>
            <span class="k">static</span> <span class="k">auto</span> <span class="n">test</span><span class="p">(...)</span><span class="o">-&gt;</span><span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">;</span>

        <span class="k">public</span><span class="o">:</span>
            <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="k">decltype</span><span class="p">(</span><span class="n">test</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">::</span><span class="n">value</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">E</span><span class="o">&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convertUnknownEnumToString</span><span class="p">(</span> <span class="n">E</span> <span class="n">e</span> <span class="p">);</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
            <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_enum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">convertUnstreamable</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">Detail</span><span class="o">::</span><span class="n">unprintableString</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
            <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_enum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">convertUnstreamable</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">is_enum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span>
        <span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">convertUnstreamable</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">convertUnknownEnumToString</span><span class="p">(</span> <span class="n">value</span> <span class="p">);</span>
        <span class="p">}</span>

<span class="cp">#if defined(_MANAGED)</span>
        <span class="c1">//! Convert a CLR string to a utf8 std::string</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">clrReferenceToString</span><span class="p">(</span> <span class="n">T</span><span class="o">^</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;null&quot;</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">System</span><span class="o">::</span><span class="n">Text</span><span class="o">::</span><span class="n">Encoding</span><span class="o">::</span><span class="n">UTF8</span><span class="o">-&gt;</span><span class="n">GetBytes</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">());</span>
            <span class="n">cli</span><span class="o">::</span><span class="n">pin_ptr</span><span class="o">&lt;</span><span class="n">System</span><span class="o">::</span><span class="n">Byte</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">bytes</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">);</span>
        <span class="p">}</span>
<span class="cp">#endif</span>

    <span class="p">}</span> <span class="c1">// namespace Detail</span>

    <span class="c1">// If we decide for C++14, change these to enable_if_ts</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fake</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span>
        <span class="k">static</span>
        <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">IsStreamInsertable</span><span class="o">&lt;</span><span class="n">Fake</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">type</span>
            <span class="n">convert</span><span class="p">(</span><span class="k">const</span> <span class="n">Fake</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
                <span class="c1">// NB: call using the function-like syntax to avoid ambiguity with</span>
                <span class="c1">// user-defined templated operator&lt;&lt; under clang.</span>
                <span class="n">rss</span><span class="p">.</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fake</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span>
        <span class="k">static</span>
        <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">IsStreamInsertable</span><span class="o">&lt;</span><span class="n">Fake</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">type</span>
            <span class="n">convert</span><span class="p">(</span> <span class="k">const</span> <span class="n">Fake</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
<span class="cp">#if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)</span>
            <span class="k">return</span> <span class="n">Detail</span><span class="o">::</span><span class="n">convertUnstreamable</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="cp">#else</span>
            <span class="k">return</span> <span class="nf">CATCH_CONFIG_FALLBACK_STRINGIFIER</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="cp">#endif</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>

        <span class="c1">// This function dispatches all stringification requests inside of Catch.</span>
        <span class="c1">// Should be preferably called fully qualified, like ::Catch::Detail::stringify</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">stringify</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">StringMaker</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">remove_cv</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">E</span><span class="o">&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convertUnknownEnumToString</span><span class="p">(</span> <span class="n">E</span> <span class="n">e</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
        <span class="p">}</span>

<span class="cp">#if defined(_MANAGED)</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">stringify</span><span class="p">(</span> <span class="n">T</span><span class="o">^</span> <span class="n">e</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">StringMaker</span><span class="o">&lt;</span><span class="n">T</span><span class="o">^&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
<span class="cp">#endif</span>

    <span class="p">}</span> <span class="c1">// namespace Detail</span>

    <span class="c1">// Some predefined specializations</span>

    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
    <span class="p">};</span>

<span class="cp">#ifdef CATCH_CONFIG_CPP17_STRING_VIEW</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">str</span><span class="p">);</span>
    <span class="p">};</span>
<span class="cp">#endif</span>

    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">str</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">);</span>
    <span class="p">};</span>

<span class="cp">#ifdef CATCH_CONFIG_WCHAR</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&amp;</span> <span class="n">wstr</span><span class="p">);</span>
    <span class="p">};</span>

<span class="cp"># ifdef CATCH_CONFIG_CPP17_STRING_VIEW</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">wstring_view</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">wstring_view</span> <span class="n">str</span><span class="p">);</span>
    <span class="p">};</span>
<span class="cp"># endif</span>

    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">wchar_t</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">wchar_t</span> <span class="k">const</span> <span class="o">*</span> <span class="n">str</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">wchar_t</span> <span class="o">*&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span> <span class="n">str</span><span class="p">);</span>
    <span class="p">};</span>
<span class="cp">#endif</span>

    <span class="c1">// TBD: Should we use `strnlen` to ensure that we don&#39;t go out of the buffer,</span>
    <span class="c1">//      while keeping string semantics?</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">SZ</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">[</span><span class="n">SZ</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span> <span class="n">str</span> <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">SZ</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">signed</span> <span class="kt">char</span><span class="p">[</span><span class="n">SZ</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">SZ</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">[</span><span class="n">SZ</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="cp">#if defined(CATCH_CONFIG_CPP17_BYTE)</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">};</span>
<span class="cp">#endif </span><span class="c1">// defined(CATCH_CONFIG_CPP17_BYTE)</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">long</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">signed</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">char</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">float</span> <span class="n">value</span><span class="p">);</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">precision</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="kt">double</span> <span class="n">value</span><span class="p">);</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">precision</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="o">&gt;</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">U</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">rawMemoryToString</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="s">&quot;nullptr&quot;</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">R</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">C</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">R</span> <span class="n">C</span><span class="o">::*&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">R</span> <span class="n">C</span><span class="o">::*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">rawMemoryToString</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="s">&quot;nullptr&quot;</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="cp">#if defined(_MANAGED)</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">T</span><span class="o">^&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span> <span class="n">T</span><span class="o">^</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">clrReferenceToString</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="cp">#endif</span>

    <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Sentinel</span> <span class="o">=</span> <span class="n">InputIterator</span><span class="o">&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rangeToString</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Sentinel</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{ &quot;</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span>
                <span class="k">for</span> <span class="p">(</span><span class="o">++</span><span class="n">first</span><span class="p">;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
                    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; }&quot;</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="cp">#ifdef __OBJC__</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">NSString</span><span class="o">*&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span> <span class="n">nsstring</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nsstring</span><span class="p">)</span>
                <span class="k">return</span> <span class="s">&quot;nil&quot;</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;@&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">nsstring</span> <span class="n">UTF8String</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">NSObject</span><span class="o">*&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">NSObject</span><span class="o">*</span> <span class="n">nsObject</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">([</span><span class="n">nsObject</span> <span class="n">description</span><span class="p">]);</span>
        <span class="p">}</span>

    <span class="p">};</span>
    <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
        <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">stringify</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">nsstring</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="n">NSString</span><span class="o">*&gt;::</span><span class="n">convert</span><span class="p">(</span> <span class="n">nsstring</span> <span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="c1">// namespace Detail</span>
<span class="cp">#endif </span><span class="c1">// __OBJC__</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">//////////////////////////////////////////////////////</span>
<span class="c1">// Separate std-lib types stringification, so it can be selectively enabled</span>
<span class="c1">// This means that we do not bring in</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)</span>
<span class="cp">#  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER</span>
<span class="cp">#  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER</span>
<span class="cp">#  define CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER</span>
<span class="cp">#  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER</span>
<span class="cp">#  define CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER</span>
<span class="cp">#endif</span>

<span class="c1">// Separate std::pair specialization</span>
<span class="cp">#if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)</span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;&amp;</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{ &quot;</span>
                <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span>
                <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">)</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot; }&quot;</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER) &amp;&amp; defined(CATCH_CONFIG_CPP17_OPTIONAL)</span>
<span class="cp">#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">optional</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">optional</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="o">*</span><span class="n">optional</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{ }&quot;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER</span>

<span class="c1">// Separate std::tuple specialization</span>
<span class="cp">#if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)</span>
<span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span>
            <span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="kt">bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
            <span class="o">&gt;</span>
            <span class="k">struct</span> <span class="nc">TupleElementPrinter</span> <span class="p">{</span>
            <span class="k">static</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span> <span class="n">tuple</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">?</span> <span class="s">&quot;, &quot;</span> <span class="o">:</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
                    <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">));</span>
                <span class="n">TupleElementPrinter</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">print</span><span class="p">(</span><span class="n">tuple</span><span class="p">,</span> <span class="n">os</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">template</span><span class="o">&lt;</span>
            <span class="k">typename</span> <span class="nc">Tuple</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span>
        <span class="o">&gt;</span>
            <span class="k">struct</span> <span class="nc">TupleElementPrinter</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">static</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="k">const</span> <span class="n">Tuple</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
        <span class="p">};</span>

    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span><span class="n">Types</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">tuple</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;{&#39;</span><span class="p">;</span>
            <span class="n">Detail</span><span class="o">::</span><span class="n">TupleElementPrinter</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;::</span><span class="n">print</span><span class="p">(</span><span class="n">tuple</span><span class="p">,</span> <span class="n">rss</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; }&quot;</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER) &amp;&amp; defined(CATCH_CONFIG_CPP17_VARIANT)</span>
<span class="cp">#include</span> <span class="cpf">&lt;variant&gt;</span><span class="cp"></span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">monostate</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">monostate</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;{ }&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Elements</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">Elements</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">Elements</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">variant</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">variant</span><span class="p">.</span><span class="n">valueless_by_exception</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">return</span> <span class="s">&quot;{valueless variant}&quot;</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span>
                    <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
                    <span class="p">},</span>
                    <span class="n">variant</span>
                <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="c1">// Import begin/ end from std here</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">;</span>

    <span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">void_type</span> <span class="p">{</span>
            <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="kt">void</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">is_range_impl</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{</span>
        <span class="p">};</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">is_range_impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">void_type</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()))</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{</span>
        <span class="p">};</span>
    <span class="p">}</span> <span class="c1">// namespace detail</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">is_range</span> <span class="o">:</span> <span class="n">detail</span><span class="o">::</span><span class="n">is_range_impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">};</span>

<span class="cp">#if defined(_MANAGED) </span><span class="c1">// Managed types are never ranges</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">is_range</span><span class="o">&lt;</span><span class="n">T</span><span class="o">^&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>
<span class="cp">#endif</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Range</span><span class="o">&gt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rangeToString</span><span class="p">(</span> <span class="n">Range</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">range</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">rangeToString</span><span class="p">(</span> <span class="n">begin</span><span class="p">(</span> <span class="n">range</span> <span class="p">),</span> <span class="n">end</span><span class="p">(</span> <span class="n">range</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Handle vector&lt;bool&gt; specially</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Allocator</span><span class="o">&gt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rangeToString</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
        <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{ &quot;</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">bool</span> <span class="nl">b</span> <span class="p">:</span> <span class="n">v</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">first</span> <span class="p">)</span>
                <span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">b</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; }&quot;</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">R</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">is_range</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="o">!::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">IsStreamInsertable</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span> <span class="n">R</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">range</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">rangeToString</span><span class="p">(</span> <span class="n">range</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SZ</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[</span><span class="n">SZ</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="n">SZ</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">rangeToString</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// Separate std::chrono::duration specialization</span>
<span class="cp">#if defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)</span>
<span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ratio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ratio</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">ratio_string</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">symbol</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ratio</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ratio_string</span><span class="o">&lt;</span><span class="n">Ratio</span><span class="o">&gt;::</span><span class="n">symbol</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Catch</span><span class="o">::</span><span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;[&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">Ratio</span><span class="o">::</span><span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;/&#39;</span>
        <span class="o">&lt;&lt;</span> <span class="n">Ratio</span><span class="o">::</span><span class="n">den</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;]&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="nc">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">atto</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">symbol</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="nc">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">femto</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">symbol</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="nc">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pico</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">symbol</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="nc">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">nano</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">symbol</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="nc">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">micro</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">symbol</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="nc">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">symbol</span><span class="p">();</span>
<span class="p">};</span>

    <span class="c1">////////////</span>
    <span class="c1">// std::chrono::duration specializations</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Value</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Ratio</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">Ratio</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">Ratio</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">duration</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">ratio_string</span><span class="o">&lt;</span><span class="n">Ratio</span><span class="o">&gt;::</span><span class="n">symbol</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;s&#39;</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Value</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">duration</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Value</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">60</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">60</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">duration</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; m&quot;</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Value</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">3600</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">3600</span><span class="o">&gt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">duration</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; h&quot;</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">////////////</span>
    <span class="c1">// std::chrono::time_point specialization</span>
    <span class="c1">// Generic time_point cannot be specialized, only std::chrono::time_point&lt;system_clock&gt;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Duration</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">Clock</span><span class="p">,</span> <span class="n">Duration</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">Clock</span><span class="p">,</span> <span class="n">Duration</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">time_point</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">time_point</span><span class="p">.</span><span class="n">time_since_epoch</span><span class="p">())</span> <span class="o">+</span> <span class="s">&quot; since epoch&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="c1">// std::chrono::time_point&lt;system_clock&gt; specialization</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="p">,</span> <span class="n">Duration</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="p">,</span> <span class="n">Duration</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">time_point</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">converted</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">time_point</span><span class="p">);</span>

<span class="cp">#ifdef _MSC_VER</span>
            <span class="n">std</span><span class="o">::</span><span class="n">tm</span> <span class="n">timeInfo</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">gmtime_s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">converted</span><span class="p">);</span>
<span class="cp">#else</span>
            <span class="n">std</span><span class="o">::</span><span class="n">tm</span><span class="o">*</span> <span class="n">timeInfo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">gmtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">converted</span><span class="p">);</span>
<span class="cp">#endif</span>

            <span class="k">auto</span> <span class="k">const</span> <span class="n">timeStampSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;2017-01-16T17:06:45Z&quot;</span><span class="p">);</span>
            <span class="kt">char</span> <span class="n">timeStamp</span><span class="p">[</span><span class="n">timeStampSize</span><span class="p">];</span>
            <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">fmt</span> <span class="o">=</span> <span class="s">&quot;%Y-%m-%dT%H:%M:%SZ&quot;</span><span class="p">;</span>

<span class="cp">#ifdef _MSC_VER</span>
            <span class="n">std</span><span class="o">::</span><span class="n">strftime</span><span class="p">(</span><span class="n">timeStamp</span><span class="p">,</span> <span class="n">timeStampSize</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeInfo</span><span class="p">);</span>
<span class="cp">#else</span>
            <span class="n">std</span><span class="o">::</span><span class="n">strftime</span><span class="p">(</span><span class="n">timeStamp</span><span class="p">,</span> <span class="n">timeStampSize</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">timeInfo</span><span class="p">);</span>
<span class="cp">#endif</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">timeStamp</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER</span>

<span class="cp">#define INTERNAL_CATCH_REGISTER_ENUM( enumName, ... ) \</span>
<span class="cp">namespace Catch { \</span>
<span class="cp">    template&lt;&gt; struct StringMaker&lt;enumName&gt; { \</span>
<span class="cp">        static std::string convert( enumName value ) { \</span>
<span class="cp">            static const auto&amp; enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, { __VA_ARGS__ } ); \</span>
<span class="cp">            return static_cast&lt;std::string&gt;(enumInfo.lookup( static_cast&lt;int&gt;( value ) )); \</span>
<span class="cp">        } \</span>
<span class="cp">    }; \</span>
<span class="cp">}</span>

<span class="cp">#define CATCH_REGISTER_ENUM( enumName, ... ) INTERNAL_CATCH_REGISTER_ENUM( enumName, __VA_ARGS__ )</span>

<span class="cp">#ifdef _MSC_VER</span>
<span class="cp">#pragma warning(pop)</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_tostring.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"></span>

<span class="cp">#ifdef _MSC_VER</span>
<span class="cp">#pragma warning(push)</span>
<span class="cp">#pragma warning(disable:4389) </span><span class="c1">// &#39;==&#39; : signed/unsigned mismatch</span>
<span class="cp">#pragma warning(disable:4018) </span><span class="c1">// more &quot;signed/unsigned mismatch&quot;</span>
<span class="cp">#pragma warning(disable:4312) </span><span class="c1">// Converting int to T* using reinterpret_cast (issue on x64 platform)</span>
<span class="cp">#pragma warning(disable:4180) </span><span class="c1">// qualifier applied to function type has no meaning</span>
<span class="cp">#pragma warning(disable:4800) </span><span class="c1">// Forcing result to true or false</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">ITransientExpression</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="nf">isBinaryExpression</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_isBinaryExpression</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">auto</span> <span class="nf">getResult</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_result</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">streamReconstructedExpression</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">ITransientExpression</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">isBinaryExpression</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">result</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">m_isBinaryExpression</span><span class="p">(</span> <span class="n">isBinaryExpression</span> <span class="p">),</span>
            <span class="n">m_result</span><span class="p">(</span> <span class="n">result</span> <span class="p">)</span>
        <span class="p">{}</span>

        <span class="c1">// We don&#39;t actually need a virtual destructor, but many static analysers</span>
        <span class="c1">// complain if it&#39;s not here :-(</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">ITransientExpression</span><span class="p">();</span>

        <span class="kt">bool</span> <span class="n">m_isBinaryExpression</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_result</span><span class="p">;</span>

    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">formatReconstructedExpression</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">op</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">);</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LhsT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">BinaryExpr</span>  <span class="o">:</span> <span class="k">public</span> <span class="n">ITransientExpression</span> <span class="p">{</span>
        <span class="n">LhsT</span> <span class="n">m_lhs</span><span class="p">;</span>
        <span class="n">StringRef</span> <span class="n">m_op</span><span class="p">;</span>
        <span class="n">RhsT</span> <span class="n">m_rhs</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">streamReconstructedExpression</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">formatReconstructedExpression</span>
                    <span class="p">(</span> <span class="n">os</span><span class="p">,</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_lhs</span> <span class="p">),</span> <span class="n">m_op</span><span class="p">,</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_rhs</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">BinaryExpr</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">comparisonResult</span><span class="p">,</span> <span class="n">LhsT</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">op</span><span class="p">,</span> <span class="n">RhsT</span> <span class="n">rhs</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">ITransientExpression</span><span class="p">{</span> <span class="nb">true</span><span class="p">,</span> <span class="n">comparisonResult</span> <span class="p">},</span>
            <span class="n">m_lhs</span><span class="p">(</span> <span class="n">lhs</span> <span class="p">),</span>
            <span class="n">m_op</span><span class="p">(</span> <span class="n">op</span> <span class="p">),</span>
            <span class="n">m_rhs</span><span class="p">(</span> <span class="n">rhs</span> <span class="p">)</span>
        <span class="p">{}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="n">always_false</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;chained comparisons are not supported inside assertions, &quot;</span>
            <span class="s">&quot;wrap the expression inside parentheses, or decompose it&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">||</span> <span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="n">always_false</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;chained comparisons are not supported inside assertions, &quot;</span>
            <span class="s">&quot;wrap the expression inside parentheses, or decompose it&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="n">always_false</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;chained comparisons are not supported inside assertions, &quot;</span>
            <span class="s">&quot;wrap the expression inside parentheses, or decompose it&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">!=</span> <span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="n">always_false</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;chained comparisons are not supported inside assertions, &quot;</span>
            <span class="s">&quot;wrap the expression inside parentheses, or decompose it&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&gt;</span> <span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="n">always_false</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;chained comparisons are not supported inside assertions, &quot;</span>
            <span class="s">&quot;wrap the expression inside parentheses, or decompose it&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="n">always_false</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;chained comparisons are not supported inside assertions, &quot;</span>
            <span class="s">&quot;wrap the expression inside parentheses, or decompose it&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&gt;=</span> <span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="n">always_false</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;chained comparisons are not supported inside assertions, &quot;</span>
            <span class="s">&quot;wrap the expression inside parentheses, or decompose it&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;=</span> <span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="n">always_false</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;chained comparisons are not supported inside assertions, &quot;</span>
            <span class="s">&quot;wrap the expression inside parentheses, or decompose it&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LhsT</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">UnaryExpr</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ITransientExpression</span> <span class="p">{</span>
        <span class="n">LhsT</span> <span class="n">m_lhs</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">streamReconstructedExpression</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_lhs</span> <span class="p">);</span>
        <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="k">explicit</span> <span class="n">UnaryExpr</span><span class="p">(</span> <span class="n">LhsT</span> <span class="n">lhs</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">ITransientExpression</span><span class="p">{</span> <span class="nb">false</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="p">},</span>
            <span class="n">m_lhs</span><span class="p">(</span> <span class="n">lhs</span> <span class="p">)</span>
        <span class="p">{}</span>
    <span class="p">};</span>

    <span class="c1">// Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LhsT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">compareEqual</span><span class="p">(</span> <span class="n">LhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">compareEqual</span><span class="p">(</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">lhs</span> <span class="o">==</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">rhs</span> <span class="p">);</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">compareEqual</span><span class="p">(</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">lhs</span> <span class="o">==</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">rhs</span> <span class="p">);</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">compareEqual</span><span class="p">(</span> <span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">lhs</span> <span class="p">)</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">compareEqual</span><span class="p">(</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">lhs</span> <span class="p">)</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LhsT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">compareNotEqual</span><span class="p">(</span> <span class="n">LhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">RhsT</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">compareNotEqual</span><span class="p">(</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">lhs</span> <span class="o">!=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">rhs</span> <span class="p">);</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">compareNotEqual</span><span class="p">(</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">long</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">lhs</span> <span class="o">!=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">rhs</span> <span class="p">);</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">compareNotEqual</span><span class="p">(</span> <span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">lhs</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">compareNotEqual</span><span class="p">(</span> <span class="kt">long</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">lhs</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LhsT</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">ExprLhs</span> <span class="p">{</span>
        <span class="n">LhsT</span> <span class="n">m_lhs</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">explicit</span> <span class="n">ExprLhs</span><span class="p">(</span> <span class="n">LhsT</span> <span class="n">lhs</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_lhs</span><span class="p">(</span> <span class="n">lhs</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">compareEqual</span><span class="p">(</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">),</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;==&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="kt">bool</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">m_lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;==&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">!=</span> <span class="p">(</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">compareNotEqual</span><span class="p">(</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">),</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;!=&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">!=</span> <span class="p">(</span> <span class="kt">bool</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">m_lhs</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;!=&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&gt;</span> <span class="p">(</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_lhs</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="p">),</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_lhs</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">),</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&gt;=</span> <span class="p">(</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_lhs</span> <span class="o">&gt;=</span> <span class="n">rhs</span><span class="p">),</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;=</span> <span class="p">(</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_lhs</span> <span class="o">&lt;=</span> <span class="n">rhs</span><span class="p">),</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">|</span> <span class="p">(</span><span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_lhs</span> <span class="o">|</span> <span class="n">rhs</span><span class="p">),</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;|&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_lhs</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">),</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;&amp;&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">^</span> <span class="p">(</span><span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_lhs</span> <span class="o">^</span> <span class="n">rhs</span><span class="p">),</span> <span class="n">m_lhs</span><span class="p">,</span> <span class="s">&quot;^&quot;</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">};</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="n">always_false</span><span class="o">&lt;</span><span class="n">RhsT</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;operator&amp;&amp; is not supported inside assertions, &quot;</span>
            <span class="s">&quot;wrap the expression inside parentheses, or decompose it&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">RhsT</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">||</span> <span class="p">(</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="p">,</span> <span class="n">RhsT</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">static_assert</span><span class="p">(</span><span class="n">always_false</span><span class="o">&lt;</span><span class="n">RhsT</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;operator|| is not supported inside assertions, &quot;</span>
            <span class="s">&quot;wrap the expression inside parentheses, or decompose it&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">makeUnaryExpr</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">UnaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">UnaryExpr</span><span class="o">&lt;</span><span class="n">LhsT</span><span class="o">&gt;</span><span class="p">{</span> <span class="n">m_lhs</span> <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">handleExpression</span><span class="p">(</span> <span class="n">ITransientExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">expr</span> <span class="p">);</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">handleExpression</span><span class="p">(</span> <span class="n">ExprLhs</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">expr</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">handleExpression</span><span class="p">(</span> <span class="n">expr</span><span class="p">.</span><span class="n">makeUnaryExpr</span><span class="p">()</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="nc">Decomposer</span> <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;=</span> <span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExprLhs</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ExprLhs</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">{</span> <span class="n">lhs</span> <span class="p">};</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;=</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">value</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExprLhs</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ExprLhs</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">{</span> <span class="n">value</span> <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#ifdef _MSC_VER</span>
<span class="cp">#pragma warning(pop)</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_decomposer.h</span>
<span class="c1">// start catch_interfaces_capture.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">AssertionResult</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">AssertionInfo</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">SectionInfo</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">SectionEndInfo</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">MessageInfo</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">MessageBuilder</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">Counts</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">AssertionReaction</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">SourceLineInfo</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">ITransientExpression</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IGeneratorTracker</span><span class="p">;</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
    <span class="k">struct</span> <span class="nc">BenchmarkInfo</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">nano</span><span class="o">&gt;&gt;</span>
    <span class="k">struct</span> <span class="nc">BenchmarkStats</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

    <span class="k">struct</span> <span class="nc">IResultCapture</span> <span class="p">{</span>

        <span class="k">virtual</span> <span class="o">~</span><span class="n">IResultCapture</span><span class="p">();</span>

        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">sectionStarted</span><span class="p">(</span>    <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionInfo</span><span class="p">,</span>
                                        <span class="n">Counts</span><span class="o">&amp;</span> <span class="n">assertions</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">sectionEnded</span><span class="p">(</span> <span class="n">SectionEndInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">endInfo</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">sectionEndedEarly</span><span class="p">(</span> <span class="n">SectionEndInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">endInfo</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">acquireGeneratorTracker</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">generatorName</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IGeneratorTracker</span><span class="o">&amp;</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">benchmarkPreparing</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">benchmarkStarting</span><span class="p">(</span> <span class="n">BenchmarkInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">benchmarkEnded</span><span class="p">(</span> <span class="n">BenchmarkStats</span><span class="o">&lt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stats</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">benchmarkFailed</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">error</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">pushScopedMessage</span><span class="p">(</span> <span class="n">MessageInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">popScopedMessage</span><span class="p">(</span> <span class="n">MessageInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">emplaceUnscopedMessage</span><span class="p">(</span> <span class="n">MessageBuilder</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">builder</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handleFatalErrorCondition</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">message</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handleExpr</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
                    <span class="n">ITransientExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">expr</span><span class="p">,</span>
                    <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handleMessage</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
                    <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span>
                    <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">,</span>
                    <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handleUnexpectedExceptionNotThrown</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
                    <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handleUnexpectedInflightException</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">,</span>
                    <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handleIncomplete</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handleNonExpr</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span>
                    <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span>
                    <span class="n">AssertionReaction</span> <span class="o">&amp;</span><span class="n">reaction</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">lastAssertionPassed</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">assertionPassed</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// Deprecated, do not use:</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getCurrentTestName</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="k">const</span> <span class="n">AssertionResult</span><span class="o">*</span> <span class="n">getLastResult</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">exceptionEarlyReported</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">IResultCapture</span><span class="o">&amp;</span> <span class="nf">getResultCapture</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// end catch_interfaces_capture.h</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">TestFailureException</span><span class="p">{};</span>
    <span class="k">struct</span> <span class="nc">AssertionResultData</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IResultCapture</span><span class="p">;</span>
    <span class="k">class</span> <span class="nc">RunContext</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">LazyExpression</span> <span class="p">{</span>
        <span class="k">friend</span> <span class="k">class</span> <span class="nc">AssertionHandler</span><span class="p">;</span>
        <span class="k">friend</span> <span class="k">struct</span> <span class="nc">AssertionStats</span><span class="p">;</span>
        <span class="k">friend</span> <span class="k">class</span> <span class="nc">RunContext</span><span class="p">;</span>

        <span class="n">ITransientExpression</span> <span class="k">const</span><span class="o">*</span> <span class="n">m_transientExpression</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_isNegated</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">LazyExpression</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">isNegated</span> <span class="p">);</span>
        <span class="n">LazyExpression</span><span class="p">(</span> <span class="n">LazyExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">);</span>
        <span class="n">LazyExpression</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">LazyExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="k">friend</span> <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">LazyExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lazyExpr</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">AssertionReaction</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">shouldDebugBreak</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">shouldThrow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">AssertionHandler</span> <span class="p">{</span>
        <span class="n">AssertionInfo</span> <span class="n">m_assertionInfo</span><span class="p">;</span>
        <span class="n">AssertionReaction</span> <span class="n">m_reaction</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_completed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">IResultCapture</span><span class="o">&amp;</span> <span class="n">m_resultCapture</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">AssertionHandler</span>
            <span class="p">(</span>   <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">macroName</span><span class="p">,</span>
                <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span><span class="p">,</span>
                <span class="n">StringRef</span> <span class="n">capturedExpression</span><span class="p">,</span>
                <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Flags</span> <span class="n">resultDisposition</span> <span class="p">);</span>
        <span class="o">~</span><span class="n">AssertionHandler</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">m_completed</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">m_resultCapture</span><span class="p">.</span><span class="n">handleIncomplete</span><span class="p">(</span> <span class="n">m_assertionInfo</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="kt">void</span> <span class="n">handleExpr</span><span class="p">(</span> <span class="n">ExprLhs</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">expr</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">handleExpr</span><span class="p">(</span> <span class="n">expr</span><span class="p">.</span><span class="n">makeUnaryExpr</span><span class="p">()</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">handleExpr</span><span class="p">(</span> <span class="n">ITransientExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">expr</span> <span class="p">);</span>

        <span class="kt">void</span> <span class="nf">handleMessage</span><span class="p">(</span><span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">handleExceptionThrownAsExpected</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">handleUnexpectedExceptionNotThrown</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">handleExceptionNotThrownAsExpected</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">handleThrowingCallSkipped</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">handleUnexpectedInflightException</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">complete</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">setCompleted</span><span class="p">();</span>

        <span class="c1">// query</span>
        <span class="k">auto</span> <span class="nf">allowThrows</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">handleExceptionMatchExpr</span><span class="p">(</span> <span class="n">AssertionHandler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matcherString</span> <span class="p">);</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_assertionhandler.h</span>
<span class="c1">// start catch_message.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">MessageInfo</span> <span class="p">{</span>
        <span class="n">MessageInfo</span><span class="p">(</span>    <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_macroName</span><span class="p">,</span>
                        <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_lineInfo</span><span class="p">,</span>
                        <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">_type</span> <span class="p">);</span>

        <span class="n">StringRef</span> <span class="n">macroName</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">;</span>
        <span class="n">SourceLineInfo</span> <span class="n">lineInfo</span><span class="p">;</span>
        <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">type</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sequence</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="n">MessageInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span> <span class="n">MessageInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">globalCount</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">MessageStream</span> <span class="p">{</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">MessageStream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_stream</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ReusableStringStream</span> <span class="n">m_stream</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">MessageBuilder</span> <span class="o">:</span> <span class="n">MessageStream</span> <span class="p">{</span>
        <span class="n">MessageBuilder</span><span class="p">(</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">macroName</span><span class="p">,</span>
                        <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span><span class="p">,</span>
                        <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">type</span> <span class="p">);</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">MessageBuilder</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_stream</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">MessageInfo</span> <span class="n">m_info</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">ScopedMessage</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">explicit</span> <span class="n">ScopedMessage</span><span class="p">(</span> <span class="n">MessageBuilder</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">builder</span> <span class="p">);</span>
        <span class="n">ScopedMessage</span><span class="p">(</span> <span class="n">ScopedMessage</span><span class="o">&amp;</span> <span class="n">duplicate</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">ScopedMessage</span><span class="p">(</span> <span class="n">ScopedMessage</span><span class="o">&amp;&amp;</span> <span class="n">old</span> <span class="p">);</span>
        <span class="o">~</span><span class="n">ScopedMessage</span><span class="p">();</span>

        <span class="n">MessageInfo</span> <span class="n">m_info</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_moved</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Capturer</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MessageInfo</span><span class="o">&gt;</span> <span class="n">m_messages</span><span class="p">;</span>
        <span class="n">IResultCapture</span><span class="o">&amp;</span> <span class="n">m_resultCapture</span> <span class="o">=</span> <span class="n">getResultCapture</span><span class="p">();</span>
        <span class="kt">size_t</span> <span class="n">m_captured</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Capturer</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">macroName</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span><span class="p">,</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">names</span> <span class="p">);</span>
        <span class="o">~</span><span class="n">Capturer</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">captureValue</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">);</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="kt">void</span> <span class="n">captureValues</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">captureValue</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
        <span class="kt">void</span> <span class="n">captureValues</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">Ts</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">values</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">captureValue</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">);</span>
            <span class="n">captureValues</span><span class="p">(</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">values</span><span class="p">...</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_message.h</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE)</span>

<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)</span>
  <span class="cp">#define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__</span>
<span class="cp">#else</span>
  <span class="cp">#define CATCH_INTERNAL_STRINGIFY(...) &quot;Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Another way to speed-up compilation is to omit local try-catch for REQUIRE*</span>
<span class="c1">// macros.</span>
<span class="cp">#define INTERNAL_CATCH_TRY</span>
<span class="cp">#define INTERNAL_CATCH_CATCH( capturer )</span>

<span class="cp">#else </span><span class="c1">// CATCH_CONFIG_FAST_COMPILE</span>

<span class="cp">#define INTERNAL_CATCH_TRY try</span>
<span class="cp">#define INTERNAL_CATCH_CATCH( handler ) catch(...) { handler.handleUnexpectedInflightException(); }</span>

<span class="cp">#endif</span>

<span class="cp">#define INTERNAL_CATCH_REACT( handler ) handler.complete();</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \</span>
<span class="cp">    do { \</span>
<span class="cp">        CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \</span>
<span class="cp">        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \</span>
<span class="cp">        INTERNAL_CATCH_TRY { \</span>
<span class="cp">            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \</span>
<span class="cp">            catchAssertionHandler.handleExpr( Catch::Decomposer() &lt;= __VA_ARGS__ ); \</span>
<span class="cp">            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \</span>
<span class="cp">        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \</span>
<span class="cp">        INTERNAL_CATCH_REACT( catchAssertionHandler ) \</span>
<span class="cp">    } while( (void)0, (false) &amp;&amp; static_cast&lt;bool&gt;( !!(__VA_ARGS__) ) )</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \</span>
<span class="cp">    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \</span>
<span class="cp">    if( Catch::getResultCapture().lastAssertionPassed() )</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \</span>
<span class="cp">    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \</span>
<span class="cp">    if( !Catch::getResultCapture().lastAssertionPassed() )</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \</span>
<span class="cp">    do { \</span>
<span class="cp">        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \</span>
<span class="cp">        try { \</span>
<span class="cp">            static_cast&lt;void&gt;(__VA_ARGS__); \</span>
<span class="cp">            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \</span>
<span class="cp">        } \</span>
<span class="cp">        catch( ... ) { \</span>
<span class="cp">            catchAssertionHandler.handleUnexpectedInflightException(); \</span>
<span class="cp">        } \</span>
<span class="cp">        INTERNAL_CATCH_REACT( catchAssertionHandler ) \</span>
<span class="cp">    } while( false )</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \</span>
<span class="cp">    do { \</span>
<span class="cp">        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \</span>
<span class="cp">        if( catchAssertionHandler.allowThrows() ) \</span>
<span class="cp">            try { \</span>
<span class="cp">                static_cast&lt;void&gt;(__VA_ARGS__); \</span>
<span class="cp">                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \</span>
<span class="cp">            } \</span>
<span class="cp">            catch( ... ) { \</span>
<span class="cp">                catchAssertionHandler.handleExceptionThrownAsExpected(); \</span>
<span class="cp">            } \</span>
<span class="cp">        else \</span>
<span class="cp">            catchAssertionHandler.handleThrowingCallSkipped(); \</span>
<span class="cp">        INTERNAL_CATCH_REACT( catchAssertionHandler ) \</span>
<span class="cp">    } while( false )</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \</span>
<span class="cp">    do { \</span>
<span class="cp">        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \</span>
<span class="cp">        if( catchAssertionHandler.allowThrows() ) \</span>
<span class="cp">            try { \</span>
<span class="cp">                static_cast&lt;void&gt;(expr); \</span>
<span class="cp">                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \</span>
<span class="cp">            } \</span>
<span class="cp">            catch( exceptionType const&amp; ) { \</span>
<span class="cp">                catchAssertionHandler.handleExceptionThrownAsExpected(); \</span>
<span class="cp">            } \</span>
<span class="cp">            catch( ... ) { \</span>
<span class="cp">                catchAssertionHandler.handleUnexpectedInflightException(); \</span>
<span class="cp">            } \</span>
<span class="cp">        else \</span>
<span class="cp">            catchAssertionHandler.handleThrowingCallSkipped(); \</span>
<span class="cp">        INTERNAL_CATCH_REACT( catchAssertionHandler ) \</span>
<span class="cp">    } while( false )</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \</span>
<span class="cp">    do { \</span>
<span class="cp">        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \</span>
<span class="cp">        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() &lt;&lt; __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \</span>
<span class="cp">        INTERNAL_CATCH_REACT( catchAssertionHandler ) \</span>
<span class="cp">    } while( false )</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \</span>
<span class="cp">    auto varName = Catch::Capturer( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info, #__VA_ARGS__ ); \</span>
<span class="cp">    varName.captureValues( 0, __VA_ARGS__ )</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_INFO( macroName, log ) \</span>
<span class="cp">    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) &lt;&lt; log );</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_UNSCOPED_INFO( macroName, log ) \</span>
<span class="cp">    Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) &lt;&lt; log )</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Although this is matcher-based, it can be used with just a string</span>
<span class="cp">#define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \</span>
<span class="cp">    do { \</span>
<span class="cp">        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \</span>
<span class="cp">        if( catchAssertionHandler.allowThrows() ) \</span>
<span class="cp">            try { \</span>
<span class="cp">                static_cast&lt;void&gt;(__VA_ARGS__); \</span>
<span class="cp">                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \</span>
<span class="cp">            } \</span>
<span class="cp">            catch( ... ) { \</span>
<span class="cp">                Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher##_catch_sr ); \</span>
<span class="cp">            } \</span>
<span class="cp">        else \</span>
<span class="cp">            catchAssertionHandler.handleThrowingCallSkipped(); \</span>
<span class="cp">        INTERNAL_CATCH_REACT( catchAssertionHandler ) \</span>
<span class="cp">    } while( false )</span>

<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE</span>

<span class="c1">// end catch_capture.hpp</span>
<span class="c1">// start catch_section.h</span>

<span class="c1">// start catch_section_info.h</span>

<span class="c1">// start catch_totals.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">Counts</span> <span class="p">{</span>
        <span class="n">Counts</span> <span class="k">operator</span> <span class="o">-</span> <span class="p">(</span> <span class="n">Counts</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">Counts</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">Counts</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">total</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">allPassed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">allOk</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">passed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">failedButOk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">Totals</span> <span class="p">{</span>

        <span class="n">Totals</span> <span class="k">operator</span> <span class="o">-</span> <span class="p">(</span> <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">Totals</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">);</span>

        <span class="n">Totals</span> <span class="nf">delta</span><span class="p">(</span> <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">prevTotals</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">Counts</span> <span class="n">assertions</span><span class="p">;</span>
        <span class="n">Counts</span> <span class="n">testCases</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// end catch_totals.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">SectionInfo</span> <span class="p">{</span>
        <span class="n">SectionInfo</span>
            <span class="p">(</span>   <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_lineInfo</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span> <span class="p">);</span>

        <span class="c1">// Deprecated</span>
        <span class="n">SectionInfo</span>
            <span class="p">(</span>   <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_lineInfo</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">:</span> <span class="n">SectionInfo</span><span class="p">(</span> <span class="n">_lineInfo</span><span class="p">,</span> <span class="n">_name</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">description</span><span class="p">;</span> <span class="c1">// !Deprecated: this will always be empty</span>
        <span class="n">SourceLineInfo</span> <span class="n">lineInfo</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">SectionEndInfo</span> <span class="p">{</span>
        <span class="n">SectionInfo</span> <span class="n">sectionInfo</span><span class="p">;</span>
        <span class="n">Counts</span> <span class="n">prevAssertions</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">durationInSeconds</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_section_info.h</span>
<span class="c1">// start catch_timer.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">auto</span> <span class="nf">getCurrentNanosecondsSinceEpoch</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">uint64_t</span><span class="p">;</span>
    <span class="k">auto</span> <span class="nf">getEstimatedClockResolution</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">uint64_t</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">Timer</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">m_nanoseconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">start</span><span class="p">();</span>
        <span class="k">auto</span> <span class="nf">getElapsedNanoseconds</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">uint64_t</span><span class="p">;</span>
        <span class="k">auto</span> <span class="nf">getElapsedMicroseconds</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">uint64_t</span><span class="p">;</span>
        <span class="k">auto</span> <span class="nf">getElapsedMilliseconds</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>
        <span class="k">auto</span> <span class="nf">getElapsedSeconds</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">double</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_timer.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">Section</span> <span class="o">:</span> <span class="n">NonCopyable</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Section</span><span class="p">(</span> <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span> <span class="p">);</span>
        <span class="o">~</span><span class="n">Section</span><span class="p">();</span>

        <span class="c1">// This indicates whether the section should be executed or not</span>
        <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">SectionInfo</span> <span class="n">m_info</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>
        <span class="n">Counts</span> <span class="n">m_assertions</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_sectionIncluded</span><span class="p">;</span>
        <span class="n">Timer</span> <span class="n">m_timer</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#define INTERNAL_CATCH_SECTION( ... ) \</span>
<span class="cp">    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">    CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \</span>
<span class="cp">    if( Catch::Section const&amp; INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \</span>
<span class="cp">    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION</span>

<span class="cp">#define INTERNAL_CATCH_DYNAMIC_SECTION( ... ) \</span>
<span class="cp">    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">    CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \</span>
<span class="cp">    if( Catch::Section const&amp; INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, (Catch::ReusableStringStream() &lt;&lt; __VA_ARGS__).str() ) ) \</span>
<span class="cp">    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION</span>

<span class="c1">// end catch_section.h</span>
<span class="c1">// start catch_interfaces_exception.h</span>

<span class="c1">// start catch_interfaces_registry_hub.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">TestCase</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">ITestCaseRegistry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IExceptionTranslatorRegistry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IExceptionTranslator</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IReporterRegistry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IReporterFactory</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">ITagAliasRegistry</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IMutableEnumValuesRegistry</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">StartupExceptionRegistry</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">IReporterFactoryPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IReporterFactory</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">IRegistryHub</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IRegistryHub</span><span class="p">();</span>

        <span class="k">virtual</span> <span class="n">IReporterRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getReporterRegistry</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">ITestCaseRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getTestCaseRegistry</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">ITagAliasRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getTagAliasRegistry</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">IExceptionTranslatorRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getExceptionTranslatorRegistry</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="n">StartupExceptionRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getStartupExceptionRegistry</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">IMutableRegistryHub</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IMutableRegistryHub</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">registerReporter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">IReporterFactoryPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">factory</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">registerListener</span><span class="p">(</span> <span class="n">IReporterFactoryPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">factory</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">registerTest</span><span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">registerTranslator</span><span class="p">(</span> <span class="k">const</span> <span class="n">IExceptionTranslator</span><span class="o">*</span> <span class="n">translator</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">registerTagAlias</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">alias</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tag</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">registerStartupException</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">IMutableEnumValuesRegistry</span><span class="o">&amp;</span> <span class="n">getMutableEnumValuesRegistry</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">IRegistryHub</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getRegistryHub</span><span class="p">();</span>
    <span class="n">IMutableRegistryHub</span><span class="o">&amp;</span> <span class="nf">getMutableRegistryHub</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">cleanUp</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">translateActiveException</span><span class="p">();</span>

<span class="p">}</span>

<span class="c1">// end catch_interfaces_registry_hub.h</span>
<span class="cp">#if defined(CATCH_CONFIG_DISABLE)</span>
    <span class="cp">#define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \</span>
<span class="cp">        static std::string translatorName( signature )</span>
<span class="cp">#endif</span>

<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">exceptionTranslateFunction</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="p">)();</span>

    <span class="k">struct</span> <span class="nc">IExceptionTranslator</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ExceptionTranslators</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IExceptionTranslator</span> <span class="k">const</span><span class="o">&gt;&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">IExceptionTranslator</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IExceptionTranslator</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">translate</span><span class="p">(</span> <span class="n">ExceptionTranslators</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it</span><span class="p">,</span> <span class="n">ExceptionTranslators</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">itEnd</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">IExceptionTranslatorRegistry</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IExceptionTranslatorRegistry</span><span class="p">();</span>

        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">translateActiveException</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">ExceptionTranslatorRegistrar</span> <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">class</span> <span class="nc">ExceptionTranslator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IExceptionTranslator</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>

            <span class="n">ExceptionTranslator</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">translateFunction</span><span class="p">)(</span> <span class="n">T</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">)</span>
            <span class="o">:</span> <span class="n">m_translateFunction</span><span class="p">(</span> <span class="n">translateFunction</span> <span class="p">)</span>
            <span class="p">{}</span>

            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">translate</span><span class="p">(</span> <span class="n">ExceptionTranslators</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it</span><span class="p">,</span> <span class="n">ExceptionTranslators</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">itEnd</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
<span class="cp">#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
                <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="cp">#else</span>
                <span class="k">try</span> <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">it</span> <span class="o">==</span> <span class="n">itEnd</span> <span class="p">)</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
                    <span class="k">else</span>
                        <span class="nf">return</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">translate</span><span class="p">(</span> <span class="n">it</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">itEnd</span> <span class="p">);</span>
                <span class="p">}</span>
                <span class="k">catch</span><span class="p">(</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">ex</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">m_translateFunction</span><span class="p">(</span> <span class="n">ex</span> <span class="p">);</span>
                <span class="p">}</span>
<span class="cp">#endif</span>
            <span class="p">}</span>

        <span class="k">protected</span><span class="o">:</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">m_translateFunction</span><span class="p">)(</span> <span class="n">T</span><span class="o">&amp;</span> <span class="p">);</span>
        <span class="p">};</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">ExceptionTranslatorRegistrar</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">translateFunction</span><span class="p">)(</span> <span class="n">T</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">getMutableRegistryHub</span><span class="p">().</span><span class="n">registerTranslator</span>
                <span class="p">(</span> <span class="k">new</span> <span class="n">ExceptionTranslator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">translateFunction</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \</span>
<span class="cp">    static std::string translatorName( signature ); \</span>
<span class="cp">    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \</span>
<span class="cp">    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \</span>
<span class="cp">    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &amp;translatorName ); } \</span>
<span class="cp">    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \</span>
<span class="cp">    static std::string translatorName( signature )</span>

<span class="cp">#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )</span>

<span class="c1">// end catch_interfaces_exception.h</span>
<span class="c1">// start catch_approx.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">Approx</span> <span class="p">{</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">bool</span> <span class="n">equalityComparisonImpl</span><span class="p">(</span><span class="kt">double</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="c1">// Validates the new margin (margin &gt;= 0)</span>
        <span class="c1">// out-of-line to avoid including stdexcept in the header</span>
        <span class="kt">void</span> <span class="nf">setMargin</span><span class="p">(</span><span class="kt">double</span> <span class="n">margin</span><span class="p">);</span>
        <span class="c1">// Validates the new epsilon (0 &lt; epsilon &lt; 1)</span>
        <span class="c1">// out-of-line to avoid including stdexcept in the header</span>
        <span class="kt">void</span> <span class="nf">setEpsilon</span><span class="p">(</span><span class="kt">double</span> <span class="n">epsilon</span><span class="p">);</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="k">explicit</span> <span class="n">Approx</span> <span class="p">(</span> <span class="kt">double</span> <span class="n">value</span> <span class="p">);</span>

        <span class="k">static</span> <span class="n">Approx</span> <span class="n">custom</span><span class="p">();</span>

        <span class="n">Approx</span> <span class="k">operator</span><span class="o">-</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="n">Approx</span> <span class="k">operator</span><span class="p">()(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">Approx</span> <span class="nf">approx</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">);</span>
            <span class="n">approx</span><span class="p">.</span><span class="n">m_epsilon</span> <span class="o">=</span> <span class="n">m_epsilon</span><span class="p">;</span>
            <span class="n">approx</span><span class="p">.</span><span class="n">m_margin</span> <span class="o">=</span> <span class="n">m_margin</span><span class="p">;</span>
            <span class="n">approx</span><span class="p">.</span><span class="n">m_scale</span> <span class="o">=</span> <span class="n">m_scale</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">approx</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="k">explicit</span> <span class="n">Approx</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span><span class="o">:</span> <span class="n">Approx</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="p">{}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Approx</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">lhs_v</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">rhs</span><span class="p">.</span><span class="n">equalityComparisonImpl</span><span class="p">(</span><span class="n">lhs_v</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="n">Approx</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="o">!=</span> <span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Approx</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="o">!=</span> <span class="p">(</span> <span class="n">Approx</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;=</span> <span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Approx</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m_value</span> <span class="o">||</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;=</span> <span class="p">(</span> <span class="n">Approx</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">m_value</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="o">||</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&gt;=</span> <span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Approx</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m_value</span> <span class="o">||</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&gt;=</span> <span class="p">(</span> <span class="n">Approx</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">m_value</span> <span class="o">&gt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="o">||</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="n">Approx</span><span class="o">&amp;</span> <span class="n">epsilon</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">newEpsilon</span> <span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">epsilonAsDouble</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newEpsilon</span><span class="p">);</span>
            <span class="n">setEpsilon</span><span class="p">(</span><span class="n">epsilonAsDouble</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="n">Approx</span><span class="o">&amp;</span> <span class="n">margin</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">newMargin</span> <span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">marginAsDouble</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newMargin</span><span class="p">);</span>
            <span class="n">setMargin</span><span class="p">(</span><span class="n">marginAsDouble</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
        <span class="n">Approx</span><span class="o">&amp;</span> <span class="n">scale</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">newScale</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_scale</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newScale</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">double</span> <span class="n">m_epsilon</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">m_margin</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">m_scale</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">m_value</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span> <span class="c1">// end namespace Detail</span>

<span class="k">namespace</span> <span class="n">literals</span> <span class="p">{</span>
    <span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span> <span class="k">operator</span> <span class="s">&quot;&quot;</span> <span class="n">_a</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">val</span><span class="p">);</span>
    <span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span> <span class="k">operator</span> <span class="s">&quot;&quot;</span> <span class="n">_a</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// end namespace literals</span>

<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="nc">StringMaker</span><span class="o">&lt;</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">convert</span><span class="p">(</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_approx.h</span>
<span class="c1">// start catch_string_manip.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="kt">bool</span> <span class="nf">startsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">prefix</span> <span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">startsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">prefix</span> <span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">endsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">suffix</span> <span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">endsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">suffix</span> <span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">contains</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">infix</span> <span class="p">);</span>
    <span class="kt">void</span> <span class="nf">toLowerInPlace</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">);</span>
    <span class="c1">//! Returns a new string without whitespace at the start/end</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">trim</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">);</span>
    <span class="c1">//! Returns a substring of the original ref without whitespace. Beware lifetimes!</span>
    <span class="n">StringRef</span> <span class="nf">trim</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">ref</span><span class="p">);</span>

    <span class="c1">// !!! Be aware, returns refs into original string - make sure original string outlives them</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">StringRef</span><span class="o">&gt;</span> <span class="n">splitStringRef</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">str</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delimiter</span> <span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">replaceInPlace</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">replaceThis</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">withThis</span> <span class="p">);</span>

    <span class="k">struct</span> <span class="nc">pluralise</span> <span class="p">{</span>
        <span class="n">pluralise</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">label</span> <span class="p">);</span>

        <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">pluralise</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pluraliser</span> <span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_count</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_label</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// end catch_string_manip.h</span>
<span class="cp">#ifndef CATCH_CONFIG_DISABLE_MATCHERS</span>
<span class="c1">// start catch_capture_matchers.h</span>

<span class="c1">// start catch_matchers.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Impl</span> <span class="p">{</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ArgT</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">MatchAllOf</span><span class="p">;</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ArgT</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">MatchAnyOf</span><span class="p">;</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ArgT</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">MatchNotOf</span><span class="p">;</span>

        <span class="k">class</span> <span class="nc">MatcherUntypedBase</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">MatcherUntypedBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
            <span class="n">MatcherUntypedBase</span> <span class="p">(</span> <span class="n">MatcherUntypedBase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
            <span class="n">MatcherUntypedBase</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">MatcherUntypedBase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="k">protected</span><span class="o">:</span>
            <span class="k">virtual</span> <span class="o">~</span><span class="n">MatcherUntypedBase</span><span class="p">();</span>
            <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_cachedToString</span><span class="p">;</span>
        <span class="p">};</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#    pragma clang diagnostic push</span>
<span class="cp">#    pragma clang diagnostic ignored &quot;-Wnon-virtual-dtor&quot;</span>
<span class="cp">#endif</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ObjectT</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">MatcherMethod</span> <span class="p">{</span>
            <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span> <span class="n">ObjectT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arg</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">};</span>

<span class="cp">#if defined(__OBJC__)</span>
        <span class="c1">// Hack to fix Catch GH issue #1661. Could use id for generic Object support.</span>
        <span class="c1">// use of const for Object pointers is very uncommon and under ARC it causes some kind of signature mismatch that breaks compilation</span>
        <span class="k">template</span><span class="o">&lt;&gt;</span>
        <span class="k">struct</span> <span class="nc">MatcherMethod</span><span class="o">&lt;</span><span class="n">NSString</span><span class="o">*&gt;</span> <span class="p">{</span>
            <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">arg</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">};</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#    pragma clang diagnostic pop</span>
<span class="cp">#endif</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">MatcherBase</span> <span class="o">:</span> <span class="n">MatcherUntypedBase</span><span class="p">,</span> <span class="n">MatcherMethod</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>

            <span class="n">MatchAllOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">MatcherBase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
            <span class="n">MatchAnyOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="o">||</span> <span class="p">(</span> <span class="n">MatcherBase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
            <span class="n">MatchNotOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="o">!</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ArgT</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">MatchAllOf</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="kt">bool</span> <span class="nf">match</span><span class="p">(</span> <span class="n">ArgT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arg</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="nl">matcher</span> <span class="p">:</span> <span class="n">m_matchers</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">matcher</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">description</span><span class="p">;</span>
                <span class="n">description</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">m_matchers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="mi">32</span> <span class="p">);</span>
                <span class="n">description</span> <span class="o">+=</span> <span class="s">&quot;( &quot;</span><span class="p">;</span>
                <span class="kt">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="nl">matcher</span> <span class="p">:</span> <span class="n">m_matchers</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">first</span> <span class="p">)</span>
                        <span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">else</span>
                        <span class="n">description</span> <span class="o">+=</span> <span class="s">&quot; and &quot;</span><span class="p">;</span>
                    <span class="n">description</span> <span class="o">+=</span> <span class="n">matcher</span><span class="o">-&gt;</span><span class="n">toString</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="n">description</span> <span class="o">+=</span> <span class="s">&quot; )&quot;</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">description</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">MatchAllOf</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="nf">copy</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
                <span class="n">copy</span><span class="p">.</span><span class="n">m_matchers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">);</span>
                <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">*&gt;</span> <span class="n">m_matchers</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ArgT</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">MatchAnyOf</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="p">{</span>

            <span class="kt">bool</span> <span class="nf">match</span><span class="p">(</span> <span class="n">ArgT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arg</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="nl">matcher</span> <span class="p">:</span> <span class="n">m_matchers</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">matcher</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
                        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">description</span><span class="p">;</span>
                <span class="n">description</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">m_matchers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="mi">32</span> <span class="p">);</span>
                <span class="n">description</span> <span class="o">+=</span> <span class="s">&quot;( &quot;</span><span class="p">;</span>
                <span class="kt">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="nl">matcher</span> <span class="p">:</span> <span class="n">m_matchers</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">first</span> <span class="p">)</span>
                        <span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">else</span>
                        <span class="n">description</span> <span class="o">+=</span> <span class="s">&quot; or &quot;</span><span class="p">;</span>
                    <span class="n">description</span> <span class="o">+=</span> <span class="n">matcher</span><span class="o">-&gt;</span><span class="n">toString</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="n">description</span> <span class="o">+=</span> <span class="s">&quot; )&quot;</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">description</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">MatchAnyOf</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="o">||</span> <span class="p">(</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="nf">copy</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
                <span class="n">copy</span><span class="p">.</span><span class="n">m_matchers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">);</span>
                <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">*&gt;</span> <span class="n">m_matchers</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ArgT</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">MatchNotOf</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="p">{</span>

            <span class="n">MatchNotOf</span><span class="p">(</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">underlyingMatcher</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_underlyingMatcher</span><span class="p">(</span> <span class="n">underlyingMatcher</span> <span class="p">)</span> <span class="p">{}</span>

            <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span> <span class="n">ArgT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arg</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">!</span><span class="n">m_underlyingMatcher</span><span class="p">.</span><span class="n">match</span><span class="p">(</span> <span class="n">arg</span> <span class="p">);</span>
            <span class="p">}</span>

            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="s">&quot;not &quot;</span> <span class="o">+</span> <span class="n">m_underlyingMatcher</span><span class="p">.</span><span class="n">toString</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m_underlyingMatcher</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">MatchAllOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="n">MatcherBase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">MatchAllOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="k">this</span> <span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">MatchAnyOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span> <span class="o">||</span> <span class="p">(</span> <span class="n">MatcherBase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">MatchAnyOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">||</span> <span class="o">*</span><span class="k">this</span> <span class="o">||</span> <span class="n">other</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">MatchNotOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span> <span class="o">!</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">MatchNotOf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="c1">// namespace Impl</span>

<span class="p">}</span> <span class="c1">// namespace Matchers</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">Matchers</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Matchers</span><span class="o">::</span><span class="n">Impl</span><span class="o">::</span><span class="n">MatcherBase</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_matchers.h</span>
<span class="c1">// start catch_matchers_exception.hpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Exception</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">ExceptionMessageMatcher</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_message</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>

    <span class="n">ExceptionMessageMatcher</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span><span class="o">:</span>
        <span class="n">m_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace Exception</span>

<span class="n">Exception</span><span class="o">::</span><span class="n">ExceptionMessageMatcher</span> <span class="n">Message</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">);</span>

<span class="p">}</span> <span class="c1">// namespace Matchers</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_matchers_exception.hpp</span>
<span class="c1">// start catch_matchers_floating.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="n">Floating</span> <span class="p">{</span>

        <span class="k">enum</span> <span class="k">class</span> <span class="nc">FloatingPointKind</span> <span class="o">:</span> <span class="kt">uint8_t</span><span class="p">;</span>

        <span class="k">struct</span> <span class="nc">WithinAbsMatcher</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">WithinAbsMatcher</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">match</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matchee</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">private</span><span class="o">:</span>
            <span class="kt">double</span> <span class="n">m_target</span><span class="p">;</span>
            <span class="kt">double</span> <span class="n">m_margin</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="nc">WithinUlpsMatcher</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">WithinUlpsMatcher</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">ulps</span><span class="p">,</span> <span class="n">FloatingPointKind</span> <span class="n">baseType</span><span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">match</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matchee</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">private</span><span class="o">:</span>
            <span class="kt">double</span> <span class="n">m_target</span><span class="p">;</span>
            <span class="kt">uint64_t</span> <span class="n">m_ulps</span><span class="p">;</span>
            <span class="n">FloatingPointKind</span> <span class="n">m_type</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="c1">// Given IEEE-754 format for floats and doubles, we can assume</span>
        <span class="c1">// that float -&gt; double promotion is lossless. Given this, we can</span>
        <span class="c1">// assume that if we do the standard relative comparison of</span>
        <span class="c1">// |lhs - rhs| &lt;= epsilon * max(fabs(lhs), fabs(rhs)), then we get</span>
        <span class="c1">// the same result if we do this for floats, as if we do this for</span>
        <span class="c1">// doubles that were promoted from floats.</span>
        <span class="k">struct</span> <span class="nc">WithinRelMatcher</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">WithinRelMatcher</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">match</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matchee</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">private</span><span class="o">:</span>
            <span class="kt">double</span> <span class="n">m_target</span><span class="p">;</span>
            <span class="kt">double</span> <span class="n">m_epsilon</span><span class="p">;</span>
        <span class="p">};</span>

    <span class="p">}</span> <span class="c1">// namespace Floating</span>

    <span class="c1">// The following functions create the actual matcher objects.</span>
    <span class="c1">// This allows the types to be inferred</span>
    <span class="n">Floating</span><span class="o">::</span><span class="n">WithinUlpsMatcher</span> <span class="n">WithinULP</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">maxUlpDiff</span><span class="p">);</span>
    <span class="n">Floating</span><span class="o">::</span><span class="n">WithinUlpsMatcher</span> <span class="n">WithinULP</span><span class="p">(</span><span class="kt">float</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">maxUlpDiff</span><span class="p">);</span>
    <span class="n">Floating</span><span class="o">::</span><span class="n">WithinAbsMatcher</span> <span class="n">WithinAbs</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="p">);</span>
    <span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span> <span class="n">WithinRel</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">);</span>
    <span class="c1">// defaults epsilon to 100*numeric_limits&lt;double&gt;::epsilon()</span>
    <span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span> <span class="n">WithinRel</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">);</span>
    <span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span> <span class="n">WithinRel</span><span class="p">(</span><span class="kt">float</span> <span class="n">target</span><span class="p">,</span> <span class="kt">float</span> <span class="n">eps</span><span class="p">);</span>
    <span class="c1">// defaults epsilon to 100*numeric_limits&lt;float&gt;::epsilon()</span>
    <span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span> <span class="n">WithinRel</span><span class="p">(</span><span class="kt">float</span> <span class="n">target</span><span class="p">);</span>

<span class="p">}</span> <span class="c1">// namespace Matchers</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_matchers_floating.h</span>
<span class="c1">// start catch_matchers_generic.hpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Generic</span> <span class="p">{</span>

<span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">finalizeDescription</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">PredicateMatcher</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">m_predicate</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_description</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>

    <span class="n">PredicateMatcher</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">descr</span><span class="p">)</span>
        <span class="o">:</span><span class="n">m_predicate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">elem</span><span class="p">)),</span>
        <span class="n">m_description</span><span class="p">(</span><span class="n">Detail</span><span class="o">::</span><span class="n">finalizeDescription</span><span class="p">(</span><span class="n">descr</span><span class="p">))</span>
    <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">item</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">m_predicate</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_description</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace Generic</span>

    <span class="c1">// The following functions create the actual matcher objects.</span>
    <span class="c1">// The user has to explicitly specify type to the function, because</span>
    <span class="c1">// inferring std::function&lt;bool(T const&amp;)&gt; is hard (but possible) and</span>
    <span class="c1">// requires a lot of TMP.</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="n">Generic</span><span class="o">::</span><span class="n">PredicateMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Predicate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">description</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Generic</span><span class="o">::</span><span class="n">PredicateMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">description</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Matchers</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_matchers_generic.hpp</span>
<span class="c1">// start catch_matchers_string.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="n">StdString</span> <span class="p">{</span>

        <span class="k">struct</span> <span class="nc">CasedString</span>
        <span class="p">{</span>
            <span class="n">CasedString</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">adjustString</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">caseSensitivitySuffix</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

            <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">m_caseSensitivity</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_str</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="nc">StringMatcherBase</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">StringMatcherBase</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">operation</span><span class="p">,</span> <span class="n">CasedString</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

            <span class="n">CasedString</span> <span class="n">m_comparator</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_operation</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="nc">EqualsMatcher</span> <span class="o">:</span> <span class="n">StringMatcherBase</span> <span class="p">{</span>
            <span class="n">EqualsMatcher</span><span class="p">(</span> <span class="n">CasedString</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">match</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">source</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">struct</span> <span class="nc">ContainsMatcher</span> <span class="o">:</span> <span class="n">StringMatcherBase</span> <span class="p">{</span>
            <span class="n">ContainsMatcher</span><span class="p">(</span> <span class="n">CasedString</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">match</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">source</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">struct</span> <span class="nc">StartsWithMatcher</span> <span class="o">:</span> <span class="n">StringMatcherBase</span> <span class="p">{</span>
            <span class="n">StartsWithMatcher</span><span class="p">(</span> <span class="n">CasedString</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">match</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">source</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">struct</span> <span class="nc">EndsWithMatcher</span> <span class="o">:</span> <span class="n">StringMatcherBase</span> <span class="p">{</span>
            <span class="n">EndsWithMatcher</span><span class="p">(</span> <span class="n">CasedString</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">match</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">source</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="nc">RegexMatcher</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">RegexMatcher</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">regex</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">match</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matchee</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="k">private</span><span class="o">:</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_regex</span><span class="p">;</span>
            <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">m_caseSensitivity</span><span class="p">;</span>
        <span class="p">};</span>

    <span class="p">}</span> <span class="c1">// namespace StdString</span>

    <span class="c1">// The following functions create the actual matcher objects.</span>
    <span class="c1">// This allows the types to be inferred</span>

    <span class="n">StdString</span><span class="o">::</span><span class="n">EqualsMatcher</span> <span class="n">Equals</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="o">=</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Yes</span> <span class="p">);</span>
    <span class="n">StdString</span><span class="o">::</span><span class="n">ContainsMatcher</span> <span class="n">Contains</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="o">=</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Yes</span> <span class="p">);</span>
    <span class="n">StdString</span><span class="o">::</span><span class="n">EndsWithMatcher</span> <span class="n">EndsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="o">=</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Yes</span> <span class="p">);</span>
    <span class="n">StdString</span><span class="o">::</span><span class="n">StartsWithMatcher</span> <span class="n">StartsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="o">=</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Yes</span> <span class="p">);</span>
    <span class="n">StdString</span><span class="o">::</span><span class="n">RegexMatcher</span> <span class="n">Matches</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">regex</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="o">=</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Yes</span> <span class="p">);</span>

<span class="p">}</span> <span class="c1">// namespace Matchers</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_matchers_string.h</span>
<span class="c1">// start catch_matchers_vector.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="n">Vector</span> <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Alloc</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">ContainsElementMatcher</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&gt;</span> <span class="p">{</span>

            <span class="n">ContainsElementMatcher</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">comparator</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_comparator</span><span class="p">(</span> <span class="n">comparator</span><span class="p">)</span> <span class="p">{}</span>

            <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">el</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">el</span> <span class="o">==</span> <span class="n">m_comparator</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="s">&quot;Contains: &quot;</span> <span class="o">+</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_comparator</span> <span class="p">);</span>
            <span class="p">}</span>

            <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m_comparator</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocComp</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocMatch</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">ContainsMatcher</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;&gt;</span> <span class="p">{</span>

            <span class="n">ContainsMatcher</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">comparator</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_comparator</span><span class="p">(</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{}</span>

            <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="c1">// !TBD: see note in EqualsMatcher</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m_comparator</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">comparator</span> <span class="p">:</span> <span class="n">m_comparator</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">present</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">el</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">el</span> <span class="o">==</span> <span class="n">comparator</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">present</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">present</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="s">&quot;Contains: &quot;</span> <span class="o">+</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_comparator</span> <span class="p">);</span>
            <span class="p">}</span>

            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m_comparator</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocComp</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocMatch</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">EqualsMatcher</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;&gt;</span> <span class="p">{</span>

            <span class="n">EqualsMatcher</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">comparator</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_comparator</span><span class="p">(</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{}</span>

            <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="c1">// !TBD: This currently works if all elements can be compared using !=</span>
                <span class="c1">// - a more general approach would be via a compare template that defaults</span>
                <span class="c1">// to using !=. but could be specialised for, e.g. std::vector&lt;T, Alloc&gt; etc</span>
                <span class="c1">// - then just call that directly</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m_comparator</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">m_comparator</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="s">&quot;Equals: &quot;</span> <span class="o">+</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_comparator</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m_comparator</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocComp</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocMatch</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">ApproxMatcher</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;&gt;</span> <span class="p">{</span>

            <span class="n">ApproxMatcher</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_comparator</span><span class="p">(</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{}</span>

            <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m_comparator</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">m_comparator</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">approx</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="s">&quot;is approx: &quot;</span> <span class="o">+</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_comparator</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
            <span class="n">ApproxMatcher</span><span class="o">&amp;</span> <span class="n">epsilon</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">newEpsilon</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">approx</span><span class="p">.</span><span class="n">epsilon</span><span class="p">(</span><span class="n">newEpsilon</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
            <span class="n">ApproxMatcher</span><span class="o">&amp;</span> <span class="n">margin</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">newMargin</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">approx</span><span class="p">.</span><span class="n">margin</span><span class="p">(</span><span class="n">newMargin</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_constructible</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
            <span class="n">ApproxMatcher</span><span class="o">&amp;</span> <span class="n">scale</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">newScale</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">approx</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="n">newScale</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m_comparator</span><span class="p">;</span>
            <span class="k">mutable</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span> <span class="n">approx</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span><span class="o">::</span><span class="n">custom</span><span class="p">();</span>
        <span class="p">};</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocComp</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocMatch</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">UnorderedEqualsMatcher</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
            <span class="n">UnorderedEqualsMatcher</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">target</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_target</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{}</span>
            <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">vec</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m_target</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">is_permutation</span><span class="p">(</span><span class="n">m_target</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_target</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="s">&quot;UnorderedEquals: &quot;</span> <span class="o">+</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">m_target</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="k">private</span><span class="o">:</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m_target</span><span class="p">;</span>
        <span class="p">};</span>

    <span class="p">}</span> <span class="c1">// namespace Vector</span>

    <span class="c1">// The following functions create the actual matcher objects.</span>
    <span class="c1">// This allows the types to be inferred</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocComp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocMatch</span> <span class="o">=</span> <span class="n">AllocComp</span><span class="o">&gt;</span>
    <span class="n">Vector</span><span class="o">::</span><span class="n">ContainsMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span> <span class="n">Contains</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">::</span><span class="n">ContainsMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">comparator</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
    <span class="n">Vector</span><span class="o">::</span><span class="n">ContainsElementMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span> <span class="n">VectorContains</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">::</span><span class="n">ContainsElementMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">comparator</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocComp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocMatch</span> <span class="o">=</span> <span class="n">AllocComp</span><span class="o">&gt;</span>
    <span class="n">Vector</span><span class="o">::</span><span class="n">EqualsMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span> <span class="n">Equals</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">::</span><span class="n">EqualsMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">comparator</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocComp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocMatch</span> <span class="o">=</span> <span class="n">AllocComp</span><span class="o">&gt;</span>
    <span class="n">Vector</span><span class="o">::</span><span class="n">ApproxMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span> <span class="n">Approx</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">::</span><span class="n">ApproxMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">comparator</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocComp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">AllocMatch</span> <span class="o">=</span> <span class="n">AllocComp</span><span class="o">&gt;</span>
    <span class="n">Vector</span><span class="o">::</span><span class="n">UnorderedEqualsMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span> <span class="n">UnorderedEquals</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="o">::</span><span class="n">UnorderedEqualsMatcher</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">AllocComp</span><span class="p">,</span> <span class="n">AllocMatch</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">target</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Matchers</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_matchers_vector.h</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ArgT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">MatcherT</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">MatchExpr</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ITransientExpression</span> <span class="p">{</span>
        <span class="n">ArgT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m_arg</span><span class="p">;</span>
        <span class="n">MatcherT</span> <span class="n">m_matcher</span><span class="p">;</span>
        <span class="n">StringRef</span> <span class="n">m_matcherString</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">MatchExpr</span><span class="p">(</span> <span class="n">ArgT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">,</span> <span class="n">MatcherT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matcherString</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">ITransientExpression</span><span class="p">{</span> <span class="nb">true</span><span class="p">,</span> <span class="n">matcher</span><span class="p">.</span><span class="n">match</span><span class="p">(</span> <span class="n">arg</span> <span class="p">)</span> <span class="p">},</span>
            <span class="n">m_arg</span><span class="p">(</span> <span class="n">arg</span> <span class="p">),</span>
            <span class="n">m_matcher</span><span class="p">(</span> <span class="n">matcher</span> <span class="p">),</span>
            <span class="n">m_matcherString</span><span class="p">(</span> <span class="n">matcherString</span> <span class="p">)</span>
        <span class="p">{}</span>

        <span class="kt">void</span> <span class="n">streamReconstructedExpression</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">matcherAsString</span> <span class="o">=</span> <span class="n">m_matcher</span><span class="p">.</span><span class="n">toString</span><span class="p">();</span>
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_arg</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">matcherAsString</span> <span class="o">==</span> <span class="n">Detail</span><span class="o">::</span><span class="n">unprintableString</span> <span class="p">)</span>
                <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">m_matcherString</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">matcherAsString</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">using</span> <span class="n">StringMatcher</span> <span class="o">=</span> <span class="n">Matchers</span><span class="o">::</span><span class="n">Impl</span><span class="o">::</span><span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">handleExceptionMatchExpr</span><span class="p">(</span> <span class="n">AssertionHandler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">,</span> <span class="n">StringMatcher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matcherString</span>  <span class="p">);</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ArgT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">MatcherT</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">makeMatchExpr</span><span class="p">(</span> <span class="n">ArgT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">,</span> <span class="n">MatcherT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matcherString</span>  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MatchExpr</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="p">,</span> <span class="n">MatcherT</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">MatchExpr</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="p">,</span> <span class="n">MatcherT</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">arg</span><span class="p">,</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">matcherString</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \</span>
<span class="cp">    do { \</span>
<span class="cp">        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \</span>
<span class="cp">        INTERNAL_CATCH_TRY { \</span>
<span class="cp">            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher##_catch_sr ) ); \</span>
<span class="cp">        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \</span>
<span class="cp">        INTERNAL_CATCH_REACT( catchAssertionHandler ) \</span>
<span class="cp">    } while( false )</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \</span>
<span class="cp">    do { \</span>
<span class="cp">        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(exceptionType) &quot;, &quot; CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \</span>
<span class="cp">        if( catchAssertionHandler.allowThrows() ) \</span>
<span class="cp">            try { \</span>
<span class="cp">                static_cast&lt;void&gt;(__VA_ARGS__ ); \</span>
<span class="cp">                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \</span>
<span class="cp">            } \</span>
<span class="cp">            catch( exceptionType const&amp; ex ) { \</span>
<span class="cp">                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher##_catch_sr ) ); \</span>
<span class="cp">            } \</span>
<span class="cp">            catch( ... ) { \</span>
<span class="cp">                catchAssertionHandler.handleUnexpectedInflightException(); \</span>
<span class="cp">            } \</span>
<span class="cp">        else \</span>
<span class="cp">            catchAssertionHandler.handleThrowingCallSkipped(); \</span>
<span class="cp">        INTERNAL_CATCH_REACT( catchAssertionHandler ) \</span>
<span class="cp">    } while( false )</span>

<span class="c1">// end catch_capture_matchers.h</span>
<span class="cp">#endif</span>
<span class="c1">// start catch_generators.hpp</span>

<span class="c1">// start catch_interfaces_generatortracker.h</span>


<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="n">Generators</span> <span class="p">{</span>
        <span class="k">class</span> <span class="nc">GeneratorUntypedBase</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">GeneratorUntypedBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
            <span class="k">virtual</span> <span class="o">~</span><span class="n">GeneratorUntypedBase</span><span class="p">();</span>
            <span class="c1">// Attempts to move the generator to the next element</span>
             <span class="c1">//</span>
             <span class="c1">// Returns true iff the move succeeded (and a valid element</span>
             <span class="c1">// can be retrieved).</span>
            <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">using</span> <span class="n">GeneratorBasePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GeneratorUntypedBase</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="p">}</span> <span class="c1">// namespace Generators</span>

    <span class="k">struct</span> <span class="nc">IGeneratorTracker</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IGeneratorTracker</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">hasGenerator</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">getGenerator</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Generators</span><span class="o">::</span><span class="n">GeneratorBasePtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setGenerator</span><span class="p">(</span> <span class="n">Generators</span><span class="o">::</span><span class="n">GeneratorBasePtr</span><span class="o">&amp;&amp;</span> <span class="n">generator</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_interfaces_generatortracker.h</span>
<span class="c1">// start catch_enforce.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Ex</span><span class="o">&gt;</span>
    <span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">throw_exception</span><span class="p">(</span><span class="n">Ex</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="n">e</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#else </span><span class="c1">// ^^ Exceptions are enabled //  Exceptions are disabled vv</span>
    <span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">throw_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">throw_logic_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">throw_domain_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">throw_runtime_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>

<span class="p">}</span> <span class="c1">// namespace Catch;</span>

<span class="cp">#define CATCH_MAKE_MSG(...) \</span>
<span class="cp">    (Catch::ReusableStringStream() &lt;&lt; __VA_ARGS__).str()</span>

<span class="cp">#define CATCH_INTERNAL_ERROR(...) \</span>
<span class="cp">    Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO &lt;&lt; &quot;: Internal Catch2 error: &quot; &lt;&lt; __VA_ARGS__))</span>

<span class="cp">#define CATCH_ERROR(...) \</span>
<span class="cp">    Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))</span>

<span class="cp">#define CATCH_RUNTIME_ERROR(...) \</span>
<span class="cp">    Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))</span>

<span class="cp">#define CATCH_ENFORCE( condition, ... ) \</span>
<span class="cp">    do{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); } while(false)</span>

<span class="c1">// end catch_enforce.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">GeneratorException</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">m_msg</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">GeneratorException</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span><span class="o">:</span>
        <span class="n">m_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span> <span class="k">final</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">namespace</span> <span class="n">Generators</span> <span class="p">{</span>

    <span class="c1">// !TBD move this into its own location?</span>
    <span class="k">namespace</span> <span class="n">pf</span><span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_unique</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">IGenerator</span> <span class="o">:</span> <span class="n">GeneratorUntypedBase</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IGenerator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="c1">// Returns the current element of the generator</span>
        <span class="c1">//</span>
        <span class="c1">// \Precondition The generator is either freshly constructed,</span>
        <span class="c1">// or the last call to `next()` returned true</span>
        <span class="k">virtual</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">SingleValueGenerator</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">m_value</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">SingleValueGenerator</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{}</span>

        <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">FixedValuesGenerator</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;FixedValuesGenerator does not support bools because of std::vector&lt;bool&gt;&quot;</span>
            <span class="s">&quot;specialization, use SingleValue Generator instead.&quot;</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m_values</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">m_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">FixedValuesGenerator</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">values</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_values</span><span class="p">(</span> <span class="n">values</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_values</span><span class="p">[</span><span class="n">m_idx</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">m_idx</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">m_idx</span> <span class="o">&lt;</span> <span class="n">m_values</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">GeneratorWrapper</span> <span class="k">final</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">m_generator</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">GeneratorWrapper</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">generator</span><span class="p">)</span><span class="o">:</span>
            <span class="n">m_generator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
        <span class="p">{}</span>
        <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_generator</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_generator</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SingleValueGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)));</span>
    <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">FixedValuesGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Generators</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">m_generators</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">m_current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">populate</span><span class="p">(</span><span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_generators</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">populate</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_generators</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">)));</span>
        <span class="p">}</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="o">&gt;</span>
        <span class="kt">void</span> <span class="n">populate</span><span class="p">(</span><span class="n">U</span><span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">populate</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">)));</span>
        <span class="p">}</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Gs</span><span class="o">&gt;</span>
        <span class="kt">void</span> <span class="n">populate</span><span class="p">(</span><span class="n">U</span><span class="o">&amp;&amp;</span> <span class="n">valueOrGenerator</span><span class="p">,</span> <span class="n">Gs</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">moreGenerators</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">populate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">valueOrGenerator</span><span class="p">));</span>
            <span class="n">populate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Gs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">moreGenerators</span><span class="p">)...);</span>
        <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Gs</span><span class="o">&gt;</span>
        <span class="n">Generators</span><span class="p">(</span><span class="n">Gs</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">moreGenerators</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_generators</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Gs</span><span class="p">));</span>
            <span class="n">populate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Gs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">moreGenerators</span><span class="p">)...);</span>
        <span class="p">}</span>

        <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_generators</span><span class="p">[</span><span class="n">m_current</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_current</span> <span class="o">&gt;=</span> <span class="n">m_generators</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">const</span> <span class="kt">bool</span> <span class="n">current_status</span> <span class="o">=</span> <span class="n">m_generators</span><span class="p">[</span><span class="n">m_current</span><span class="p">].</span><span class="n">next</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current_status</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">m_current</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">m_current</span> <span class="o">&lt;</span> <span class="n">m_generators</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
    <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="n">table</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="n">tuples</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">values</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="n">tuples</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Tag type to signal that a generator sequence should convert arguments to a specific type</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">as</span> <span class="p">{};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Gs</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">makeGenerators</span><span class="p">(</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">,</span> <span class="n">Gs</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">moreGenerators</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generators</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Generators</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Gs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">moreGenerators</span><span class="p">)...);</span>
    <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">makeGenerators</span><span class="p">(</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generators</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Generators</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Gs</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">makeGenerators</span><span class="p">(</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Gs</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">moreGenerators</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generators</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">makeGenerators</span><span class="p">(</span> <span class="n">value</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span> <span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Gs</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">moreGenerators</span> <span class="p">)...</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Gs</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">makeGenerators</span><span class="p">(</span> <span class="n">as</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">U</span><span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Gs</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">moreGenerators</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generators</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">makeGenerators</span><span class="p">(</span> <span class="n">value</span><span class="p">(</span> <span class="n">T</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span> <span class="p">)</span> <span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Gs</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">moreGenerators</span> <span class="p">)...</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">acquireGeneratorTracker</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">generatorName</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IGeneratorTracker</span><span class="o">&amp;</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">L</span><span class="o">&gt;</span>
    <span class="c1">// Note: The type after -&gt; is weird, because VS2015 cannot parse</span>
    <span class="c1">//       the expression used in the typedef inside, when it is in</span>
    <span class="c1">//       return type. Yeah.</span>
    <span class="k">auto</span> <span class="n">generate</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">generatorName</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span><span class="p">,</span> <span class="n">L</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">generatorExpression</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">generatorExpression</span><span class="p">())</span><span class="o">&gt;</span><span class="p">().</span><span class="n">get</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">UnderlyingType</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">decltype</span><span class="p">(</span><span class="n">generatorExpression</span><span class="p">())</span><span class="o">::</span><span class="n">type</span><span class="p">;</span>

        <span class="n">IGeneratorTracker</span><span class="o">&amp;</span> <span class="n">tracker</span> <span class="o">=</span> <span class="n">acquireGeneratorTracker</span><span class="p">(</span> <span class="n">generatorName</span><span class="p">,</span> <span class="n">lineInfo</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tracker</span><span class="p">.</span><span class="n">hasGenerator</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">tracker</span><span class="p">.</span><span class="n">setGenerator</span><span class="p">(</span><span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Generators</span><span class="o">&lt;</span><span class="n">UnderlyingType</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">generatorExpression</span><span class="p">()));</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">generator</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">UnderlyingType</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="n">tracker</span><span class="p">.</span><span class="n">getGenerator</span><span class="p">()</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">generator</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Generators</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="cp">#define GENERATE( ... ) \</span>
<span class="cp">    Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \</span>
<span class="cp">                                 CATCH_INTERNAL_LINEINFO, \</span>
<span class="cp">                                 [ ]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) </span><span class="c1">//NOLINT(google-build-using-namespace)</span>
<span class="cp">#define GENERATE_COPY( ... ) \</span>
<span class="cp">    Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \</span>
<span class="cp">                                 CATCH_INTERNAL_LINEINFO, \</span>
<span class="cp">                                 [=]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) </span><span class="c1">//NOLINT(google-build-using-namespace)</span>
<span class="cp">#define GENERATE_REF( ... ) \</span>
<span class="cp">    Catch::Generators::generate( INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \</span>
<span class="cp">                                 CATCH_INTERNAL_LINEINFO, \</span>
<span class="cp">                                 [&amp;]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) </span><span class="c1">//NOLINT(google-build-using-namespace)</span>

<span class="c1">// end catch_generators.hpp</span>
<span class="c1">// start catch_generators_generic.hpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Generators</span> <span class="p">{</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">TakeGenerator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m_generator</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">m_returned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">m_target</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">TakeGenerator</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">target</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span><span class="o">:</span>
            <span class="n">m_generator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">)),</span>
            <span class="n">m_target</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Empty generators are not allowed&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_generator</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">m_returned</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_returned</span> <span class="o">&gt;=</span> <span class="n">m_target</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">const</span> <span class="k">auto</span> <span class="n">success</span> <span class="o">=</span> <span class="n">m_generator</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
            <span class="c1">// If the underlying generator does not contain enough values</span>
            <span class="c1">// then we cut short as well</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">m_returned</span> <span class="o">=</span> <span class="n">m_target</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">take</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">target</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">TakeGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">FilterGenerator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m_generator</span><span class="p">;</span>
        <span class="n">Predicate</span> <span class="n">m_predicate</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">P</span> <span class="o">=</span> <span class="n">Predicate</span><span class="o">&gt;</span>
        <span class="n">FilterGenerator</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span><span class="o">:</span>
            <span class="n">m_generator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">)),</span>
            <span class="n">m_predicate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_predicate</span><span class="p">(</span><span class="n">m_generator</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
                <span class="c1">// It might happen that there are no values that pass the</span>
                <span class="c1">// filter. In that case we throw an exception.</span>
                <span class="k">auto</span> <span class="n">has_initial_value</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_initial_value</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">Catch</span><span class="o">::</span><span class="n">throw_exception</span><span class="p">(</span><span class="n">GeneratorException</span><span class="p">(</span><span class="s">&quot;No valid value found in filtered generator&quot;</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_generator</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">m_generator</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">m_predicate</span><span class="p">(</span><span class="n">m_generator</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">success</span> <span class="o">=</span> <span class="n">m_generator</span><span class="p">.</span><span class="n">next</span><span class="p">())</span> <span class="o">==</span> <span class="nb">true</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
    <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">filter</span><span class="p">(</span><span class="n">Predicate</span><span class="o">&amp;&amp;</span> <span class="n">pred</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">FilterGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Predicate</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Predicate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pred</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">))));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">RepeatGenerator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
            <span class="s">&quot;RepeatGenerator currently does not support bools&quot;</span>
            <span class="s">&quot;because of std::vector&lt;bool&gt; specialization&quot;</span><span class="p">);</span>
        <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m_generator</span><span class="p">;</span>
        <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m_returned</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">m_target_repeats</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">m_current_repeat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">m_repeat_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">RepeatGenerator</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span><span class="o">:</span>
            <span class="n">m_generator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">)),</span>
            <span class="n">m_target_repeats</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">m_target_repeats</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Repeat generator must repeat at least once&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_current_repeat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">m_returned</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_generator</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">m_returned</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">m_returned</span><span class="p">[</span><span class="n">m_repeat_index</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="c1">// There are 2 basic cases:</span>
            <span class="c1">// 1) We are still reading the generator</span>
            <span class="c1">// 2) We are reading our own cache</span>

            <span class="c1">// In the first case, we need to poke the underlying generator.</span>
            <span class="c1">// If it happily moves, we are left in that state, otherwise it is time to start reading from our cache</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_current_repeat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">const</span> <span class="k">auto</span> <span class="n">success</span> <span class="o">=</span> <span class="n">m_generator</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
                    <span class="o">++</span><span class="n">m_current_repeat</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">m_current_repeat</span> <span class="o">&lt;</span> <span class="n">m_target_repeats</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// In the second case, we need to move indices forward and check that we haven&#39;t run up against the end</span>
            <span class="o">++</span><span class="n">m_repeat_index</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_repeat_index</span> <span class="o">==</span> <span class="n">m_returned</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">m_repeat_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="o">++</span><span class="n">m_current_repeat</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">m_current_repeat</span> <span class="o">&lt;</span> <span class="n">m_target_repeats</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">repeat</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RepeatGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Func</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">MapGenerator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// TBD: provide static assert for mapping function, for friendly error message</span>
        <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">m_generator</span><span class="p">;</span>
        <span class="n">Func</span> <span class="n">m_function</span><span class="p">;</span>
        <span class="c1">// To avoid returning dangling reference, we have to save the values</span>
        <span class="n">T</span> <span class="n">m_cache</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F2</span> <span class="o">=</span> <span class="n">Func</span><span class="o">&gt;</span>
        <span class="n">MapGenerator</span><span class="p">(</span><span class="n">F2</span><span class="o">&amp;&amp;</span> <span class="n">function</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span> <span class="o">:</span>
            <span class="n">m_generator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">)),</span>
            <span class="n">m_function</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">function</span><span class="p">)),</span>
            <span class="n">m_cache</span><span class="p">(</span><span class="n">m_function</span><span class="p">(</span><span class="n">m_generator</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span>
        <span class="p">{}</span>

        <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_cache</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">success</span> <span class="o">=</span> <span class="n">m_generator</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">m_cache</span> <span class="o">=</span> <span class="n">m_function</span><span class="p">(</span><span class="n">m_generator</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Func</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="n">FunctionReturnType</span><span class="o">&lt;</span><span class="n">Func</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;&gt;</span>
    <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">Func</span><span class="o">&amp;&amp;</span> <span class="n">function</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MapGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Func</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">function</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Func</span><span class="o">&gt;</span>
    <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">Func</span><span class="o">&amp;&amp;</span> <span class="n">function</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MapGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Func</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">function</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">ChunkGenerator</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m_chunk</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">m_chunk_size</span><span class="p">;</span>
        <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m_generator</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_used_up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">ChunkGenerator</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">generator</span><span class="p">)</span> <span class="o">:</span>
            <span class="n">m_chunk_size</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">m_generator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">m_chunk</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">m_chunk_size</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_chunk_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">m_chunk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_generator</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_chunk_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_generator</span><span class="p">.</span><span class="n">next</span><span class="p">())</span> <span class="p">{</span>
                        <span class="n">Catch</span><span class="o">::</span><span class="n">throw_exception</span><span class="p">(</span><span class="n">GeneratorException</span><span class="p">(</span><span class="s">&quot;Not enough values to initialize the first chunk&quot;</span><span class="p">));</span>
                    <span class="p">}</span>
                    <span class="n">m_chunk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_generator</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_chunk</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">m_chunk</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">m_chunk_size</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_generator</span><span class="p">.</span><span class="n">next</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">m_chunk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_generator</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">chunk</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">generator</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span>
            <span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ChunkGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
        <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Generators</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_generators_generic.hpp</span>
<span class="c1">// start catch_generators_specific.hpp</span>

<span class="c1">// start catch_context.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">IResultCapture</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IRunner</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IConfig</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IMutableContext</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">IConfigPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IConfig</span> <span class="k">const</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">IContext</span>
    <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IContext</span><span class="p">();</span>

        <span class="k">virtual</span> <span class="n">IResultCapture</span><span class="o">*</span> <span class="n">getResultCapture</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">IRunner</span><span class="o">*</span> <span class="n">getRunner</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getConfig</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">IMutableContext</span> <span class="o">:</span> <span class="n">IContext</span>
    <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IMutableContext</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setResultCapture</span><span class="p">(</span> <span class="n">IResultCapture</span><span class="o">*</span> <span class="n">resultCapture</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setRunner</span><span class="p">(</span> <span class="n">IRunner</span><span class="o">*</span> <span class="n">runner</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">setConfig</span><span class="p">(</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="k">static</span> <span class="n">IMutableContext</span> <span class="o">*</span><span class="n">currentContext</span><span class="p">;</span>
        <span class="k">friend</span> <span class="n">IMutableContext</span><span class="o">&amp;</span> <span class="n">getCurrentMutableContext</span><span class="p">();</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">cleanUpContext</span><span class="p">();</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="n">createContext</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="kr">inline</span> <span class="n">IMutableContext</span><span class="o">&amp;</span> <span class="n">getCurrentMutableContext</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">IMutableContext</span><span class="o">::</span><span class="n">currentContext</span> <span class="p">)</span>
            <span class="n">IMutableContext</span><span class="o">::</span><span class="n">createContext</span><span class="p">();</span>
        <span class="c1">// NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">IMutableContext</span><span class="o">::</span><span class="n">currentContext</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">inline</span> <span class="n">IContext</span><span class="o">&amp;</span> <span class="n">getCurrentContext</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getCurrentMutableContext</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">cleanUpContext</span><span class="p">();</span>

    <span class="k">class</span> <span class="nc">SimplePcg32</span><span class="p">;</span>
    <span class="n">SimplePcg32</span><span class="o">&amp;</span> <span class="nf">rng</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// end catch_context.h</span>
<span class="c1">// start catch_interfaces_config.h</span>

<span class="c1">// start catch_option.hpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="c1">// An optional type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Option</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Option</span><span class="p">()</span> <span class="o">:</span> <span class="n">nullableValue</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{}</span>
        <span class="n">Option</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_value</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">nullableValue</span><span class="p">(</span> <span class="k">new</span><span class="p">(</span> <span class="n">storage</span> <span class="p">)</span> <span class="n">T</span><span class="p">(</span> <span class="n">_value</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{}</span>
        <span class="n">Option</span><span class="p">(</span> <span class="n">Option</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_other</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">nullableValue</span><span class="p">(</span> <span class="n">_other</span> <span class="o">?</span> <span class="k">new</span><span class="p">(</span> <span class="n">storage</span> <span class="p">)</span> <span class="n">T</span><span class="p">(</span> <span class="o">*</span><span class="n">_other</span> <span class="p">)</span> <span class="o">:</span> <span class="k">nullptr</span> <span class="p">)</span>
        <span class="p">{}</span>

        <span class="o">~</span><span class="n">Option</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">reset</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">Option</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span> <span class="n">Option</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_other</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">_other</span> <span class="o">!=</span> <span class="k">this</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">reset</span><span class="p">();</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">_other</span> <span class="p">)</span>
                    <span class="n">nullableValue</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span> <span class="n">storage</span> <span class="p">)</span> <span class="n">T</span><span class="p">(</span> <span class="o">*</span><span class="n">_other</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Option</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_value</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">reset</span><span class="p">();</span>
            <span class="n">nullableValue</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span> <span class="n">storage</span> <span class="p">)</span> <span class="n">T</span><span class="p">(</span> <span class="n">_value</span> <span class="p">);</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">reset</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">nullableValue</span> <span class="p">)</span>
                <span class="n">nullableValue</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>
            <span class="n">nullableValue</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">nullableValue</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">nullableValue</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nullableValue</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nullableValue</span><span class="p">;</span> <span class="p">}</span>

        <span class="n">T</span> <span class="n">valueOr</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">defaultValue</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">nullableValue</span> <span class="o">?</span> <span class="o">*</span><span class="nl">nullableValue</span> <span class="p">:</span> <span class="n">defaultValue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">some</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nullableValue</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">none</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nullableValue</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span> <span class="o">!</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nullableValue</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">some</span><span class="p">();</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">T</span> <span class="o">*</span><span class="n">nullableValue</span><span class="p">;</span>
        <span class="k">alignas</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">))</span> <span class="kt">char</span> <span class="n">storage</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_option.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">enum</span> <span class="k">class</span> <span class="nc">Verbosity</span> <span class="p">{</span>
        <span class="n">Quiet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">Normal</span><span class="p">,</span>
        <span class="n">High</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">WarnAbout</span> <span class="p">{</span> <span class="k">enum</span> <span class="nc">What</span> <span class="p">{</span>
        <span class="n">Nothing</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
        <span class="n">NoAssertions</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
        <span class="n">NoTests</span> <span class="o">=</span> <span class="mh">0x02</span>
    <span class="p">};</span> <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">ShowDurations</span> <span class="p">{</span> <span class="k">enum</span> <span class="nc">OrNot</span> <span class="p">{</span>
        <span class="n">DefaultForReporter</span><span class="p">,</span>
        <span class="n">Always</span><span class="p">,</span>
        <span class="n">Never</span>
    <span class="p">};</span> <span class="p">};</span>
    <span class="k">struct</span> <span class="nc">RunTests</span> <span class="p">{</span> <span class="k">enum</span> <span class="nc">InWhatOrder</span> <span class="p">{</span>
        <span class="n">InDeclarationOrder</span><span class="p">,</span>
        <span class="n">InLexicographicalOrder</span><span class="p">,</span>
        <span class="n">InRandomOrder</span>
    <span class="p">};</span> <span class="p">};</span>
    <span class="k">struct</span> <span class="nc">UseColour</span> <span class="p">{</span> <span class="k">enum</span> <span class="nc">YesOrNo</span> <span class="p">{</span>
        <span class="n">Auto</span><span class="p">,</span>
        <span class="n">Yes</span><span class="p">,</span>
        <span class="n">No</span>
    <span class="p">};</span> <span class="p">};</span>
    <span class="k">struct</span> <span class="nc">WaitForKeypress</span> <span class="p">{</span> <span class="k">enum</span> <span class="nc">When</span> <span class="p">{</span>
        <span class="n">Never</span><span class="p">,</span>
        <span class="n">BeforeStart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">BeforeExit</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">BeforeStartAndExit</span> <span class="o">=</span> <span class="n">BeforeStart</span> <span class="o">|</span> <span class="n">BeforeExit</span>
    <span class="p">};</span> <span class="p">};</span>

    <span class="k">class</span> <span class="nc">TestSpec</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">IConfig</span> <span class="o">:</span> <span class="n">NonCopyable</span> <span class="p">{</span>

        <span class="k">virtual</span> <span class="o">~</span><span class="n">IConfig</span><span class="p">();</span>

        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">allowThrows</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">includeSuccessfulResults</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">shouldDebugBreak</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">warnAboutMissingAssertions</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">warnAboutNoTests</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">int</span> <span class="n">abortAfter</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">showInvisibles</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">ShowDurations</span><span class="o">::</span><span class="n">OrNot</span> <span class="n">showDurations</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">double</span> <span class="n">minDuration</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">hasTestFilters</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getTestsOrTags</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">RunTests</span><span class="o">::</span><span class="n">InWhatOrder</span> <span class="n">runOrder</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rngSeed</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">YesOrNo</span> <span class="n">useColour</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getSectionsToRun</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">Verbosity</span> <span class="n">verbosity</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">benchmarkNoAnalysis</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">int</span> <span class="n">benchmarkSamples</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">double</span> <span class="n">benchmarkConfidenceInterval</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">benchmarkResamples</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">benchmarkWarmupTime</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">using</span> <span class="n">IConfigPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IConfig</span> <span class="k">const</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// end catch_interfaces_config.h</span>
<span class="c1">// start catch_random_number_generator.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="c1">// This is a simple implementation of C++11 Uniform Random Number</span>
    <span class="c1">// Generator. It does not provide all operators, because Catch2</span>
    <span class="c1">// does not use it, but it should behave as expected inside stdlib&#39;s</span>
    <span class="c1">// distributions.</span>
    <span class="c1">// The implementation is based on the PCG family (http://pcg-random.org)</span>
    <span class="k">class</span> <span class="nc">SimplePcg32</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">state_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span>
        <span class="k">static</span> <span class="k">constexpr</span> <span class="n">result_type</span> <span class="p">(</span><span class="n">min</span><span class="p">)()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">static</span> <span class="k">constexpr</span> <span class="n">result_type</span> <span class="p">(</span><span class="n">max</span><span class="p">)()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">result_type</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Provide some default initial state for the default constructor</span>
        <span class="n">SimplePcg32</span><span class="p">()</span><span class="o">:</span><span class="n">SimplePcg32</span><span class="p">(</span><span class="mh">0xed743cc4U</span><span class="p">)</span> <span class="p">{}</span>

        <span class="k">explicit</span> <span class="n">SimplePcg32</span><span class="p">(</span><span class="n">result_type</span> <span class="n">seed_</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">seed</span><span class="p">(</span><span class="n">result_type</span> <span class="n">seed_</span><span class="p">);</span>
        <span class="kt">void</span> <span class="nf">discard</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">skip</span><span class="p">);</span>

        <span class="n">result_type</span> <span class="nf">operator</span><span class="p">()();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">SimplePcg32</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">SimplePcg32</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">SimplePcg32</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">SimplePcg32</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

        <span class="c1">// In theory we also need operator&lt;&lt; and operator&gt;&gt;</span>
        <span class="c1">// In practice we do not use them, so we will skip them for now</span>

        <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">m_state</span><span class="p">;</span>
        <span class="c1">// This part of the state determines which &quot;stream&quot; of the numbers</span>
        <span class="c1">// is chosen -- we take it as a constant for Catch2, so we only</span>
        <span class="c1">// need to deal with seeding the main state.</span>
        <span class="c1">// Picked by reading 8 bytes from `/dev/random` :-)</span>
        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">s_inc</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x13ed0cc53f939476ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">1ULL</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1ULL</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_random_number_generator.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Generators</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Float</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">RandomFloatingGenerator</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Catch</span><span class="o">::</span><span class="n">SimplePcg32</span><span class="o">&amp;</span> <span class="n">m_rng</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="n">Float</span><span class="o">&gt;</span> <span class="n">m_dist</span><span class="p">;</span>
    <span class="n">Float</span> <span class="n">m_current_number</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>

    <span class="n">RandomFloatingGenerator</span><span class="p">(</span><span class="n">Float</span> <span class="n">a</span><span class="p">,</span> <span class="n">Float</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span>
        <span class="n">m_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">()),</span>
        <span class="n">m_dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">next</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">Float</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_current_number</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">m_current_number</span> <span class="o">=</span> <span class="n">m_dist</span><span class="p">(</span><span class="n">m_rng</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Integer</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">RandomIntegerGenerator</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Catch</span><span class="o">::</span><span class="n">SimplePcg32</span><span class="o">&amp;</span> <span class="n">m_rng</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">m_dist</span><span class="p">;</span>
    <span class="n">Integer</span> <span class="n">m_current_number</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>

    <span class="n">RandomIntegerGenerator</span><span class="p">(</span><span class="n">Integer</span> <span class="n">a</span><span class="p">,</span> <span class="n">Integer</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span>
        <span class="n">m_rng</span><span class="p">(</span><span class="n">rng</span><span class="p">()),</span>
        <span class="n">m_dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">next</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">Integer</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_current_number</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">m_current_number</span> <span class="o">=</span> <span class="n">m_dist</span><span class="p">(</span><span class="n">m_rng</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// TODO: Ideally this would be also constrained against the various char types,</span>
<span class="c1">//       but I don&#39;t expect users to run into that in practice.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
<span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">type</span>
<span class="n">random</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RandomIntegerGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
<span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">type</span>
<span class="n">random</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RandomFloatingGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">RangeGenerator</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">m_current</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">m_end</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">m_step</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">m_positive</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">RangeGenerator</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">step</span><span class="p">)</span><span class="o">:</span>
        <span class="n">m_current</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
        <span class="n">m_end</span><span class="p">(</span><span class="n">end</span><span class="p">),</span>
        <span class="n">m_step</span><span class="p">(</span><span class="n">step</span><span class="p">),</span>
        <span class="n">m_positive</span><span class="p">(</span><span class="n">m_step</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">m_current</span> <span class="o">!=</span> <span class="n">m_end</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Range start and end cannot be equal&quot;</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">m_step</span> <span class="o">!=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Step size cannot be zero&quot;</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(((</span><span class="n">m_positive</span> <span class="o">&amp;&amp;</span> <span class="n">m_current</span> <span class="o">&lt;=</span> <span class="n">m_end</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">m_positive</span> <span class="o">&amp;&amp;</span> <span class="n">m_current</span> <span class="o">&gt;=</span> <span class="n">m_end</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Step moves away from end&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">RangeGenerator</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">)</span><span class="o">:</span>
        <span class="n">RangeGenerator</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="o">?</span> <span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">T</span><span class="p">(</span><span class="mi">-1</span><span class="p">))</span>
    <span class="p">{}</span>

    <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_current</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">m_current</span> <span class="o">+=</span> <span class="n">m_step</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">m_positive</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">m_current</span> <span class="o">&lt;</span> <span class="n">m_end</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">m_current</span> <span class="o">&gt;</span> <span class="n">m_end</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">range</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">step</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">&quot;Type must be numeric&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RangeGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">range</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">&quot;Type must be an integer&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RangeGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IteratorGenerator</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
        <span class="s">&quot;IteratorGenerator currently does not support bools&quot;</span>
        <span class="s">&quot;because of std::vector&lt;bool&gt; specialization&quot;</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">m_elems</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InputSentinel</span><span class="o">&gt;</span>
    <span class="n">IteratorGenerator</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputSentinel</span> <span class="n">last</span><span class="p">)</span><span class="o">:</span><span class="n">m_elems</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_elems</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">throw_exception</span><span class="p">(</span><span class="n">GeneratorException</span><span class="p">(</span><span class="s">&quot;IteratorGenerator received no valid values&quot;</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_elems</span><span class="p">[</span><span class="n">m_current</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">m_current</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">m_current</span> <span class="o">!=</span> <span class="n">m_elems</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">InputIterator</span><span class="p">,</span>
          <span class="k">typename</span> <span class="nc">InputSentinel</span><span class="p">,</span>
          <span class="k">typename</span> <span class="nc">ResultType</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">InputIterator</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">&gt;</span>
<span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span> <span class="n">from_range</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">from</span><span class="p">,</span> <span class="n">InputSentinel</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">IteratorGenerator</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Container</span><span class="p">,</span>
          <span class="k">typename</span> <span class="nc">ResultType</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">Container</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span>
<span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span> <span class="n">from_range</span><span class="p">(</span><span class="n">Container</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GeneratorWrapper</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pf</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">IteratorGenerator</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">cnt</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cnt</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Generators</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_generators_specific.hpp</span>

<span class="c1">// These files are included here so the single_include script doesn&#39;t put them</span>
<span class="c1">// in the conditionally compiled sections</span>
<span class="c1">// start catch_test_case_info.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic push</span>
<span class="cp">#pragma clang diagnostic ignored &quot;-Wpadded&quot;</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">ITestInvoker</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">TestCaseInfo</span> <span class="p">{</span>
        <span class="k">enum</span> <span class="nc">SpecialProperties</span><span class="p">{</span>
            <span class="n">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">IsHidden</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">ShouldFail</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">MayFail</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
            <span class="n">Throws</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
            <span class="n">NonPortable</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span>
            <span class="n">Benchmark</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span>
        <span class="p">};</span>

        <span class="n">TestCaseInfo</span><span class="p">(</span>   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">,</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_className</span><span class="p">,</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_description</span><span class="p">,</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_tags</span><span class="p">,</span>
                        <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_lineInfo</span> <span class="p">);</span>

        <span class="k">friend</span> <span class="kt">void</span> <span class="n">setTags</span><span class="p">(</span> <span class="n">TestCaseInfo</span><span class="o">&amp;</span> <span class="n">testCaseInfo</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">tags</span> <span class="p">);</span>

        <span class="kt">bool</span> <span class="nf">isHidden</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">throws</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">okToFail</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">expectedToFail</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tagsAsString</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">className</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">description</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">tags</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">lcaseTags</span><span class="p">;</span>
        <span class="n">SourceLineInfo</span> <span class="n">lineInfo</span><span class="p">;</span>
        <span class="n">SpecialProperties</span> <span class="n">properties</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">TestCase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TestCaseInfo</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>

        <span class="n">TestCase</span><span class="p">(</span> <span class="n">ITestInvoker</span><span class="o">*</span> <span class="n">testCase</span><span class="p">,</span> <span class="n">TestCaseInfo</span><span class="o">&amp;&amp;</span> <span class="n">info</span> <span class="p">);</span>

        <span class="n">TestCase</span> <span class="nf">withName</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_newName</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">invoke</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getTestCaseInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ITestInvoker</span><span class="o">&gt;</span> <span class="n">test</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">TestCase</span> <span class="nf">makeTestCase</span><span class="p">(</span>  <span class="n">ITestInvoker</span><span class="o">*</span> <span class="n">testCase</span><span class="p">,</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">className</span><span class="p">,</span>
                            <span class="n">NameAndTags</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndTags</span><span class="p">,</span>
                            <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic pop</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_test_case_info.h</span>
<span class="c1">// start catch_interfaces_runner.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">IRunner</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IRunner</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">aborting</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// end catch_interfaces_runner.h</span>

<span class="cp">#ifdef __OBJC__</span>
<span class="c1">// start catch_objc.hpp</span>

<span class="cp">#import &lt;objc/runtime.h&gt;</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="c1">// NB. Any general catch headers included here must be included</span>
<span class="c1">// in catch.hpp first to make sure they are included by the single</span>
<span class="c1">// header for non obj-usage</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// This protocol is really only here for (self) documenting purposes, since</span>
<span class="c1">// all its methods are optional.</span>
<span class="err">@</span><span class="n">protocol</span> <span class="n">OcFixture</span>

<span class="err">@</span><span class="n">optional</span>

<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">setUp</span><span class="p">;</span>
<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">tearDown</span><span class="p">;</span>

<span class="err">@</span><span class="n">end</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">OcMethod</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ITestInvoker</span> <span class="p">{</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">OcMethod</span><span class="p">(</span> <span class="n">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">sel</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_cls</span><span class="p">(</span> <span class="n">cls</span> <span class="p">),</span> <span class="n">m_sel</span><span class="p">(</span> <span class="n">sel</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">invoke</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="n">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">m_cls</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>

            <span class="n">performOptionalSelector</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="err">@</span><span class="n">selector</span><span class="p">(</span><span class="n">setUp</span><span class="p">)</span>  <span class="p">);</span>
            <span class="n">performOptionalSelector</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="n">m_sel</span> <span class="p">);</span>
            <span class="n">performOptionalSelector</span><span class="p">(</span> <span class="n">obj</span><span class="p">,</span> <span class="err">@</span><span class="n">selector</span><span class="p">(</span><span class="n">tearDown</span><span class="p">)</span>  <span class="p">);</span>

            <span class="n">arcSafeRelease</span><span class="p">(</span> <span class="n">obj</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">OcMethod</span><span class="p">()</span> <span class="p">{}</span>

        <span class="n">Class</span> <span class="n">m_cls</span><span class="p">;</span>
        <span class="n">SEL</span> <span class="n">m_sel</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">namespace</span> <span class="n">Detail</span><span class="p">{</span>

        <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getAnnotation</span><span class="p">(</span>   <span class="n">Class</span> <span class="n">cls</span><span class="p">,</span>
                                            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">annotationName</span><span class="p">,</span>
                                            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseName</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">NSString</span><span class="o">*</span> <span class="n">selStr</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="err">@</span><span class="s">&quot;Catch_%s_%s&quot;</span><span class="p">,</span> <span class="n">annotationName</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">testCaseName</span><span class="p">.</span><span class="n">c_str</span><span class="p">()];</span>
            <span class="n">SEL</span> <span class="n">sel</span> <span class="o">=</span> <span class="n">NSSelectorFromString</span><span class="p">(</span> <span class="n">selStr</span> <span class="p">);</span>
            <span class="n">arcSafeRelease</span><span class="p">(</span> <span class="n">selStr</span> <span class="p">);</span>
            <span class="n">id</span> <span class="n">value</span> <span class="o">=</span> <span class="n">performOptionalSelector</span><span class="p">(</span> <span class="n">cls</span><span class="p">,</span> <span class="n">sel</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
                <span class="k">return</span> <span class="p">[(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">value</span> <span class="n">UTF8String</span><span class="p">];</span>
            <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">registerTestMethods</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">noTestMethods</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">noClasses</span> <span class="o">=</span> <span class="n">objc_getClassList</span><span class="p">(</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

        <span class="n">Class</span><span class="o">*</span> <span class="n">classes</span> <span class="o">=</span> <span class="p">(</span><span class="n">CATCH_UNSAFE_UNRETAINED</span> <span class="n">Class</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Class</span><span class="p">)</span> <span class="o">*</span> <span class="n">noClasses</span><span class="p">);</span>
        <span class="n">objc_getClassList</span><span class="p">(</span> <span class="n">classes</span><span class="p">,</span> <span class="n">noClasses</span> <span class="p">);</span>

        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">noClasses</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">classes</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
            <span class="p">{</span>
                <span class="n">u_int</span> <span class="n">count</span><span class="p">;</span>
                <span class="n">Method</span><span class="o">*</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">class_copyMethodList</span><span class="p">(</span> <span class="n">cls</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span> <span class="p">);</span>
                <span class="k">for</span><span class="p">(</span> <span class="n">u_int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="p">;</span> <span class="n">m</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">SEL</span> <span class="n">selector</span> <span class="o">=</span> <span class="n">method_getName</span><span class="p">(</span><span class="n">methods</span><span class="p">[</span><span class="n">m</span><span class="p">]);</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">methodName</span> <span class="o">=</span> <span class="n">sel_getName</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">startsWith</span><span class="p">(</span> <span class="n">methodName</span><span class="p">,</span> <span class="s">&quot;Catch_TestCase_&quot;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">testCaseName</span> <span class="o">=</span> <span class="n">methodName</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="mi">15</span> <span class="p">);</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">getAnnotation</span><span class="p">(</span> <span class="n">cls</span><span class="p">,</span> <span class="s">&quot;Name&quot;</span><span class="p">,</span> <span class="n">testCaseName</span> <span class="p">);</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">getAnnotation</span><span class="p">(</span> <span class="n">cls</span><span class="p">,</span> <span class="s">&quot;Description&quot;</span><span class="p">,</span> <span class="n">testCaseName</span> <span class="p">);</span>
                        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">className</span> <span class="o">=</span> <span class="n">class_getName</span><span class="p">(</span> <span class="n">cls</span> <span class="p">);</span>

                        <span class="n">getMutableRegistryHub</span><span class="p">().</span><span class="n">registerTest</span><span class="p">(</span> <span class="n">makeTestCase</span><span class="p">(</span> <span class="k">new</span> <span class="n">OcMethod</span><span class="p">(</span> <span class="n">cls</span><span class="p">,</span> <span class="n">selector</span> <span class="p">),</span> <span class="n">className</span><span class="p">,</span> <span class="n">NameAndTags</span><span class="p">(</span> <span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">desc</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="p">),</span> <span class="n">SourceLineInfo</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
                        <span class="n">noTestMethods</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">free</span><span class="p">(</span><span class="n">methods</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">noTestMethods</span><span class="p">;</span>
    <span class="p">}</span>

<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>

    <span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Impl</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">NSStringMatchers</span> <span class="p">{</span>

            <span class="k">struct</span> <span class="nc">StringHolder</span> <span class="o">:</span> <span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">NSString</span><span class="o">*&gt;</span><span class="p">{</span>
                <span class="n">StringHolder</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">substr</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_substr</span><span class="p">(</span> <span class="p">[</span><span class="n">substr</span> <span class="n">copy</span><span class="p">]</span> <span class="p">){}</span>
                <span class="n">StringHolder</span><span class="p">(</span> <span class="n">StringHolder</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_substr</span><span class="p">(</span> <span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">m_substr</span> <span class="n">copy</span><span class="p">]</span> <span class="p">){}</span>
                <span class="n">StringHolder</span><span class="p">()</span> <span class="p">{</span>
                    <span class="n">arcSafeRelease</span><span class="p">(</span> <span class="n">m_substr</span> <span class="p">);</span>
                <span class="p">}</span>

                <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">NSString</span><span class="o">*</span> <span class="n">CATCH_ARC_STRONG</span> <span class="n">m_substr</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="nc">Equals</span> <span class="o">:</span> <span class="n">StringHolder</span> <span class="p">{</span>
                <span class="n">Equals</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">substr</span> <span class="p">)</span> <span class="o">:</span> <span class="n">StringHolder</span><span class="p">(</span> <span class="n">substr</span> <span class="p">){}</span>

                <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                    <span class="k">return</span>  <span class="p">(</span><span class="n">str</span> <span class="o">!=</span> <span class="n">nil</span> <span class="o">||</span> <span class="n">m_substr</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="p">[</span><span class="n">str</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="n">m_substr</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="s">&quot;equals string: &quot;</span> <span class="o">+</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_substr</span> <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="nc">Contains</span> <span class="o">:</span> <span class="n">StringHolder</span> <span class="p">{</span>
                <span class="n">Contains</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">substr</span> <span class="p">)</span> <span class="o">:</span> <span class="n">StringHolder</span><span class="p">(</span> <span class="n">substr</span> <span class="p">){}</span>

                <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                    <span class="k">return</span>  <span class="p">(</span><span class="n">str</span> <span class="o">!=</span> <span class="n">nil</span> <span class="o">||</span> <span class="n">m_substr</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="p">[</span><span class="n">str</span> <span class="nl">rangeOfString</span><span class="p">:</span><span class="n">m_substr</span><span class="p">].</span><span class="n">location</span> <span class="o">!=</span> <span class="n">NSNotFound</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="s">&quot;contains string: &quot;</span> <span class="o">+</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_substr</span> <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="nc">StartsWith</span> <span class="o">:</span> <span class="n">StringHolder</span> <span class="p">{</span>
                <span class="n">StartsWith</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">substr</span> <span class="p">)</span> <span class="o">:</span> <span class="n">StringHolder</span><span class="p">(</span> <span class="n">substr</span> <span class="p">){}</span>

                <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                    <span class="k">return</span>  <span class="p">(</span><span class="n">str</span> <span class="o">!=</span> <span class="n">nil</span> <span class="o">||</span> <span class="n">m_substr</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="p">[</span><span class="n">str</span> <span class="nl">rangeOfString</span><span class="p">:</span><span class="n">m_substr</span><span class="p">].</span><span class="n">location</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="s">&quot;starts with: &quot;</span> <span class="o">+</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_substr</span> <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">};</span>
            <span class="k">struct</span> <span class="nc">EndsWith</span> <span class="o">:</span> <span class="n">StringHolder</span> <span class="p">{</span>
                <span class="n">EndsWith</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">substr</span> <span class="p">)</span> <span class="o">:</span> <span class="n">StringHolder</span><span class="p">(</span> <span class="n">substr</span> <span class="p">){}</span>

                <span class="kt">bool</span> <span class="n">match</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                    <span class="k">return</span>  <span class="p">(</span><span class="n">str</span> <span class="o">!=</span> <span class="n">nil</span> <span class="o">||</span> <span class="n">m_substr</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">)</span> <span class="o">&amp;&amp;</span>
                            <span class="p">[</span><span class="n">str</span> <span class="nl">rangeOfString</span><span class="p">:</span><span class="n">m_substr</span><span class="p">].</span><span class="n">location</span> <span class="o">==</span> <span class="p">[</span><span class="n">str</span> <span class="n">length</span><span class="p">]</span> <span class="o">-</span> <span class="p">[</span><span class="n">m_substr</span> <span class="n">length</span><span class="p">];</span>
                <span class="p">}</span>

                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="s">&quot;ends with: &quot;</span> <span class="o">+</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_substr</span> <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">};</span>

        <span class="p">}</span> <span class="c1">// namespace NSStringMatchers</span>
        <span class="p">}</span> <span class="c1">// namespace Impl</span>

        <span class="kr">inline</span> <span class="n">Impl</span><span class="o">::</span><span class="n">NSStringMatchers</span><span class="o">::</span><span class="n">Equals</span>
            <span class="n">Equals</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">substr</span> <span class="p">){</span> <span class="k">return</span> <span class="n">Impl</span><span class="o">::</span><span class="n">NSStringMatchers</span><span class="o">::</span><span class="n">Equals</span><span class="p">(</span> <span class="n">substr</span> <span class="p">);</span> <span class="p">}</span>

        <span class="kr">inline</span> <span class="n">Impl</span><span class="o">::</span><span class="n">NSStringMatchers</span><span class="o">::</span><span class="n">Contains</span>
            <span class="n">Contains</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">substr</span> <span class="p">){</span> <span class="k">return</span> <span class="n">Impl</span><span class="o">::</span><span class="n">NSStringMatchers</span><span class="o">::</span><span class="n">Contains</span><span class="p">(</span> <span class="n">substr</span> <span class="p">);</span> <span class="p">}</span>

        <span class="kr">inline</span> <span class="n">Impl</span><span class="o">::</span><span class="n">NSStringMatchers</span><span class="o">::</span><span class="n">StartsWith</span>
            <span class="n">StartsWith</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">substr</span> <span class="p">){</span> <span class="k">return</span> <span class="n">Impl</span><span class="o">::</span><span class="n">NSStringMatchers</span><span class="o">::</span><span class="n">StartsWith</span><span class="p">(</span> <span class="n">substr</span> <span class="p">);</span> <span class="p">}</span>

        <span class="kr">inline</span> <span class="n">Impl</span><span class="o">::</span><span class="n">NSStringMatchers</span><span class="o">::</span><span class="n">EndsWith</span>
            <span class="n">EndsWith</span><span class="p">(</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">substr</span> <span class="p">){</span> <span class="k">return</span> <span class="n">Impl</span><span class="o">::</span><span class="n">NSStringMatchers</span><span class="o">::</span><span class="n">EndsWith</span><span class="p">(</span> <span class="n">substr</span> <span class="p">);</span> <span class="p">}</span>

    <span class="p">}</span> <span class="c1">// namespace Matchers</span>

    <span class="k">using</span> <span class="k">namespace</span> <span class="n">Matchers</span><span class="p">;</span>

<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">///////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">#define OC_MAKE_UNIQUE_NAME( root, uniqueSuffix ) root##uniqueSuffix</span>
<span class="cp">#define OC_TEST_CASE2( name, desc, uniqueSuffix ) \</span>
<span class="cp">+(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Name_test_, uniqueSuffix ) \</span>
<span class="cp">{ \</span>
<span class="cp">return @ name; \</span>
<span class="cp">} \</span>
<span class="cp">+(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Description_test_, uniqueSuffix ) \</span>
<span class="cp">{ \</span>
<span class="cp">return @ desc; \</span>
<span class="cp">} \</span>
<span class="cp">-(void) OC_MAKE_UNIQUE_NAME( Catch_TestCase_test_, uniqueSuffix )</span>

<span class="cp">#define OC_TEST_CASE( name, desc ) OC_TEST_CASE2( name, desc, __LINE__ )</span>

<span class="c1">// end catch_objc.hpp</span>
<span class="cp">#endif</span>

<span class="c1">// Benchmarking needs the externally-facing parts of reporters to work</span>
<span class="cp">#if defined(CATCH_CONFIG_EXTERNAL_INTERFACES) || defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
<span class="c1">// start catch_external_interfaces.h</span>

<span class="c1">// start catch_reporter_bases.hpp</span>

<span class="c1">// start catch_interfaces_reporter.h</span>

<span class="c1">// start catch_config.hpp</span>

<span class="c1">// start catch_test_spec_parser.h</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic push</span>
<span class="cp">#pragma clang diagnostic ignored &quot;-Wpadded&quot;</span>
<span class="cp">#endif</span>

<span class="c1">// start catch_test_spec.h</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic push</span>
<span class="cp">#pragma clang diagnostic ignored &quot;-Wpadded&quot;</span>
<span class="cp">#endif</span>

<span class="c1">// start catch_wildcard_pattern.h</span>

<span class="k">namespace</span> <span class="n">Catch</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">WildcardPattern</span> <span class="p">{</span>
        <span class="k">enum</span> <span class="nc">WildcardPosition</span> <span class="p">{</span>
            <span class="n">NoWildcard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">WildcardAtStart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">WildcardAtEnd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">WildcardAtBothEnds</span> <span class="o">=</span> <span class="n">WildcardAtStart</span> <span class="o">|</span> <span class="n">WildcardAtEnd</span>
        <span class="p">};</span>

    <span class="k">public</span><span class="o">:</span>

        <span class="n">WildcardPattern</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="p">);</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">WildcardPattern</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">matches</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">normaliseString</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">m_caseSensitivity</span><span class="p">;</span>
        <span class="n">WildcardPosition</span> <span class="n">m_wildcard</span> <span class="o">=</span> <span class="n">NoWildcard</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_pattern</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// end catch_wildcard_pattern.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">IConfig</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">TestSpec</span> <span class="p">{</span>
        <span class="k">class</span> <span class="nc">Pattern</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="k">explicit</span> <span class="n">Pattern</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span> <span class="p">);</span>
            <span class="k">virtual</span> <span class="o">~</span><span class="n">Pattern</span><span class="p">();</span>
            <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="k">private</span><span class="o">:</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="n">m_name</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">using</span> <span class="n">PatternPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Pattern</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="k">class</span> <span class="nc">NamePattern</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Pattern</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="k">explicit</span> <span class="n">NamePattern</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filterString</span> <span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">private</span><span class="o">:</span>
            <span class="n">WildcardPattern</span> <span class="n">m_wildcardPattern</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">class</span> <span class="nc">TagPattern</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Pattern</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="k">explicit</span> <span class="n">TagPattern</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tag</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filterString</span> <span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">private</span><span class="o">:</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_tag</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">class</span> <span class="nc">ExcludedPattern</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Pattern</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="k">explicit</span> <span class="n">ExcludedPattern</span><span class="p">(</span> <span class="n">PatternPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">underlyingPattern</span> <span class="p">);</span>
            <span class="kt">bool</span> <span class="nf">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">private</span><span class="o">:</span>
            <span class="n">PatternPtr</span> <span class="n">m_underlyingPattern</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="nc">Filter</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PatternPtr</span><span class="o">&gt;</span> <span class="n">m_patterns</span><span class="p">;</span>

            <span class="kt">bool</span> <span class="nf">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="p">};</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="k">struct</span> <span class="nc">FilterMatch</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span> <span class="k">const</span><span class="o">*&gt;</span> <span class="n">tests</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">using</span> <span class="n">Matches</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FilterMatch</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">vectorStrings</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">hasFilters</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">Matches</span> <span class="nf">matchesByFilter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCases</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">vectorStrings</span> <span class="o">&amp;</span> <span class="n">getInvalidArgs</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Filter</span><span class="o">&gt;</span> <span class="n">m_filters</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m_invalidArgs</span><span class="p">;</span>
        <span class="k">friend</span> <span class="k">class</span> <span class="nc">TestSpecParser</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic pop</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_test_spec.h</span>
<span class="c1">// start catch_interfaces_tag_alias_registry.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">TagAlias</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">ITagAliasRegistry</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">ITagAliasRegistry</span><span class="p">();</span>
        <span class="c1">// Nullptr if not present</span>
        <span class="k">virtual</span> <span class="n">TagAlias</span> <span class="k">const</span><span class="o">*</span> <span class="n">find</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">alias</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expandAliases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">unexpandedTestSpec</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">static</span> <span class="n">ITagAliasRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">();</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_interfaces_tag_alias_registry.h</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">TestSpecParser</span> <span class="p">{</span>
        <span class="k">enum</span> <span class="nc">Mode</span><span class="p">{</span> <span class="n">None</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">QuotedName</span><span class="p">,</span> <span class="n">Tag</span><span class="p">,</span> <span class="n">EscapedName</span> <span class="p">};</span>
        <span class="n">Mode</span> <span class="n">m_mode</span> <span class="o">=</span> <span class="n">None</span><span class="p">;</span>
        <span class="n">Mode</span> <span class="n">lastMode</span> <span class="o">=</span> <span class="n">None</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_exclusion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_realPatternPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_arg</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_substring</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_patternName</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">m_escapeChars</span><span class="p">;</span>
        <span class="n">TestSpec</span><span class="o">::</span><span class="n">Filter</span> <span class="n">m_currentFilter</span><span class="p">;</span>
        <span class="n">TestSpec</span> <span class="n">m_testSpec</span><span class="p">;</span>
        <span class="n">ITagAliasRegistry</span> <span class="k">const</span><span class="o">*</span> <span class="n">m_tagAliases</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">TestSpecParser</span><span class="p">(</span> <span class="n">ITagAliasRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tagAliases</span> <span class="p">);</span>

        <span class="n">TestSpecParser</span><span class="o">&amp;</span> <span class="nf">parse</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arg</span> <span class="p">);</span>
        <span class="n">TestSpec</span> <span class="nf">testSpec</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">bool</span> <span class="n">visitChar</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">);</span>
        <span class="kt">void</span> <span class="nf">startNewMode</span><span class="p">(</span> <span class="n">Mode</span> <span class="n">mode</span> <span class="p">);</span>
        <span class="kt">bool</span> <span class="nf">processNoneChar</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">);</span>
        <span class="kt">void</span> <span class="nf">processNameChar</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">);</span>
        <span class="kt">bool</span> <span class="nf">processOtherChar</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">);</span>
        <span class="kt">void</span> <span class="nf">endMode</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">escape</span><span class="p">();</span>
        <span class="kt">bool</span> <span class="nf">isControlChar</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">saveLastMode</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">revertBackToLastMode</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">addFilter</span><span class="p">();</span>
        <span class="kt">bool</span> <span class="nf">separate</span><span class="p">();</span>

        <span class="c1">// Handles common preprocessing of the pattern for name/tag patterns</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">preprocessPattern</span><span class="p">();</span>
        <span class="c1">// Adds the current pattern as a test name</span>
        <span class="kt">void</span> <span class="nf">addNamePattern</span><span class="p">();</span>
        <span class="c1">// Adds the current pattern as a tag</span>
        <span class="kt">void</span> <span class="nf">addTagPattern</span><span class="p">();</span>

        <span class="kr">inline</span> <span class="kt">void</span> <span class="n">addCharToPattern</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_substring</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
            <span class="n">m_patternName</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
            <span class="n">m_realPatternPos</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">};</span>
    <span class="n">TestSpec</span> <span class="nf">parseTestSpec</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arg</span> <span class="p">);</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic pop</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_test_spec_parser.h</span>
<span class="c1">// Libstdc++ doesn&#39;t like incomplete classes for unique_ptr</span>

<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="cp">#ifndef CATCH_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#define CATCH_CONFIG_CONSOLE_WIDTH 80</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">IStream</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">ConfigData</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">listTests</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">listTags</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">listReporters</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">listTestNamesOnly</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="n">showSuccessfulTests</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">shouldDebugBreak</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">noThrow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">showHelp</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">showInvisibles</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">filenamesAsTags</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">libIdentify</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">abortAfter</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rngSeed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="n">benchmarkNoAnalysis</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">benchmarkSamples</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">benchmarkConfidenceInterval</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">benchmarkResamples</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">::</span><span class="n">rep</span> <span class="n">benchmarkWarmupTime</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

        <span class="n">Verbosity</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">Normal</span><span class="p">;</span>
        <span class="n">WarnAbout</span><span class="o">::</span><span class="n">What</span> <span class="n">warnings</span> <span class="o">=</span> <span class="n">WarnAbout</span><span class="o">::</span><span class="n">Nothing</span><span class="p">;</span>
        <span class="n">ShowDurations</span><span class="o">::</span><span class="n">OrNot</span> <span class="n">showDurations</span> <span class="o">=</span> <span class="n">ShowDurations</span><span class="o">::</span><span class="n">DefaultForReporter</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">minDuration</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
        <span class="n">RunTests</span><span class="o">::</span><span class="n">InWhatOrder</span> <span class="n">runOrder</span> <span class="o">=</span> <span class="n">RunTests</span><span class="o">::</span><span class="n">InDeclarationOrder</span><span class="p">;</span>
        <span class="n">UseColour</span><span class="o">::</span><span class="n">YesOrNo</span> <span class="n">useColour</span> <span class="o">=</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">Auto</span><span class="p">;</span>
        <span class="n">WaitForKeypress</span><span class="o">::</span><span class="n">When</span> <span class="n">waitForKeypress</span> <span class="o">=</span> <span class="n">WaitForKeypress</span><span class="o">::</span><span class="n">Never</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">outputFilename</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">processName</span><span class="p">;</span>
<span class="cp">#ifndef CATCH_CONFIG_DEFAULT_REPORTER</span>
<span class="cp">#define CATCH_CONFIG_DEFAULT_REPORTER &quot;console&quot;</span>
<span class="cp">#endif</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">reporterName</span> <span class="o">=</span> <span class="n">CATCH_CONFIG_DEFAULT_REPORTER</span><span class="p">;</span>
<span class="cp">#undef CATCH_CONFIG_DEFAULT_REPORTER</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">testsOrTags</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">sectionsToRun</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Config</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IConfig</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>

        <span class="n">Config</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">Config</span><span class="p">(</span> <span class="n">ConfigData</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">data</span> <span class="p">);</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">Config</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getFilename</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">listTests</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">listTestNamesOnly</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">listTags</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">listReporters</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getProcessName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getReporterName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getTestsOrTags</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getSectionsToRun</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">hasTestFilters</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">showHelp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="c1">// IConfig interface</span>
        <span class="kt">bool</span> <span class="nf">allowThrows</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">includeSuccessfulResults</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">warnAboutMissingAssertions</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">warnAboutNoTests</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">ShowDurations</span><span class="o">::</span><span class="n">OrNot</span> <span class="n">showDurations</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">double</span> <span class="nf">minDuration</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">RunTests</span><span class="o">::</span><span class="n">InWhatOrder</span> <span class="n">runOrder</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rngSeed</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">UseColour</span><span class="o">::</span><span class="n">YesOrNo</span> <span class="n">useColour</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">shouldDebugBreak</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">int</span> <span class="nf">abortAfter</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">showInvisibles</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">Verbosity</span> <span class="nf">verbosity</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">benchmarkNoAnalysis</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">int</span> <span class="nf">benchmarkSamples</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">double</span> <span class="nf">benchmarkConfidenceInterval</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">benchmarkResamples</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">benchmarkWarmupTime</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>

        <span class="n">IStream</span> <span class="k">const</span><span class="o">*</span> <span class="n">openStream</span><span class="p">();</span>
        <span class="n">ConfigData</span> <span class="n">m_data</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IStream</span> <span class="k">const</span><span class="o">&gt;</span> <span class="n">m_stream</span><span class="p">;</span>
        <span class="n">TestSpec</span> <span class="n">m_testSpec</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_hasTestFilters</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_config.hpp</span>
<span class="c1">// start catch_assertionresult.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">AssertionResultData</span>
    <span class="p">{</span>
        <span class="n">AssertionResultData</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="n">AssertionResultData</span><span class="p">(</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">_resultType</span><span class="p">,</span> <span class="n">LazyExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_lazyExpression</span> <span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">;</span>
        <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">reconstructedExpression</span><span class="p">;</span>
        <span class="n">LazyExpression</span> <span class="n">lazyExpression</span><span class="p">;</span>
        <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">reconstructExpression</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">AssertionResult</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">AssertionResult</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">AssertionResult</span><span class="p">(</span> <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span> <span class="n">AssertionResultData</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">data</span> <span class="p">);</span>

        <span class="kt">bool</span> <span class="nf">isOk</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">succeeded</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">getResultType</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">hasExpression</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">hasMessage</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getExpression</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getExpressionInMacro</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">hasExpandedExpression</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getExpandedExpression</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getMessage</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">SourceLineInfo</span> <span class="nf">getSourceInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">StringRef</span> <span class="nf">getTestMacroName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//protected:</span>
        <span class="n">AssertionInfo</span> <span class="n">m_info</span><span class="p">;</span>
        <span class="n">AssertionResultData</span> <span class="n">m_resultData</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_assertionresult.h</span>
<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
<span class="c1">// start catch_estimate.hpp</span>

 <span class="c1">// Statistics estimates</span>


<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">Estimate</span> <span class="p">{</span>
            <span class="n">Duration</span> <span class="n">point</span><span class="p">;</span>
            <span class="n">Duration</span> <span class="n">lower_bound</span><span class="p">;</span>
            <span class="n">Duration</span> <span class="n">upper_bound</span><span class="p">;</span>
            <span class="kt">double</span> <span class="n">confidence_interval</span><span class="p">;</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration2</span><span class="o">&gt;</span>
            <span class="k">operator</span> <span class="n">Estimate</span><span class="o">&lt;</span><span class="n">Duration2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">{</span> <span class="n">point</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">confidence_interval</span> <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_estimate.hpp</span>
<span class="c1">// start catch_outlier_classification.hpp</span>

<span class="c1">// Outlier information</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">OutlierClassification</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">samples_seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">low_severe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// more than 3 times IQR below Q1</span>
            <span class="kt">int</span> <span class="n">low_mild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">// 1.5 to 3 times IQR below Q1</span>
            <span class="kt">int</span> <span class="n">high_mild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// 1.5 to 3 times IQR above Q3</span>
            <span class="kt">int</span> <span class="n">high_severe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// more than 3 times IQR above Q3</span>

            <span class="kt">int</span> <span class="nf">total</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">low_severe</span> <span class="o">+</span> <span class="n">low_mild</span> <span class="o">+</span> <span class="n">high_mild</span> <span class="o">+</span> <span class="n">high_severe</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_outlier_classification.hpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">ReporterConfig</span> <span class="p">{</span>
        <span class="k">explicit</span> <span class="nf">ReporterConfig</span><span class="p">(</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_fullConfig</span> <span class="p">);</span>

        <span class="n">ReporterConfig</span><span class="p">(</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_fullConfig</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">_stream</span> <span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">IConfigPtr</span> <span class="nf">fullConfig</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">m_stream</span><span class="p">;</span>
        <span class="n">IConfigPtr</span> <span class="n">m_fullConfig</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">ReporterPreferences</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">shouldRedirectStdOut</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">shouldReportAllAssertions</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">LazyStat</span> <span class="o">:</span> <span class="n">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">LazyStat</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_value</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">_value</span> <span class="p">);</span>
            <span class="n">used</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">reset</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">reset</span><span class="p">();</span>
            <span class="n">used</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">used</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">TestRunInfo</span> <span class="p">{</span>
        <span class="n">TestRunInfo</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span> <span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="nc">GroupInfo</span> <span class="p">{</span>
        <span class="n">GroupInfo</span><span class="p">(</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">_groupIndex</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">_groupsCount</span> <span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">groupIndex</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">groupsCounts</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">AssertionStats</span> <span class="p">{</span>
        <span class="n">AssertionStats</span><span class="p">(</span> <span class="n">AssertionResult</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_assertionResult</span><span class="p">,</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MessageInfo</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_infoMessages</span><span class="p">,</span>
                        <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_totals</span> <span class="p">);</span>

        <span class="n">AssertionStats</span><span class="p">(</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span>              <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">AssertionStats</span><span class="p">(</span> <span class="n">AssertionStats</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>                  <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">AssertionStats</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">AssertionStats</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">AssertionStats</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>     <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">AssertionStats</span><span class="p">();</span>

        <span class="n">AssertionResult</span> <span class="n">assertionResult</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MessageInfo</span><span class="o">&gt;</span> <span class="n">infoMessages</span><span class="p">;</span>
        <span class="n">Totals</span> <span class="n">totals</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">SectionStats</span> <span class="p">{</span>
        <span class="n">SectionStats</span><span class="p">(</span>   <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_sectionInfo</span><span class="p">,</span>
                        <span class="n">Counts</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_assertions</span><span class="p">,</span>
                        <span class="kt">double</span> <span class="n">_durationInSeconds</span><span class="p">,</span>
                        <span class="kt">bool</span> <span class="n">_missingAssertions</span> <span class="p">);</span>
        <span class="n">SectionStats</span><span class="p">(</span> <span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span>              <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">SectionStats</span><span class="p">(</span> <span class="n">SectionStats</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>                  <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">SectionStats</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">SectionStats</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">SectionStats</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>     <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">SectionStats</span><span class="p">();</span>

        <span class="n">SectionInfo</span> <span class="n">sectionInfo</span><span class="p">;</span>
        <span class="n">Counts</span> <span class="n">assertions</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">durationInSeconds</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">missingAssertions</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">TestCaseStats</span> <span class="p">{</span>
        <span class="n">TestCaseStats</span><span class="p">(</span>  <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testInfo</span><span class="p">,</span>
                        <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_totals</span><span class="p">,</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_stdOut</span><span class="p">,</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_stdErr</span><span class="p">,</span>
                        <span class="kt">bool</span> <span class="n">_aborting</span> <span class="p">);</span>

        <span class="n">TestCaseStats</span><span class="p">(</span> <span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span>              <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">TestCaseStats</span><span class="p">(</span> <span class="n">TestCaseStats</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>                  <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">TestCaseStats</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">TestCaseStats</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">TestCaseStats</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>     <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">TestCaseStats</span><span class="p">();</span>

        <span class="n">TestCaseInfo</span> <span class="n">testInfo</span><span class="p">;</span>
        <span class="n">Totals</span> <span class="n">totals</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">stdOut</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">stdErr</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">aborting</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">TestGroupStats</span> <span class="p">{</span>
        <span class="n">TestGroupStats</span><span class="p">(</span> <span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_groupInfo</span><span class="p">,</span>
                        <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_totals</span><span class="p">,</span>
                        <span class="kt">bool</span> <span class="n">_aborting</span> <span class="p">);</span>
        <span class="n">TestGroupStats</span><span class="p">(</span> <span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_groupInfo</span> <span class="p">);</span>

        <span class="n">TestGroupStats</span><span class="p">(</span> <span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span>              <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">TestGroupStats</span><span class="p">(</span> <span class="n">TestGroupStats</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>                  <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">TestGroupStats</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">TestGroupStats</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">TestGroupStats</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>     <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">TestGroupStats</span><span class="p">();</span>

        <span class="n">GroupInfo</span> <span class="n">groupInfo</span><span class="p">;</span>
        <span class="n">Totals</span> <span class="n">totals</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">aborting</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">TestRunStats</span> <span class="p">{</span>
        <span class="n">TestRunStats</span><span class="p">(</span>   <span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_runInfo</span><span class="p">,</span>
                        <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_totals</span><span class="p">,</span>
                        <span class="kt">bool</span> <span class="n">_aborting</span> <span class="p">);</span>

        <span class="n">TestRunStats</span><span class="p">(</span> <span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span>              <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">TestRunStats</span><span class="p">(</span> <span class="n">TestRunStats</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>                  <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">TestRunStats</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">TestRunStats</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">TestRunStats</span> <span class="o">&amp;&amp;</span> <span class="p">)</span>     <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">TestRunStats</span><span class="p">();</span>

        <span class="n">TestRunInfo</span> <span class="n">runInfo</span><span class="p">;</span>
        <span class="n">Totals</span> <span class="n">totals</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">aborting</span><span class="p">;</span>
    <span class="p">};</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
    <span class="k">struct</span> <span class="nc">BenchmarkInfo</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">estimatedDuration</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">iterations</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">samples</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resamples</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">clockResolution</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">clockCost</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Duration</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">BenchmarkStats</span> <span class="p">{</span>
        <span class="n">BenchmarkInfo</span> <span class="n">info</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">;</span>
        <span class="n">Benchmark</span><span class="o">::</span><span class="n">Estimate</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">mean</span><span class="p">;</span>
        <span class="n">Benchmark</span><span class="o">::</span><span class="n">Estimate</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">standardDeviation</span><span class="p">;</span>
        <span class="n">Benchmark</span><span class="o">::</span><span class="n">OutlierClassification</span> <span class="n">outliers</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">outlierVariance</span><span class="p">;</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration2</span><span class="o">&gt;</span>
        <span class="k">operator</span> <span class="n">BenchmarkStats</span><span class="o">&lt;</span><span class="n">Duration2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Duration2</span><span class="o">&gt;</span> <span class="n">samples2</span><span class="p">;</span>
            <span class="n">samples2</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
            <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">samples</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">samples2</span><span class="p">),</span> <span class="p">[](</span><span class="n">Duration</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Duration2</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="p">});</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">info</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">samples2</span><span class="p">),</span>
                <span class="n">mean</span><span class="p">,</span>
                <span class="n">standardDeviation</span><span class="p">,</span>
                <span class="n">outliers</span><span class="p">,</span>
                <span class="n">outlierVariance</span><span class="p">,</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

    <span class="k">struct</span> <span class="nc">IStreamingReporter</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IStreamingReporter</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="c1">// Implementing class must also provide the following static methods:</span>
        <span class="c1">// static std::string getDescription();</span>
        <span class="c1">// static std::set&lt;Verbosity&gt; getSupportedVerbosities()</span>

        <span class="k">virtual</span> <span class="n">ReporterPreferences</span> <span class="n">getPreferences</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">noMatchingTestCases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">spec</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">reportInvalidArguments</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">testRunStarting</span><span class="p">(</span> <span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testRunInfo</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">testGroupStarting</span><span class="p">(</span> <span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">groupInfo</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">testCaseStarting</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">sectionStarting</span><span class="p">(</span> <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionInfo</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">benchmarkPreparing</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">benchmarkStarting</span><span class="p">(</span> <span class="n">BenchmarkInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">benchmarkEnded</span><span class="p">(</span> <span class="n">BenchmarkStats</span><span class="o">&lt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">benchmarkFailed</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">assertionStarting</span><span class="p">(</span> <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionInfo</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// The return value indicates if the messages buffer should be cleared:</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">assertionEnded</span><span class="p">(</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionStats</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">sectionEnded</span><span class="p">(</span> <span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionStats</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">testCaseEnded</span><span class="p">(</span> <span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseStats</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">testGroupEnded</span><span class="p">(</span> <span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testGroupStats</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">testRunEnded</span><span class="p">(</span> <span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testRunStats</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">skipTest</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// Default empty implementation provided</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fatalErrorEncountered</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">name</span> <span class="p">);</span>

        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isMulti</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">using</span> <span class="n">IStreamingReporterPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IStreamingReporter</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">IReporterFactory</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">IReporterFactory</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="n">IStreamingReporterPtr</span> <span class="n">create</span><span class="p">(</span> <span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getDescription</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">using</span> <span class="n">IReporterFactoryPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IReporterFactory</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">IReporterRegistry</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">FactoryMap</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">IReporterFactoryPtr</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">Listeners</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IReporterFactoryPtr</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="o">~</span><span class="n">IReporterRegistry</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="n">IStreamingReporterPtr</span> <span class="n">create</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">FactoryMap</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getFactories</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">Listeners</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getListeners</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_interfaces_reporter.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cfloat&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">prepareExpandedExpression</span><span class="p">(</span><span class="n">AssertionResult</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">);</span>

    <span class="c1">// Returns double formatted as %.3f (format expected on output)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getFormattedDuration</span><span class="p">(</span> <span class="kt">double</span> <span class="n">duration</span> <span class="p">);</span>

    <span class="c1">//! Should the reporter show</span>
    <span class="kt">bool</span> <span class="nf">shouldShowDuration</span><span class="p">(</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">,</span> <span class="kt">double</span> <span class="n">duration</span> <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">serializeFilters</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">container</span> <span class="p">);</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">DerivedT</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">StreamingReporterBase</span> <span class="o">:</span> <span class="n">IStreamingReporter</span> <span class="p">{</span>

        <span class="n">StreamingReporterBase</span><span class="p">(</span> <span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_config</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">m_config</span><span class="p">(</span> <span class="n">_config</span><span class="p">.</span><span class="n">fullConfig</span><span class="p">()</span> <span class="p">),</span>
            <span class="n">stream</span><span class="p">(</span> <span class="n">_config</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">m_reporterPrefs</span><span class="p">.</span><span class="n">shouldRedirectStdOut</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">DerivedT</span><span class="o">::</span><span class="n">getSupportedVerbosities</span><span class="p">().</span><span class="n">count</span><span class="p">(</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">verbosity</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">CATCH_ERROR</span><span class="p">(</span> <span class="s">&quot;Verbosity level not supported by this reporter&quot;</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">ReporterPreferences</span> <span class="n">getPreferences</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_reporterPrefs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Verbosity</span><span class="o">&gt;</span> <span class="n">getSupportedVerbosities</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">Normal</span> <span class="p">};</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">StreamingReporterBase</span><span class="p">()</span> <span class="k">override</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">noMatchingTestCases</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span> <span class="p">{}</span>

        <span class="kt">void</span> <span class="nf">reportInvalidArguments</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span> <span class="p">{}</span>

        <span class="kt">void</span> <span class="nf">testRunStarting</span><span class="p">(</span><span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testRunInfo</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">currentTestRunInfo</span> <span class="o">=</span> <span class="n">_testRunInfo</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">testGroupStarting</span><span class="p">(</span><span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_groupInfo</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">currentGroupInfo</span> <span class="o">=</span> <span class="n">_groupInfo</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">testCaseStarting</span><span class="p">(</span><span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testInfo</span><span class="p">)</span> <span class="k">override</span>  <span class="p">{</span>
            <span class="n">currentTestCaseInfo</span> <span class="o">=</span> <span class="n">_testInfo</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">sectionStarting</span><span class="p">(</span><span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_sectionInfo</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">m_sectionStack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">_sectionInfo</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">sectionEnded</span><span class="p">(</span><span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="cm">/* _sectionStats */</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">m_sectionStack</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">testCaseEnded</span><span class="p">(</span><span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="cm">/* _testCaseStats */</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">currentTestCaseInfo</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">testGroupEnded</span><span class="p">(</span><span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="cm">/* _testGroupStats */</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">currentGroupInfo</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">testRunEnded</span><span class="p">(</span><span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="cm">/* _testRunStats */</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">currentTestCaseInfo</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
            <span class="n">currentGroupInfo</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
            <span class="n">currentTestRunInfo</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">skipTest</span><span class="p">(</span><span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="c1">// Don&#39;t do anything with this by default.</span>
            <span class="c1">// It can optionally be overridden in the derived class.</span>
        <span class="p">}</span>

        <span class="n">IConfigPtr</span> <span class="n">m_config</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">;</span>

        <span class="n">LazyStat</span><span class="o">&lt;</span><span class="n">TestRunInfo</span><span class="o">&gt;</span> <span class="n">currentTestRunInfo</span><span class="p">;</span>
        <span class="n">LazyStat</span><span class="o">&lt;</span><span class="n">GroupInfo</span><span class="o">&gt;</span> <span class="n">currentGroupInfo</span><span class="p">;</span>
        <span class="n">LazyStat</span><span class="o">&lt;</span><span class="n">TestCaseInfo</span><span class="o">&gt;</span> <span class="n">currentTestCaseInfo</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SectionInfo</span><span class="o">&gt;</span> <span class="n">m_sectionStack</span><span class="p">;</span>
        <span class="n">ReporterPreferences</span> <span class="n">m_reporterPrefs</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">DerivedT</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">CumulativeReporterBase</span> <span class="o">:</span> <span class="n">IStreamingReporter</span> <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ChildNodeT</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
            <span class="k">explicit</span> <span class="nf">Node</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_value</span> <span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span> <span class="n">_value</span> <span class="p">)</span> <span class="p">{}</span>
            <span class="k">virtual</span> <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{}</span>

            <span class="k">using</span> <span class="n">ChildNodes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ChildNodeT</span><span class="o">&gt;&gt;</span><span class="p">;</span>
            <span class="n">T</span> <span class="n">value</span><span class="p">;</span>
            <span class="n">ChildNodes</span> <span class="n">children</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">struct</span> <span class="nc">SectionNode</span> <span class="p">{</span>
            <span class="k">explicit</span> <span class="nf">SectionNode</span><span class="p">(</span><span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_stats</span><span class="p">)</span> <span class="o">:</span> <span class="n">stats</span><span class="p">(</span><span class="n">_stats</span><span class="p">)</span> <span class="p">{}</span>
            <span class="k">virtual</span> <span class="o">~</span><span class="n">SectionNode</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

            <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span><span class="n">SectionNode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">stats</span><span class="p">.</span><span class="n">sectionInfo</span><span class="p">.</span><span class="n">lineInfo</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">sectionInfo</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SectionNode</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">SectionStats</span> <span class="n">stats</span><span class="p">;</span>
            <span class="k">using</span> <span class="n">ChildSections</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SectionNode</span><span class="o">&gt;&gt;</span><span class="p">;</span>
            <span class="k">using</span> <span class="n">Assertions</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AssertionStats</span><span class="o">&gt;</span><span class="p">;</span>
            <span class="n">ChildSections</span> <span class="n">childSections</span><span class="p">;</span>
            <span class="n">Assertions</span> <span class="n">assertions</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">stdOut</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">stdErr</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="nc">BySectionInfo</span> <span class="p">{</span>
            <span class="n">BySectionInfo</span><span class="p">(</span> <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_other</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span> <span class="p">{}</span>
            <span class="n">BySectionInfo</span><span class="p">(</span> <span class="n">BySectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_other</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">m_other</span> <span class="p">)</span> <span class="p">{}</span>
            <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SectionNode</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sectionInfo</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">m_other</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                        <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sectionInfo</span><span class="p">.</span><span class="n">lineInfo</span> <span class="o">==</span> <span class="n">m_other</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">BySectionInfo</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="k">private</span><span class="o">:</span>
            <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m_other</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">using</span> <span class="n">TestCaseNode</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">TestCaseStats</span><span class="p">,</span> <span class="n">SectionNode</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">TestGroupNode</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">TestGroupStats</span><span class="p">,</span> <span class="n">TestCaseNode</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">TestRunNode</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">TestRunStats</span><span class="p">,</span> <span class="n">TestGroupNode</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="n">CumulativeReporterBase</span><span class="p">(</span> <span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_config</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">m_config</span><span class="p">(</span> <span class="n">_config</span><span class="p">.</span><span class="n">fullConfig</span><span class="p">()</span> <span class="p">),</span>
            <span class="n">stream</span><span class="p">(</span> <span class="n">_config</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">m_reporterPrefs</span><span class="p">.</span><span class="n">shouldRedirectStdOut</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">DerivedT</span><span class="o">::</span><span class="n">getSupportedVerbosities</span><span class="p">().</span><span class="n">count</span><span class="p">(</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">verbosity</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">CATCH_ERROR</span><span class="p">(</span> <span class="s">&quot;Verbosity level not supported by this reporter&quot;</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="o">~</span><span class="n">CumulativeReporterBase</span><span class="p">()</span> <span class="k">override</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="n">ReporterPreferences</span> <span class="nf">getPreferences</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_reporterPrefs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Verbosity</span><span class="o">&gt;</span> <span class="n">getSupportedVerbosities</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">Normal</span> <span class="p">};</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">testRunStarting</span><span class="p">(</span> <span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{}</span>
        <span class="kt">void</span> <span class="n">testGroupStarting</span><span class="p">(</span> <span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{}</span>

        <span class="kt">void</span> <span class="n">testCaseStarting</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{}</span>

        <span class="kt">void</span> <span class="n">sectionStarting</span><span class="p">(</span> <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionInfo</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">SectionStats</span> <span class="nf">incompleteStats</span><span class="p">(</span> <span class="n">sectionInfo</span><span class="p">,</span> <span class="n">Counts</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span> <span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SectionNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_sectionStack</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">m_rootSection</span> <span class="p">)</span>
                    <span class="n">m_rootSection</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SectionNode</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">incompleteStats</span> <span class="p">);</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">m_rootSection</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">SectionNode</span><span class="o">&amp;</span> <span class="n">parentNode</span> <span class="o">=</span> <span class="o">*</span><span class="n">m_sectionStack</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
                <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>   <span class="n">parentNode</span><span class="p">.</span><span class="n">childSections</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                                    <span class="n">parentNode</span><span class="p">.</span><span class="n">childSections</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                                    <span class="n">BySectionInfo</span><span class="p">(</span> <span class="n">sectionInfo</span> <span class="p">)</span> <span class="p">);</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">it</span> <span class="o">==</span> <span class="n">parentNode</span><span class="p">.</span><span class="n">childSections</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SectionNode</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">incompleteStats</span> <span class="p">);</span>
                    <span class="n">parentNode</span><span class="p">.</span><span class="n">childSections</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">m_sectionStack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
            <span class="n">m_deepestSection</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">assertionStarting</span><span class="p">(</span><span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span> <span class="p">{}</span>

        <span class="kt">bool</span> <span class="n">assertionEnded</span><span class="p">(</span><span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionStats</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_sectionStack</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
            <span class="c1">// AssertionResult holds a pointer to a temporary DecomposedExpression,</span>
            <span class="c1">// which getExpandedExpression() calls to build the expression string.</span>
            <span class="c1">// Our section stack copy of the assertionResult will likely outlive the</span>
            <span class="c1">// temporary, so it must be expanded or discarded now to avoid calling</span>
            <span class="c1">// a destroyed object later.</span>
            <span class="n">prepareExpandedExpression</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">AssertionResult</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">assertionStats</span><span class="p">.</span><span class="n">assertionResult</span> <span class="p">)</span> <span class="p">);</span>
            <span class="n">SectionNode</span><span class="o">&amp;</span> <span class="n">sectionNode</span> <span class="o">=</span> <span class="o">*</span><span class="n">m_sectionStack</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
            <span class="n">sectionNode</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">assertionStats</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">sectionEnded</span><span class="p">(</span><span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionStats</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_sectionStack</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
            <span class="n">SectionNode</span><span class="o">&amp;</span> <span class="n">node</span> <span class="o">=</span> <span class="o">*</span><span class="n">m_sectionStack</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
            <span class="n">node</span><span class="p">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">sectionStats</span><span class="p">;</span>
            <span class="n">m_sectionStack</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">testCaseEnded</span><span class="p">(</span><span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseStats</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">TestCaseNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">testCaseStats</span><span class="p">);</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">m_sectionStack</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_rootSection</span><span class="p">);</span>
            <span class="n">m_testCases</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="n">m_rootSection</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

            <span class="n">assert</span><span class="p">(</span><span class="n">m_deepestSection</span><span class="p">);</span>
            <span class="n">m_deepestSection</span><span class="o">-&gt;</span><span class="n">stdOut</span> <span class="o">=</span> <span class="n">testCaseStats</span><span class="p">.</span><span class="n">stdOut</span><span class="p">;</span>
            <span class="n">m_deepestSection</span><span class="o">-&gt;</span><span class="n">stdErr</span> <span class="o">=</span> <span class="n">testCaseStats</span><span class="p">.</span><span class="n">stdErr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">testGroupEnded</span><span class="p">(</span><span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testGroupStats</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">TestGroupNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">testGroupStats</span><span class="p">);</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">m_testCases</span><span class="p">);</span>
            <span class="n">m_testGroups</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">testRunEnded</span><span class="p">(</span><span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testRunStats</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">TestRunNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">testRunStats</span><span class="p">);</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">m_testGroups</span><span class="p">);</span>
            <span class="n">m_testRuns</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
            <span class="n">testRunEndedCumulative</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">testRunEndedCumulative</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">skipTest</span><span class="p">(</span><span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span> <span class="p">{}</span>

        <span class="n">IConfigPtr</span> <span class="n">m_config</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AssertionStats</span><span class="o">&gt;</span> <span class="n">m_assertions</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SectionNode</span><span class="o">&gt;&gt;&gt;</span> <span class="n">m_sections</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TestCaseNode</span><span class="o">&gt;&gt;</span> <span class="n">m_testCases</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TestGroupNode</span><span class="o">&gt;&gt;</span> <span class="n">m_testGroups</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TestRunNode</span><span class="o">&gt;&gt;</span> <span class="n">m_testRuns</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SectionNode</span><span class="o">&gt;</span> <span class="n">m_rootSection</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SectionNode</span><span class="o">&gt;</span> <span class="n">m_deepestSection</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SectionNode</span><span class="o">&gt;&gt;</span> <span class="n">m_sectionStack</span><span class="p">;</span>
        <span class="n">ReporterPreferences</span> <span class="n">m_reporterPrefs</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="kt">char</span> <span class="n">C</span><span class="o">&gt;</span>
    <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">getLineOfChars</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!*</span><span class="n">line</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">memset</span><span class="p">(</span> <span class="n">line</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span><span class="mi">-1</span> <span class="p">);</span>
            <span class="n">line</span><span class="p">[</span><span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span><span class="mi">-1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">line</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="nc">TestEventListenerBase</span> <span class="o">:</span> <span class="n">StreamingReporterBase</span><span class="o">&lt;</span><span class="n">TestEventListenerBase</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">TestEventListenerBase</span><span class="p">(</span> <span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_config</span> <span class="p">);</span>

        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Verbosity</span><span class="o">&gt;</span> <span class="n">getSupportedVerbosities</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">assertionStarting</span><span class="p">(</span><span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">assertionEnded</span><span class="p">(</span><span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_reporter_bases.hpp</span>
<span class="c1">// start catch_console_colour.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">Colour</span> <span class="p">{</span>
        <span class="k">enum</span> <span class="nc">Code</span> <span class="p">{</span>
            <span class="n">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

            <span class="n">White</span><span class="p">,</span>
            <span class="n">Red</span><span class="p">,</span>
            <span class="n">Green</span><span class="p">,</span>
            <span class="n">Blue</span><span class="p">,</span>
            <span class="n">Cyan</span><span class="p">,</span>
            <span class="n">Yellow</span><span class="p">,</span>
            <span class="n">Grey</span><span class="p">,</span>

            <span class="n">Bright</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>

            <span class="n">BrightRed</span> <span class="o">=</span> <span class="n">Bright</span> <span class="o">|</span> <span class="n">Red</span><span class="p">,</span>
            <span class="n">BrightGreen</span> <span class="o">=</span> <span class="n">Bright</span> <span class="o">|</span> <span class="n">Green</span><span class="p">,</span>
            <span class="n">LightGrey</span> <span class="o">=</span> <span class="n">Bright</span> <span class="o">|</span> <span class="n">Grey</span><span class="p">,</span>
            <span class="n">BrightWhite</span> <span class="o">=</span> <span class="n">Bright</span> <span class="o">|</span> <span class="n">White</span><span class="p">,</span>
            <span class="n">BrightYellow</span> <span class="o">=</span> <span class="n">Bright</span> <span class="o">|</span> <span class="n">Yellow</span><span class="p">,</span>

            <span class="c1">// By intention</span>
            <span class="n">FileName</span> <span class="o">=</span> <span class="n">LightGrey</span><span class="p">,</span>
            <span class="n">Warning</span> <span class="o">=</span> <span class="n">BrightYellow</span><span class="p">,</span>
            <span class="n">ResultError</span> <span class="o">=</span> <span class="n">BrightRed</span><span class="p">,</span>
            <span class="n">ResultSuccess</span> <span class="o">=</span> <span class="n">BrightGreen</span><span class="p">,</span>
            <span class="n">ResultExpectedFailure</span> <span class="o">=</span> <span class="n">Warning</span><span class="p">,</span>

            <span class="n">Error</span> <span class="o">=</span> <span class="n">BrightRed</span><span class="p">,</span>
            <span class="n">Success</span> <span class="o">=</span> <span class="n">Green</span><span class="p">,</span>

            <span class="n">OriginalExpression</span> <span class="o">=</span> <span class="n">Cyan</span><span class="p">,</span>
            <span class="n">ReconstructedExpression</span> <span class="o">=</span> <span class="n">BrightYellow</span><span class="p">,</span>

            <span class="n">SecondaryText</span> <span class="o">=</span> <span class="n">LightGrey</span><span class="p">,</span>
            <span class="n">Headers</span> <span class="o">=</span> <span class="n">White</span>
        <span class="p">};</span>

        <span class="c1">// Use constructed object for RAII guard</span>
        <span class="n">Colour</span><span class="p">(</span> <span class="n">Code</span> <span class="n">_colourCode</span> <span class="p">);</span>
        <span class="n">Colour</span><span class="p">(</span> <span class="n">Colour</span><span class="o">&amp;&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
        <span class="n">Colour</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">Colour</span><span class="o">&amp;&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
        <span class="o">~</span><span class="n">Colour</span><span class="p">();</span>

        <span class="c1">// Use static method for one-shot changes</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="n">use</span><span class="p">(</span> <span class="n">Code</span> <span class="n">_colourCode</span> <span class="p">);</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">bool</span> <span class="n">m_moved</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">Colour</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">);</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_console_colour.h</span>
<span class="c1">// start catch_reporter_registrars.hpp</span>


<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">ReporterRegistrar</span> <span class="p">{</span>

        <span class="k">class</span> <span class="nc">ReporterFactory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IReporterFactory</span> <span class="p">{</span>

            <span class="n">IStreamingReporterPtr</span> <span class="nf">create</span><span class="p">(</span> <span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span> <span class="k">new</span> <span class="n">T</span><span class="p">(</span> <span class="n">config</span> <span class="p">)</span> <span class="p">);</span>
            <span class="p">}</span>

            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getDescription</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">T</span><span class="o">::</span><span class="n">getDescription</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">};</span>

    <span class="k">public</span><span class="o">:</span>

        <span class="k">explicit</span> <span class="n">ReporterRegistrar</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">getMutableRegistryHub</span><span class="p">().</span><span class="n">registerReporter</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ReporterFactory</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">ListenerRegistrar</span> <span class="p">{</span>

        <span class="k">class</span> <span class="nc">ListenerFactory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IReporterFactory</span> <span class="p">{</span>

            <span class="n">IStreamingReporterPtr</span> <span class="nf">create</span><span class="p">(</span> <span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span> <span class="k">new</span> <span class="n">T</span><span class="p">(</span> <span class="n">config</span> <span class="p">)</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getDescription</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">};</span>

    <span class="k">public</span><span class="o">:</span>

        <span class="n">ListenerRegistrar</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">getMutableRegistryHub</span><span class="p">().</span><span class="n">registerListener</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ListenerFactory</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cp">#if !defined(CATCH_CONFIG_DISABLE)</span>

<span class="cp">#define CATCH_REGISTER_REPORTER( name, reporterType ) \</span>
<span class="cp">    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION         \</span>
<span class="cp">    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS          \</span>
<span class="cp">    namespace{ Catch::ReporterRegistrar&lt;reporterType&gt; catch_internal_RegistrarFor##reporterType( name ); } \</span>
<span class="cp">    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION</span>

<span class="cp">#define CATCH_REGISTER_LISTENER( listenerType ) \</span>
<span class="cp">    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION   \</span>
<span class="cp">    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS    \</span>
<span class="cp">    namespace{ Catch::ListenerRegistrar&lt;listenerType&gt; catch_internal_RegistrarFor##listenerType; } \</span>
<span class="cp">    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION</span>
<span class="cp">#else </span><span class="c1">// CATCH_CONFIG_DISABLE</span>

<span class="cp">#define CATCH_REGISTER_REPORTER(name, reporterType)</span>
<span class="cp">#define CATCH_REGISTER_LISTENER(listenerType)</span>

<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE</span>

<span class="c1">// end catch_reporter_registrars.hpp</span>
<span class="c1">// Allow users to base their work off existing reporters</span>
<span class="c1">// start catch_reporter_compact.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">CompactReporter</span> <span class="o">:</span> <span class="n">StreamingReporterBase</span><span class="o">&lt;</span><span class="n">CompactReporter</span><span class="o">&gt;</span> <span class="p">{</span>

        <span class="k">using</span> <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">StreamingReporterBase</span><span class="p">;</span>

        <span class="o">~</span><span class="n">CompactReporter</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getDescription</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">noMatchingTestCases</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">spec</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">assertionStarting</span><span class="p">(</span><span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">assertionEnded</span><span class="p">(</span><span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_assertionStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">sectionEnded</span><span class="p">(</span><span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_sectionStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testRunEnded</span><span class="p">(</span><span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testRunStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_reporter_compact.h</span>
<span class="c1">// start catch_reporter_console.h</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#pragma warning(push)</span>
<span class="cp">#pragma warning(disable:4061) </span><span class="c1">// Not all labels are EXPLICITLY handled in switch</span>
                              <span class="c1">// Note that 4062 (not all labels are handled</span>
                              <span class="c1">// and default is missing) is enabled</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="c1">// Fwd decls</span>
    <span class="k">struct</span> <span class="nc">SummaryColumn</span><span class="p">;</span>
    <span class="k">class</span> <span class="nc">TablePrinter</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">ConsoleReporter</span> <span class="o">:</span> <span class="n">StreamingReporterBase</span><span class="o">&lt;</span><span class="n">ConsoleReporter</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TablePrinter</span><span class="o">&gt;</span> <span class="n">m_tablePrinter</span><span class="p">;</span>

        <span class="n">ConsoleReporter</span><span class="p">(</span><span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">);</span>
        <span class="o">~</span><span class="n">ConsoleReporter</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getDescription</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">noMatchingTestCases</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">spec</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">reportInvalidArguments</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">assertionStarting</span><span class="p">(</span><span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">assertionEnded</span><span class="p">(</span><span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_assertionStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">sectionStarting</span><span class="p">(</span><span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_sectionInfo</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">sectionEnded</span><span class="p">(</span><span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_sectionStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
        <span class="kt">void</span> <span class="nf">benchmarkPreparing</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkStarting</span><span class="p">(</span><span class="n">BenchmarkInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkEnded</span><span class="p">(</span><span class="n">BenchmarkStats</span><span class="o">&lt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkFailed</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

        <span class="kt">void</span> <span class="nf">testCaseEnded</span><span class="p">(</span><span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testCaseStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">testGroupEnded</span><span class="p">(</span><span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testGroupStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">testRunEnded</span><span class="p">(</span><span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testRunStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">testRunStarting</span><span class="p">(</span><span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testRunInfo</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="k">private</span><span class="o">:</span>

        <span class="kt">void</span> <span class="n">lazyPrint</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">lazyPrintWithoutClosingBenchmarkTable</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">lazyPrintRunInfo</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">lazyPrintGroupInfo</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">printTestCaseAndSectionHeader</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">printClosedHeader</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">);</span>
        <span class="kt">void</span> <span class="nf">printOpenHeader</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">);</span>

        <span class="c1">// if string has a : in first line will set indent to follow it on</span>
        <span class="c1">// subsequent lines</span>
        <span class="kt">void</span> <span class="nf">printHeaderString</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">indent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">printTotals</span><span class="p">(</span><span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">totals</span><span class="p">);</span>
        <span class="kt">void</span> <span class="nf">printSummaryRow</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">label</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SummaryColumn</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">cols</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">row</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">printTotalsDivider</span><span class="p">(</span><span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">totals</span><span class="p">);</span>
        <span class="kt">void</span> <span class="nf">printSummaryDivider</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">printTestFilters</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">bool</span> <span class="n">m_headerPrinted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#pragma warning(pop)</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_reporter_console.h</span>
<span class="c1">// start catch_reporter_junit.h</span>

<span class="c1">// start catch_xmlwriter.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">XmlFormatting</span> <span class="p">{</span>
        <span class="n">None</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
        <span class="n">Indent</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
        <span class="n">Newline</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="n">XmlFormatting</span> <span class="k">operator</span> <span class="o">|</span> <span class="p">(</span><span class="n">XmlFormatting</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">rhs</span><span class="p">);</span>
    <span class="n">XmlFormatting</span> <span class="k">operator</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XmlFormatting</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">rhs</span><span class="p">);</span>

    <span class="k">class</span> <span class="nc">XmlEncode</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">enum</span> <span class="nc">ForWhat</span> <span class="p">{</span> <span class="n">ForTextNodes</span><span class="p">,</span> <span class="n">ForAttributes</span> <span class="p">};</span>

        <span class="n">XmlEncode</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">ForWhat</span> <span class="n">forWhat</span> <span class="o">=</span> <span class="n">ForTextNodes</span> <span class="p">);</span>

        <span class="kt">void</span> <span class="nf">encodeTo</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">XmlEncode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">xmlEncode</span> <span class="p">);</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_str</span><span class="p">;</span>
        <span class="n">ForWhat</span> <span class="n">m_forWhat</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">XmlWriter</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>

        <span class="k">class</span> <span class="nc">ScopedElement</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">ScopedElement</span><span class="p">(</span> <span class="n">XmlWriter</span><span class="o">*</span> <span class="n">writer</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="p">);</span>

            <span class="n">ScopedElement</span><span class="p">(</span> <span class="n">ScopedElement</span><span class="o">&amp;&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
            <span class="n">ScopedElement</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">ScopedElement</span><span class="o">&amp;&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

            <span class="o">~</span><span class="n">ScopedElement</span><span class="p">();</span>

            <span class="n">ScopedElement</span><span class="o">&amp;</span> <span class="nf">writeText</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="o">|</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Indent</span> <span class="p">);</span>

            <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
            <span class="n">ScopedElement</span><span class="o">&amp;</span> <span class="n">writeAttribute</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">attribute</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">m_writer</span><span class="o">-&gt;</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span> <span class="n">attribute</span> <span class="p">);</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="k">private</span><span class="o">:</span>
            <span class="k">mutable</span> <span class="n">XmlWriter</span><span class="o">*</span> <span class="n">m_writer</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
            <span class="n">XmlFormatting</span> <span class="n">m_fmt</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">XmlWriter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="p">);</span>
        <span class="o">~</span><span class="n">XmlWriter</span><span class="p">();</span>

        <span class="n">XmlWriter</span><span class="p">(</span> <span class="n">XmlWriter</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">XmlWriter</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="nf">startElement</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="o">|</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Indent</span><span class="p">);</span>

        <span class="n">ScopedElement</span> <span class="nf">scopedElement</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="o">|</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Indent</span><span class="p">);</span>

        <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="nf">endElement</span><span class="p">(</span><span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="o">|</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Indent</span><span class="p">);</span>

        <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="nf">writeAttribute</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">attribute</span> <span class="p">);</span>

        <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="nf">writeAttribute</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">attribute</span> <span class="p">);</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="n">writeAttribute</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">attribute</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">attribute</span><span class="p">;</span>
            <span class="k">return</span> <span class="nf">writeAttribute</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="n">writeText</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="o">|</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Indent</span><span class="p">);</span>

        <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="nf">writeComment</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="o">=</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="o">|</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Indent</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">writeStylesheetRef</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">url</span> <span class="p">);</span>

        <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="nf">writeBlankLine</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">ensureTagClosed</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>

        <span class="kt">void</span> <span class="n">applyFormatting</span><span class="p">(</span><span class="n">XmlFormatting</span> <span class="n">fmt</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">writeDeclaration</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">newlineIfNecessary</span><span class="p">();</span>

        <span class="kt">bool</span> <span class="n">m_tagIsOpen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_needsNewline</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m_tags</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_indent</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">m_os</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span>

<span class="c1">// end catch_xmlwriter.h</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">JunitReporter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CumulativeReporterBase</span><span class="o">&lt;</span><span class="n">JunitReporter</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">JunitReporter</span><span class="p">(</span><span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_config</span><span class="p">);</span>

        <span class="o">~</span><span class="n">JunitReporter</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getDescription</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">noMatchingTestCases</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="cm">/*spec*/</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testRunStarting</span><span class="p">(</span><span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">runInfo</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testGroupStarting</span><span class="p">(</span><span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">groupInfo</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testCaseStarting</span><span class="p">(</span><span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseInfo</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">assertionEnded</span><span class="p">(</span><span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testCaseEnded</span><span class="p">(</span><span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testGroupEnded</span><span class="p">(</span><span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testGroupStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testRunEndedCumulative</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">writeGroup</span><span class="p">(</span><span class="n">TestGroupNode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">groupNode</span><span class="p">,</span> <span class="kt">double</span> <span class="n">suiteTime</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">writeTestCase</span><span class="p">(</span><span class="n">TestCaseNode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseNode</span><span class="p">);</span>

        <span class="kt">void</span> <span class="nf">writeSection</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">className</span><span class="p">,</span>
                           <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rootName</span><span class="p">,</span>
                           <span class="n">SectionNode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionNode</span><span class="p">,</span>
                           <span class="kt">bool</span> <span class="n">testOkToFail</span> <span class="p">);</span>

        <span class="kt">void</span> <span class="nf">writeAssertions</span><span class="p">(</span><span class="n">SectionNode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionNode</span><span class="p">);</span>
        <span class="kt">void</span> <span class="nf">writeAssertion</span><span class="p">(</span><span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stats</span><span class="p">);</span>

        <span class="n">XmlWriter</span> <span class="n">xml</span><span class="p">;</span>
        <span class="n">Timer</span> <span class="n">suiteTimer</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">stdOutForSuite</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">stdErrForSuite</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unexpectedExceptions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_okToFail</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_reporter_junit.h</span>
<span class="c1">// start catch_reporter_xml.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">XmlReporter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">StreamingReporterBase</span><span class="o">&lt;</span><span class="n">XmlReporter</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">XmlReporter</span><span class="p">(</span><span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_config</span><span class="p">);</span>

        <span class="o">~</span><span class="n">XmlReporter</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getDescription</span><span class="p">();</span>

        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getStylesheetRef</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">writeSourceInfo</span><span class="p">(</span><span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sourceInfo</span><span class="p">);</span>

    <span class="k">public</span><span class="o">:</span> <span class="c1">// StreamingReporterBase</span>

        <span class="kt">void</span> <span class="n">noMatchingTestCases</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testRunStarting</span><span class="p">(</span><span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testGroupStarting</span><span class="p">(</span><span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">groupInfo</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testCaseStarting</span><span class="p">(</span><span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">sectionStarting</span><span class="p">(</span><span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionInfo</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">assertionStarting</span><span class="p">(</span><span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">assertionEnded</span><span class="p">(</span><span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">sectionEnded</span><span class="p">(</span><span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testCaseEnded</span><span class="p">(</span><span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testGroupEnded</span><span class="p">(</span><span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testGroupStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testRunEnded</span><span class="p">(</span><span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testRunStats</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
        <span class="kt">void</span> <span class="nf">benchmarkPreparing</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkStarting</span><span class="p">(</span><span class="n">BenchmarkInfo</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkEnded</span><span class="p">(</span><span class="n">BenchmarkStats</span><span class="o">&lt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkFailed</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">Timer</span> <span class="n">m_testCaseTimer</span><span class="p">;</span>
        <span class="n">XmlWriter</span> <span class="n">m_xml</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m_sectionDepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_reporter_xml.h</span>

<span class="c1">// end catch_external_interfaces.h</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
<span class="c1">// start catch_benchmarking_all.hpp</span>

<span class="c1">// A proxy header that includes all of the benchmarking headers to allow</span>
<span class="c1">// concise include of the benchmarking features. You should prefer the</span>
<span class="c1">// individual includes in standard use.</span>

<span class="c1">// start catch_benchmark.hpp</span>

 <span class="c1">// Benchmark</span>

<span class="c1">// start catch_chronometer.hpp</span>

<span class="c1">// User-facing chronometer</span>


<span class="c1">// start catch_clock.hpp</span>

<span class="c1">// Clocks</span>


<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ratio&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
        <span class="k">using</span> <span class="n">ClockDuration</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">Clock</span><span class="o">::</span><span class="n">duration</span><span class="p">;</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
        <span class="k">using</span> <span class="n">FloatDuration</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Clock</span><span class="o">::</span><span class="n">period</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
        <span class="k">using</span> <span class="n">TimePoint</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">Clock</span><span class="o">::</span><span class="n">time_point</span><span class="p">;</span>

        <span class="k">using</span> <span class="n">default_clock</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="p">;</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">now</span> <span class="p">{</span>
            <span class="n">TimePoint</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span> <span class="k">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">using</span> <span class="n">fp_seconds</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;&gt;</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_clock.hpp</span>
<span class="c1">// start catch_optimizer.hpp</span>

 <span class="c1">// Hinting the optimizer</span>


<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#   include &lt;atomic&gt; </span><span class="c1">// atomic_thread_fence</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
<span class="cp">#if defined(__GNUC__) || defined(__clang__)</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="kr">inline</span> <span class="kt">void</span> <span class="n">keep_memory</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">asm</span> <span class="nf">volatile</span><span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;g&quot;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kr">inline</span> <span class="kt">void</span> <span class="n">keep_memory</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">asm</span> <span class="nf">volatile</span><span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="kr">inline</span> <span class="kt">void</span> <span class="n">optimizer_barrier</span><span class="p">()</span> <span class="p">{</span> <span class="n">keep_memory</span><span class="p">();</span> <span class="p">}</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>
<span class="cp">#elif defined(_MSC_VER)</span>

<span class="cp">#pragma optimize(&quot;&quot;, off)</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="kr">inline</span> <span class="kt">void</span> <span class="n">keep_memory</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// thanks @milleniumbug</span>
            <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">volatile</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="k">volatile</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// TODO equivalent keep_memory()</span>
<span class="cp">#pragma optimize(&quot;&quot;, on)</span>

        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="kr">inline</span> <span class="kt">void</span> <span class="n">optimizer_barrier</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>

<span class="cp">#endif</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="kr">inline</span> <span class="kt">void</span> <span class="n">deoptimize_value</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">keep_memory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
        <span class="kr">inline</span> <span class="k">auto</span> <span class="n">invoke_deoptimized</span><span class="p">(</span><span class="n">Fn</span><span class="o">&amp;&amp;</span> <span class="n">fn</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">args</span><span class="p">...))</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span> <span class="p">{</span>
            <span class="n">deoptimize_value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fn</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">...)));</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
        <span class="kr">inline</span> <span class="k">auto</span> <span class="n">invoke_deoptimized</span><span class="p">(</span><span class="n">Fn</span><span class="o">&amp;&amp;</span> <span class="n">fn</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">args</span><span class="p">...))</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fn</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">...));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_optimizer.hpp</span>
<span class="c1">// start catch_complete_invoke.hpp</span>

<span class="c1">// Invoke with a special case for void</span>


<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
            <span class="k">struct</span> <span class="nc">CompleteType</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="p">};</span>
            <span class="k">template</span> <span class="o">&lt;&gt;</span>
            <span class="k">struct</span> <span class="nc">CompleteType</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">struct</span> <span class="nc">type</span> <span class="p">{};</span> <span class="p">};</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
            <span class="k">using</span> <span class="n">CompleteType_t</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">CompleteType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Result</span><span class="o">&gt;</span>
            <span class="k">struct</span> <span class="nc">CompleteInvoker</span> <span class="p">{</span>
                <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
                <span class="k">static</span> <span class="n">Result</span> <span class="n">invoke</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
                <span class="p">}</span>
            <span class="p">};</span>
            <span class="k">template</span> <span class="o">&lt;&gt;</span>
            <span class="k">struct</span> <span class="nc">CompleteInvoker</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
                <span class="k">static</span> <span class="n">CompleteType_t</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">invoke</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
                    <span class="k">return</span> <span class="p">{};</span>
                <span class="p">}</span>
            <span class="p">};</span>

            <span class="c1">// invoke and not return void :(</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
            <span class="n">CompleteType_t</span><span class="o">&lt;</span><span class="n">FunctionReturnType</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;&gt;</span> <span class="n">complete_invoke</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">CompleteInvoker</span><span class="o">&lt;</span><span class="n">FunctionReturnType</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;&gt;::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
            <span class="p">}</span>

            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">benchmarkErrorMsg</span> <span class="o">=</span> <span class="s">&quot;a benchmark failed to run successfully&quot;</span><span class="p">;</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
        <span class="n">Detail</span><span class="o">::</span><span class="n">CompleteType_t</span><span class="o">&lt;</span><span class="n">FunctionReturnType</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;&gt;</span> <span class="n">user_code</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">CATCH_TRY</span><span class="p">{</span>
                <span class="k">return</span> <span class="n">Detail</span><span class="o">::</span><span class="n">complete_invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">));</span>
            <span class="p">}</span> <span class="n">CATCH_CATCH_ALL</span><span class="p">{</span>
                <span class="n">getResultCapture</span><span class="p">().</span><span class="n">benchmarkFailed</span><span class="p">(</span><span class="n">translateActiveException</span><span class="p">());</span>
                <span class="n">CATCH_RUNTIME_ERROR</span><span class="p">(</span><span class="n">Detail</span><span class="o">::</span><span class="n">benchmarkErrorMsg</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_complete_invoke.hpp</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="nc">ChronometerConcept</span> <span class="p">{</span>
                <span class="k">virtual</span> <span class="kt">void</span> <span class="n">start</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">virtual</span> <span class="kt">void</span> <span class="n">finish</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">virtual</span> <span class="o">~</span><span class="n">ChronometerConcept</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
            <span class="p">};</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
            <span class="k">struct</span> <span class="nc">ChronometerModel</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ChronometerConcept</span> <span class="p">{</span>
                <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">started</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span> <span class="p">}</span>
                <span class="kt">void</span> <span class="nf">finish</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">finished</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span> <span class="p">}</span>

                <span class="n">ClockDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span> <span class="n">elapsed</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">finished</span> <span class="o">-</span> <span class="n">started</span><span class="p">;</span> <span class="p">}</span>

                <span class="n">TimePoint</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span> <span class="n">started</span><span class="p">;</span>
                <span class="n">TimePoint</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span> <span class="n">finished</span><span class="p">;</span>
            <span class="p">};</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>

        <span class="k">struct</span> <span class="nc">Chronometer</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
            <span class="kt">void</span> <span class="n">measure</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">)</span> <span class="p">{</span> <span class="n">measure</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">),</span> <span class="n">is_callable</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="p">());</span> <span class="p">}</span>

            <span class="kt">int</span> <span class="n">runs</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">k</span><span class="p">;</span> <span class="p">}</span>

            <span class="n">Chronometer</span><span class="p">(</span><span class="n">Detail</span><span class="o">::</span><span class="n">ChronometerConcept</span><span class="o">&amp;</span> <span class="n">meter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
                <span class="o">:</span> <span class="n">impl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">meter</span><span class="p">)</span>
                <span class="p">,</span> <span class="n">k</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{}</span>

        <span class="k">private</span><span class="o">:</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
            <span class="kt">void</span> <span class="n">measure</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">measure</span><span class="p">([</span><span class="o">&amp;</span><span class="n">fun</span><span class="p">](</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">fun</span><span class="p">();</span> <span class="p">},</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
            <span class="kt">void</span> <span class="n">measure</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Detail</span><span class="o">::</span><span class="n">optimizer_barrier</span><span class="p">();</span>
                <span class="n">impl</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">();</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">invoke_deoptimized</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                <span class="n">impl</span><span class="o">-&gt;</span><span class="n">finish</span><span class="p">();</span>
                <span class="n">Detail</span><span class="o">::</span><span class="n">optimizer_barrier</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="n">Detail</span><span class="o">::</span><span class="n">ChronometerConcept</span><span class="o">*</span> <span class="n">impl</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_chronometer.hpp</span>
<span class="c1">// start catch_environment.hpp</span>

<span class="c1">// Environment information</span>


<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">EnvironmentEstimate</span> <span class="p">{</span>
            <span class="n">Duration</span> <span class="n">mean</span><span class="p">;</span>
            <span class="n">OutlierClassification</span> <span class="n">outliers</span><span class="p">;</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration2</span><span class="o">&gt;</span>
            <span class="k">operator</span> <span class="n">EnvironmentEstimate</span><span class="o">&lt;</span><span class="n">Duration2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">{</span> <span class="n">mean</span><span class="p">,</span> <span class="n">outliers</span> <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">};</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">Environment</span> <span class="p">{</span>
            <span class="k">using</span> <span class="n">clock_type</span> <span class="o">=</span> <span class="n">Clock</span><span class="p">;</span>
            <span class="n">EnvironmentEstimate</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">clock_resolution</span><span class="p">;</span>
            <span class="n">EnvironmentEstimate</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">clock_cost</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_environment.hpp</span>
<span class="c1">// start catch_execution_plan.hpp</span>

 <span class="c1">// Execution plan</span>


<span class="c1">// start catch_benchmark_function.hpp</span>

 <span class="c1">// Dumb std::function implementation for consistent call overhead</span>


<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
            <span class="k">using</span> <span class="n">Decay</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="o">&gt;</span>
            <span class="k">struct</span> <span class="nc">is_related</span>
                <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">Decay</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Decay</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&gt;</span> <span class="p">{};</span>

            <span class="c1">/// We need to reinvent std::function because every piece of code that might add overhead</span>
            <span class="c1">/// in a measurement context needs to have consistent performance characteristics so that we</span>
            <span class="c1">/// can account for it in the measurement.</span>
            <span class="c1">/// Implementations of std::function with optimizations that aren&#39;t always applicable, like</span>
            <span class="c1">/// small buffer optimizations, are not uncommon.</span>
            <span class="c1">/// This is effectively an implementation of std::function without any such optimizations;</span>
            <span class="c1">/// it may be slow, but it is consistently slow.</span>
            <span class="k">struct</span> <span class="nc">BenchmarkFunction</span> <span class="p">{</span>
            <span class="k">private</span><span class="o">:</span>
                <span class="k">struct</span> <span class="nc">callable</span> <span class="p">{</span>
                    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">call</span><span class="p">(</span><span class="n">Chronometer</span> <span class="n">meter</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="k">virtual</span> <span class="n">callable</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="k">virtual</span> <span class="o">~</span><span class="n">callable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
                <span class="p">};</span>
                <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
                <span class="k">struct</span> <span class="nc">model</span> <span class="o">:</span> <span class="k">public</span> <span class="n">callable</span> <span class="p">{</span>
                    <span class="n">model</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">)</span> <span class="o">:</span> <span class="n">fun</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">fun</span><span class="p">))</span> <span class="p">{}</span>
                    <span class="n">model</span><span class="p">(</span><span class="n">Fun</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">fun</span><span class="p">)</span> <span class="o">:</span> <span class="n">fun</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span> <span class="p">{}</span>

                    <span class="n">model</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">model</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>

                    <span class="kt">void</span> <span class="n">call</span><span class="p">(</span><span class="n">Chronometer</span> <span class="n">meter</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                        <span class="n">call</span><span class="p">(</span><span class="n">meter</span><span class="p">,</span> <span class="n">is_callable</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">(</span><span class="n">Chronometer</span><span class="p">)</span><span class="o">&gt;</span><span class="p">());</span>
                    <span class="p">}</span>
                    <span class="kt">void</span> <span class="n">call</span><span class="p">(</span><span class="n">Chronometer</span> <span class="n">meter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                        <span class="n">fun</span><span class="p">(</span><span class="n">meter</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="kt">void</span> <span class="n">call</span><span class="p">(</span><span class="n">Chronometer</span> <span class="n">meter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                        <span class="n">meter</span><span class="p">.</span><span class="n">measure</span><span class="p">(</span><span class="n">fun</span><span class="p">);</span>
                    <span class="p">}</span>

                    <span class="n">Fun</span> <span class="n">fun</span><span class="p">;</span>
                <span class="p">};</span>

                <span class="k">struct</span> <span class="nc">do_nothing</span> <span class="p">{</span> <span class="kt">void</span> <span class="nf">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{}</span> <span class="p">};</span>

                <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
                <span class="n">BenchmarkFunction</span><span class="p">(</span><span class="n">model</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>

            <span class="k">public</span><span class="o">:</span>
                <span class="n">BenchmarkFunction</span><span class="p">()</span>
                    <span class="o">:</span> <span class="n">f</span><span class="p">(</span><span class="k">new</span> <span class="n">model</span><span class="o">&lt;</span><span class="n">do_nothing</span><span class="o">&gt;</span><span class="p">{</span> <span class="p">{}</span> <span class="p">})</span> <span class="p">{}</span>

                <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="p">,</span>
                    <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">is_related</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">,</span> <span class="n">BenchmarkFunction</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
                    <span class="n">BenchmarkFunction</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">)</span>
                    <span class="o">:</span> <span class="n">f</span><span class="p">(</span><span class="k">new</span> <span class="n">model</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">)))</span> <span class="p">{}</span>

                <span class="n">BenchmarkFunction</span><span class="p">(</span><span class="n">BenchmarkFunction</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span>
                    <span class="o">:</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">f</span><span class="p">))</span> <span class="p">{}</span>

                <span class="n">BenchmarkFunction</span><span class="p">(</span><span class="n">BenchmarkFunction</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span>
                    <span class="o">:</span> <span class="n">f</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">())</span> <span class="p">{}</span>

                <span class="n">BenchmarkFunction</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">BenchmarkFunction</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">f</span><span class="p">);</span>
                    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">BenchmarkFunction</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">BenchmarkFunction</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">f</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">());</span>
                    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Chronometer</span> <span class="n">meter</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">call</span><span class="p">(</span><span class="n">meter</span><span class="p">);</span> <span class="p">}</span>

            <span class="k">private</span><span class="o">:</span>
                <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">callable</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>
            <span class="p">};</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_benchmark_function.hpp</span>
<span class="c1">// start catch_repeat.hpp</span>

<span class="c1">// repeat algorithm</span>


<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
            <span class="k">struct</span> <span class="nc">repeater</span> <span class="p">{</span>
                <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">fun</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">Fun</span> <span class="n">fun</span><span class="p">;</span>
            <span class="p">};</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
            <span class="n">repeater</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">repeat</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Fun</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span> <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_repeat.hpp</span>
<span class="c1">// start catch_run_for_at_least.hpp</span>

<span class="c1">// Run a function for a minimum amount of time</span>


<span class="c1">// start catch_measure.hpp</span>

<span class="c1">// Measure</span>


<span class="c1">// start catch_timing.hpp</span>

<span class="c1">// Timing</span>


<span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Result</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">Timing</span> <span class="p">{</span>
            <span class="n">Duration</span> <span class="n">elapsed</span><span class="p">;</span>
            <span class="n">Result</span> <span class="n">result</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">iterations</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Func</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
        <span class="k">using</span> <span class="n">TimingOf</span> <span class="o">=</span> <span class="n">Timing</span><span class="o">&lt;</span><span class="n">ClockDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Detail</span><span class="o">::</span><span class="n">CompleteType_t</span><span class="o">&lt;</span><span class="n">FunctionReturnType</span><span class="o">&lt;</span><span class="n">Func</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_timing.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Fun</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
            <span class="n">TimingOf</span><span class="o">&lt;</span><span class="n">Clock</span><span class="p">,</span> <span class="n">Fun</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">measure</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
                <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">complete_invoke</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
                <span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
                <span class="k">auto</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
                <span class="k">return</span> <span class="p">{</span> <span class="n">delta</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="mi">1</span> <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_measure.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
            <span class="n">TimingOf</span><span class="o">&lt;</span><span class="n">Clock</span><span class="p">,</span> <span class="n">Fun</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">measure_one</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iters</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">Detail</span><span class="o">::</span><span class="n">measure</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">iters</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
            <span class="n">TimingOf</span><span class="o">&lt;</span><span class="n">Clock</span><span class="p">,</span> <span class="n">Fun</span><span class="p">,</span> <span class="n">Chronometer</span><span class="o">&gt;</span> <span class="n">measure_one</span><span class="p">(</span><span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iters</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Detail</span><span class="o">::</span><span class="n">ChronometerModel</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span> <span class="n">meter</span><span class="p">;</span>
                <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">complete_invoke</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">Chronometer</span><span class="p">(</span><span class="n">meter</span><span class="p">,</span> <span class="n">iters</span><span class="p">));</span>

                <span class="k">return</span> <span class="p">{</span> <span class="n">meter</span><span class="p">.</span><span class="n">elapsed</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="n">iters</span> <span class="p">};</span>
            <span class="p">}</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
            <span class="k">using</span> <span class="n">run_for_at_least_argument_t</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="n">is_callable</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">(</span><span class="n">Chronometer</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">Chronometer</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

            <span class="k">struct</span> <span class="nc">optimized_away_error</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span>
                <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="s">&quot;could not measure benchmark, maybe it was optimized away&quot;</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">};</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Fun</span><span class="o">&gt;</span>
            <span class="n">TimingOf</span><span class="o">&lt;</span><span class="n">Clock</span><span class="p">,</span> <span class="n">Fun</span><span class="p">,</span> <span class="n">run_for_at_least_argument_t</span><span class="o">&lt;</span><span class="n">Clock</span><span class="p">,</span> <span class="n">Fun</span><span class="o">&gt;&gt;</span> <span class="n">run_for_at_least</span><span class="p">(</span><span class="n">ClockDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span> <span class="n">how_long</span><span class="p">,</span> <span class="kt">int</span> <span class="n">seed</span><span class="p">,</span> <span class="n">Fun</span><span class="o">&amp;&amp;</span> <span class="n">fun</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">iters</span> <span class="o">=</span> <span class="n">seed</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">iters</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">))</span> <span class="p">{</span>
                    <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">Timing</span> <span class="o">=</span> <span class="n">measure_one</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">iters</span><span class="p">,</span> <span class="n">is_callable</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">(</span><span class="n">Chronometer</span><span class="p">)</span><span class="o">&gt;</span><span class="p">());</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">Timing</span><span class="p">.</span><span class="n">elapsed</span> <span class="o">&gt;=</span> <span class="n">how_long</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="p">{</span> <span class="n">Timing</span><span class="p">.</span><span class="n">elapsed</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Timing</span><span class="p">.</span><span class="n">result</span><span class="p">),</span> <span class="n">iters</span> <span class="p">};</span>
                    <span class="p">}</span>
                    <span class="n">iters</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">Catch</span><span class="o">::</span><span class="n">throw_exception</span><span class="p">(</span><span class="n">optimized_away_error</span><span class="p">{});</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_run_for_at_least.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">ExecutionPlan</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">iterations_per_sample</span><span class="p">;</span>
            <span class="n">Duration</span> <span class="n">estimated_duration</span><span class="p">;</span>
            <span class="n">Detail</span><span class="o">::</span><span class="n">BenchmarkFunction</span> <span class="n">benchmark</span><span class="p">;</span>
            <span class="n">Duration</span> <span class="n">warmup_time</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">warmup_iterations</span><span class="p">;</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration2</span><span class="o">&gt;</span>
            <span class="k">operator</span> <span class="n">ExecutionPlan</span><span class="o">&lt;</span><span class="n">Duration2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">{</span> <span class="n">iterations_per_sample</span><span class="p">,</span> <span class="n">estimated_duration</span><span class="p">,</span> <span class="n">benchmark</span><span class="p">,</span> <span class="n">warmup_time</span><span class="p">,</span> <span class="n">warmup_iterations</span> <span class="p">};</span>
            <span class="p">}</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">run</span><span class="p">(</span><span class="k">const</span> <span class="n">IConfig</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">,</span> <span class="n">Environment</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">env</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                <span class="c1">// warmup a bit</span>
                <span class="n">Detail</span><span class="o">::</span><span class="n">run_for_at_least</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">ClockDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">warmup_time</span><span class="p">),</span> <span class="n">warmup_iterations</span><span class="p">,</span> <span class="n">Detail</span><span class="o">::</span><span class="n">repeat</span><span class="p">(</span><span class="n">now</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">{}));</span>

                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">times</span><span class="p">;</span>
                <span class="n">times</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">benchmarkSamples</span><span class="p">());</span>
                <span class="n">std</span><span class="o">::</span><span class="n">generate_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">cfg</span><span class="p">.</span><span class="n">benchmarkSamples</span><span class="p">(),</span> <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="n">env</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">Detail</span><span class="o">::</span><span class="n">ChronometerModel</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span> <span class="n">model</span><span class="p">;</span>
                    <span class="k">this</span><span class="o">-&gt;</span><span class="n">benchmark</span><span class="p">(</span><span class="n">Chronometer</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">iterations_per_sample</span><span class="p">));</span>
                    <span class="k">auto</span> <span class="n">sample_time</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">elapsed</span><span class="p">()</span> <span class="o">-</span> <span class="n">env</span><span class="p">.</span><span class="n">clock_cost</span><span class="p">.</span><span class="n">mean</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">sample_time</span> <span class="o">&lt;</span> <span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;::</span><span class="n">zero</span><span class="p">())</span> <span class="n">sample_time</span> <span class="o">=</span> <span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;::</span><span class="n">zero</span><span class="p">();</span>
                    <span class="k">return</span> <span class="n">sample_time</span> <span class="o">/</span> <span class="n">iterations_per_sample</span><span class="p">;</span>
                <span class="p">});</span>
                <span class="k">return</span> <span class="n">times</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_execution_plan.hpp</span>
<span class="c1">// start catch_estimate_clock.hpp</span>

 <span class="c1">// Environment measurement</span>


<span class="c1">// start catch_stats.hpp</span>

<span class="c1">// Statistical analysis tools</span>


<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="k">using</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>

            <span class="kt">double</span> <span class="nf">weighted_average_quantile</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">q</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">);</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Iterator</span><span class="o">&gt;</span>
            <span class="n">OutlierClassification</span> <span class="n">classify_outliers</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">copy</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>

                <span class="k">auto</span> <span class="n">q1</span> <span class="o">=</span> <span class="n">weighted_average_quantile</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">copy</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">copy</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                <span class="k">auto</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">weighted_average_quantile</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">copy</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">copy</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                <span class="k">auto</span> <span class="n">iqr</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">-</span> <span class="n">q1</span><span class="p">;</span>
                <span class="k">auto</span> <span class="n">los</span> <span class="o">=</span> <span class="n">q1</span> <span class="o">-</span> <span class="p">(</span><span class="n">iqr</span> <span class="o">*</span> <span class="mf">3.</span><span class="p">);</span>
                <span class="k">auto</span> <span class="n">lom</span> <span class="o">=</span> <span class="n">q1</span> <span class="o">-</span> <span class="p">(</span><span class="n">iqr</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">);</span>
                <span class="k">auto</span> <span class="n">him</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">+</span> <span class="p">(</span><span class="n">iqr</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">);</span>
                <span class="k">auto</span> <span class="n">his</span> <span class="o">=</span> <span class="n">q3</span> <span class="o">+</span> <span class="p">(</span><span class="n">iqr</span> <span class="o">*</span> <span class="mf">3.</span><span class="p">);</span>

                <span class="n">OutlierClassification</span> <span class="n">o</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">los</span><span class="p">)</span> <span class="o">++</span><span class="n">o</span><span class="p">.</span><span class="n">low_severe</span><span class="p">;</span>
                    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">lom</span><span class="p">)</span> <span class="o">++</span><span class="n">o</span><span class="p">.</span><span class="n">low_mild</span><span class="p">;</span>
                    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">his</span><span class="p">)</span> <span class="o">++</span><span class="n">o</span><span class="p">.</span><span class="n">high_severe</span><span class="p">;</span>
                    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">him</span><span class="p">)</span> <span class="o">++</span><span class="n">o</span><span class="p">.</span><span class="n">high_mild</span><span class="p">;</span>
                    <span class="o">++</span><span class="n">o</span><span class="p">.</span><span class="n">samples_seen</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Iterator</span><span class="o">&gt;</span>
            <span class="kt">double</span> <span class="n">mean</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">count</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
                <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mf">0.</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">sum</span> <span class="o">/</span> <span class="n">count</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">URng</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Estimator</span><span class="o">&gt;</span>
            <span class="n">sample</span> <span class="n">resample</span><span class="p">(</span><span class="n">URng</span><span class="o">&amp;</span> <span class="n">rng</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resamples</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Estimator</span><span class="o">&amp;</span> <span class="n">estimator</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
                <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

                <span class="n">sample</span> <span class="n">out</span><span class="p">;</span>
                <span class="n">out</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">resamples</span><span class="p">);</span>
                <span class="n">std</span><span class="o">::</span><span class="n">generate_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">resamples</span><span class="p">,</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">estimator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rng</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">resampled</span><span class="p">;</span>
                    <span class="n">resampled</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">generate_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">resampled</span><span class="p">),</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rng</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">first</span><span class="p">[</span><span class="n">dist</span><span class="p">(</span><span class="n">rng</span><span class="p">)];</span> <span class="p">});</span>
                    <span class="k">return</span> <span class="nf">estimator</span><span class="p">(</span><span class="n">resampled</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">resampled</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                <span class="p">});</span>
                <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">out</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Estimator</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Iterator</span><span class="o">&gt;</span>
            <span class="n">sample</span> <span class="n">jackknife</span><span class="p">(</span><span class="n">Estimator</span><span class="o">&amp;&amp;</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
                <span class="k">auto</span> <span class="n">second</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
                <span class="n">sample</span> <span class="n">results</span><span class="p">;</span>
                <span class="n">results</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>
                    <span class="n">results</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">estimator</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">last</span><span class="p">));</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="n">results</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kr">inline</span> <span class="kt">double</span> <span class="n">normal_cdf</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">erfc</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">double</span> <span class="n">erfc_inv</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">);</span>

            <span class="kt">double</span> <span class="nf">normal_quantile</span><span class="p">(</span><span class="kt">double</span> <span class="n">p</span><span class="p">);</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Estimator</span><span class="o">&gt;</span>
            <span class="n">Estimate</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">bootstrap</span><span class="p">(</span><span class="kt">double</span> <span class="n">confidence_level</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">sample</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">resample</span><span class="p">,</span> <span class="n">Estimator</span><span class="o">&amp;&amp;</span> <span class="n">estimator</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>

                <span class="kt">double</span> <span class="n">point</span> <span class="o">=</span> <span class="n">estimator</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
                <span class="c1">// Degenerate case with a single sample</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="n">point</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">confidence_level</span> <span class="p">};</span>

                <span class="n">sample</span> <span class="n">jack</span> <span class="o">=</span> <span class="n">jackknife</span><span class="p">(</span><span class="n">estimator</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
                <span class="kt">double</span> <span class="n">jack_mean</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">jack</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">jack</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                <span class="kt">double</span> <span class="n">sum_squares</span><span class="p">,</span> <span class="n">sum_cubes</span><span class="p">;</span>
                <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">sum_squares</span><span class="p">,</span> <span class="n">sum_cubes</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">jack</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">jack</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">[</span><span class="n">jack_mean</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">sqcb</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">jack_mean</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
                    <span class="k">auto</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
                    <span class="k">auto</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">d2</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
                    <span class="k">return</span> <span class="p">{</span> <span class="n">sqcb</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="n">d2</span><span class="p">,</span> <span class="n">sqcb</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="n">d3</span> <span class="p">};</span>
                <span class="p">});</span>

                <span class="kt">double</span> <span class="n">accel</span> <span class="o">=</span> <span class="n">sum_cubes</span> <span class="o">/</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">sum_squares</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">));</span>
                <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">resample</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
                <span class="kt">double</span> <span class="n">prob_n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">count_if</span><span class="p">(</span><span class="n">resample</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">resample</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="n">point</span><span class="p">](</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">point</span><span class="p">;</span> <span class="p">})</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
                <span class="c1">// degenerate case with uniform samples</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">prob_n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="n">point</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">confidence_level</span> <span class="p">};</span>

                <span class="kt">double</span> <span class="n">bias</span> <span class="o">=</span> <span class="n">normal_quantile</span><span class="p">(</span><span class="n">prob_n</span><span class="p">);</span>
                <span class="kt">double</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">normal_quantile</span><span class="p">((</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">confidence_level</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">);</span>

                <span class="k">auto</span> <span class="n">cumn</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">](</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">lround</span><span class="p">(</span><span class="n">normal_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span> <span class="p">};</span>
                <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">bias</span><span class="p">,</span> <span class="n">accel</span><span class="p">](</span><span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bias</span> <span class="o">+</span> <span class="n">b</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">accel</span> <span class="o">*</span> <span class="n">b</span><span class="p">);</span> <span class="p">};</span>
                <span class="kt">double</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">bias</span> <span class="o">+</span> <span class="n">z1</span><span class="p">;</span>
                <span class="kt">double</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">bias</span> <span class="o">-</span> <span class="n">z1</span><span class="p">;</span>
                <span class="kt">double</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span>
                <span class="kt">double</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">b2</span><span class="p">);</span>
                <span class="k">auto</span> <span class="n">lo</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">)(</span><span class="n">cumn</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
                <span class="k">auto</span> <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">)(</span><span class="n">cumn</span><span class="p">(</span><span class="n">a2</span><span class="p">),</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

                <span class="k">return</span> <span class="p">{</span> <span class="n">point</span><span class="p">,</span> <span class="n">resample</span><span class="p">[</span><span class="n">lo</span><span class="p">],</span> <span class="n">resample</span><span class="p">[</span><span class="n">hi</span><span class="p">],</span> <span class="n">confidence_level</span> <span class="p">};</span>
            <span class="p">}</span>

            <span class="kt">double</span> <span class="n">outlier_variance</span><span class="p">(</span><span class="n">Estimate</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">mean</span><span class="p">,</span> <span class="n">Estimate</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">stddev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

            <span class="k">struct</span> <span class="nc">bootstrap_analysis</span> <span class="p">{</span>
                <span class="n">Estimate</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">mean</span><span class="p">;</span>
                <span class="n">Estimate</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">standard_deviation</span><span class="p">;</span>
                <span class="kt">double</span> <span class="n">outlier_variance</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">bootstrap_analysis</span> <span class="nf">analyse_samples</span><span class="p">(</span><span class="kt">double</span> <span class="n">confidence_level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_resamples</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">);</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_stats.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">resolution</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TimePoint</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">times</span><span class="p">;</span>
                <span class="n">times</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">std</span><span class="o">::</span><span class="n">generate_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">now</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">{});</span>

                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">deltas</span><span class="p">;</span>
                <span class="n">deltas</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
                <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">times</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span> <span class="n">times</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">times</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">deltas</span><span class="p">),</span>
                    <span class="p">[](</span><span class="n">TimePoint</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">TimePoint</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">).</span><span class="n">count</span><span class="p">());</span> <span class="p">});</span>

                <span class="k">return</span> <span class="n">deltas</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">const</span> <span class="k">auto</span> <span class="n">warmup_iterations</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">warmup_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">minimum_ticks</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">warmup_seed</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">clock_resolution_estimation_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">clock_cost_estimation_time_limit</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">clock_cost_estimation_tick_limit</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">clock_cost_estimation_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">clock_cost_estimation_iterations</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
            <span class="kt">int</span> <span class="n">warmup</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">run_for_at_least</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">ClockDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">warmup_time</span><span class="p">),</span> <span class="n">warmup_seed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resolution</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">)</span>
                    <span class="p">.</span><span class="n">iterations</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
            <span class="n">EnvironmentEstimate</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">estimate_clock_resolution</span><span class="p">(</span><span class="kt">int</span> <span class="n">iterations</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">run_for_at_least</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">ClockDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">clock_resolution_estimation_time</span><span class="p">),</span> <span class="n">iterations</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resolution</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">)</span>
                    <span class="p">.</span><span class="n">result</span><span class="p">;</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">r</span><span class="p">.</span><span class="n">end</span><span class="p">())),</span>
                    <span class="n">classify_outliers</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">r</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span>
                <span class="p">};</span>
            <span class="p">}</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
            <span class="n">EnvironmentEstimate</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">estimate_clock_cost</span><span class="p">(</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span> <span class="n">resolution</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">time_limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">)(</span>
                    <span class="n">resolution</span> <span class="o">*</span> <span class="n">clock_cost_estimation_tick_limit</span><span class="p">,</span>
                    <span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">clock_cost_estimation_time_limit</span><span class="p">));</span>
                <span class="k">auto</span> <span class="n">time_clock</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">Detail</span><span class="o">::</span><span class="n">measure</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">([</span><span class="n">k</span><span class="p">]</span> <span class="p">{</span>
                        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                            <span class="k">volatile</span> <span class="k">auto</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
                            <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ignored</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}).</span><span class="n">elapsed</span><span class="p">;</span>
                <span class="p">};</span>
                <span class="n">time_clock</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">iters</span> <span class="o">=</span> <span class="n">clock_cost_estimation_iterations</span><span class="p">;</span>
                <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">run_for_at_least</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">ClockDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">clock_cost_estimation_time</span><span class="p">),</span> <span class="n">iters</span><span class="p">,</span> <span class="n">time_clock</span><span class="p">);</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">times</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">nsamples</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">time_limit</span> <span class="o">/</span> <span class="n">r</span><span class="p">.</span><span class="n">elapsed</span><span class="p">));</span>
                <span class="n">times</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">nsamples</span><span class="p">);</span>
                <span class="n">std</span><span class="o">::</span><span class="n">generate_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">nsamples</span><span class="p">,</span> <span class="p">[</span><span class="n">time_clock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">]</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">((</span><span class="n">time_clock</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">iterations</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span><span class="p">.</span><span class="n">iterations</span><span class="p">).</span><span class="n">count</span><span class="p">());</span>
                <span class="p">});</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">times</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">times</span><span class="p">.</span><span class="n">end</span><span class="p">())),</span>
                    <span class="n">classify_outliers</span><span class="p">(</span><span class="n">times</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">times</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span>
                <span class="p">};</span>
            <span class="p">}</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
            <span class="n">Environment</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">measure_environment</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">static</span> <span class="n">Environment</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;*</span> <span class="n">env</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">*</span><span class="n">env</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">auto</span> <span class="n">iters</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">warmup</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">();</span>
                <span class="k">auto</span> <span class="n">resolution</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">estimate_clock_resolution</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iters</span><span class="p">);</span>
                <span class="k">auto</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">estimate_clock_cost</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">resolution</span><span class="p">.</span><span class="n">mean</span><span class="p">);</span>

                <span class="n">env</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Environment</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span><span class="p">{</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">cost</span> <span class="p">};</span>
                <span class="k">return</span> <span class="o">*</span><span class="n">env</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_estimate_clock.hpp</span>
<span class="c1">// start catch_analyse.hpp</span>

 <span class="c1">// Run and analyse one benchmark</span>


<span class="c1">// start catch_sample_analysis.hpp</span>

<span class="c1">// Benchmark results</span>


<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration</span><span class="o">&gt;</span>
        <span class="k">struct</span> <span class="nc">SampleAnalysis</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">;</span>
            <span class="n">Estimate</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">mean</span><span class="p">;</span>
            <span class="n">Estimate</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">standard_deviation</span><span class="p">;</span>
            <span class="n">OutlierClassification</span> <span class="n">outliers</span><span class="p">;</span>
            <span class="kt">double</span> <span class="n">outlier_variance</span><span class="p">;</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration2</span><span class="o">&gt;</span>
            <span class="k">operator</span> <span class="n">SampleAnalysis</span><span class="o">&lt;</span><span class="n">Duration2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Duration2</span><span class="o">&gt;</span> <span class="n">samples2</span><span class="p">;</span>
                <span class="n">samples2</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
                <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">samples</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">samples2</span><span class="p">),</span> <span class="p">[](</span><span class="n">Duration</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Duration2</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="p">});</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">samples2</span><span class="p">),</span>
                    <span class="n">mean</span><span class="p">,</span>
                    <span class="n">standard_deviation</span><span class="p">,</span>
                    <span class="n">outliers</span><span class="p">,</span>
                    <span class="n">outlier_variance</span><span class="p">,</span>
                <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_sample_analysis.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Duration</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Iterator</span><span class="o">&gt;</span>
            <span class="n">SampleAnalysis</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">analyse</span><span class="p">(</span><span class="k">const</span> <span class="n">IConfig</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">,</span> <span class="n">Environment</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">.</span><span class="n">benchmarkNoAnalysis</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">;</span>
                    <span class="n">samples</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">);</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="p">[](</span><span class="n">Duration</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">count</span><span class="p">();</span> <span class="p">});</span>

                    <span class="k">auto</span> <span class="n">analysis</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Benchmark</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">analyse_samples</span><span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">benchmarkConfidenceInterval</span><span class="p">(),</span> <span class="n">cfg</span><span class="p">.</span><span class="n">benchmarkResamples</span><span class="p">(),</span> <span class="n">samples</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">samples</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                    <span class="k">auto</span> <span class="n">outliers</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Benchmark</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">classify_outliers</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">samples</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

                    <span class="k">auto</span> <span class="n">wrap_estimate</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Estimate</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="n">Estimate</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="p">{</span>
                            <span class="n">Duration</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">point</span><span class="p">),</span>
                                <span class="n">Duration</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">),</span>
                                <span class="n">Duration</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">),</span>
                                <span class="n">e</span><span class="p">.</span><span class="n">confidence_interval</span><span class="p">,</span>
                        <span class="p">};</span>
                    <span class="p">};</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">samples2</span><span class="p">;</span>
                    <span class="n">samples2</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">samples</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">samples2</span><span class="p">),</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Duration</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="p">});</span>
                    <span class="k">return</span> <span class="p">{</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">samples2</span><span class="p">),</span>
                        <span class="n">wrap_estimate</span><span class="p">(</span><span class="n">analysis</span><span class="p">.</span><span class="n">mean</span><span class="p">),</span>
                        <span class="n">wrap_estimate</span><span class="p">(</span><span class="n">analysis</span><span class="p">.</span><span class="n">standard_deviation</span><span class="p">),</span>
                        <span class="n">outliers</span><span class="p">,</span>
                        <span class="n">analysis</span><span class="p">.</span><span class="n">outlier_variance</span><span class="p">,</span>
                    <span class="p">};</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">;</span>
                    <span class="n">samples</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">);</span>

                    <span class="n">Duration</span> <span class="n">mean</span> <span class="o">=</span> <span class="n">Duration</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">,</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">samples</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">));</span>
                        <span class="n">mean</span> <span class="o">+=</span> <span class="n">Duration</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="n">mean</span> <span class="o">/=</span> <span class="n">i</span><span class="p">;</span>

                    <span class="k">return</span> <span class="p">{</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span>
                        <span class="n">Estimate</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span><span class="p">{</span><span class="n">mean</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">},</span>
                        <span class="n">Estimate</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span><span class="p">{</span><span class="n">Duration</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Duration</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Duration</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">},</span>
                        <span class="n">OutlierClassification</span><span class="p">{},</span>
                        <span class="mf">0.0</span>
                    <span class="p">};</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_analyse.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">Benchmark</span> <span class="p">{</span>
            <span class="n">Benchmark</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;&amp;</span><span class="n">name</span><span class="p">)</span>
                <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{}</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">FUN</span><span class="o">&gt;</span>
            <span class="n">Benchmark</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">FUN</span> <span class="o">&amp;&amp;</span><span class="n">func</span><span class="p">)</span>
                <span class="o">:</span> <span class="n">fun</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">func</span><span class="p">)),</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{}</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="o">&gt;</span>
            <span class="n">ExecutionPlan</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">prepare</span><span class="p">(</span><span class="k">const</span> <span class="n">IConfig</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">,</span> <span class="n">Environment</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">env</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">min_time</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="n">clock_resolution</span><span class="p">.</span><span class="n">mean</span> <span class="o">*</span> <span class="n">Detail</span><span class="o">::</span><span class="n">minimum_ticks</span><span class="p">;</span>
                <span class="k">auto</span> <span class="n">run_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">min_time</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">min_time</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">benchmarkWarmupTime</span><span class="p">()));</span>
                <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">test</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">run_for_at_least</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">ClockDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">run_time</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fun</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">new_iters</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_time</span> <span class="o">*</span> <span class="n">test</span><span class="p">.</span><span class="n">iterations</span> <span class="o">/</span> <span class="n">test</span><span class="p">.</span><span class="n">elapsed</span><span class="p">));</span>
                <span class="k">return</span> <span class="p">{</span> <span class="n">new_iters</span><span class="p">,</span> <span class="n">test</span><span class="p">.</span><span class="n">elapsed</span> <span class="o">/</span> <span class="n">test</span><span class="p">.</span><span class="n">iterations</span> <span class="o">*</span> <span class="n">new_iters</span> <span class="o">*</span> <span class="n">cfg</span><span class="p">.</span><span class="n">benchmarkSamples</span><span class="p">(),</span> <span class="n">fun</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">benchmarkWarmupTime</span><span class="p">()),</span> <span class="n">Detail</span><span class="o">::</span><span class="n">warmup_iterations</span> <span class="p">};</span>
            <span class="p">}</span>

            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span> <span class="o">=</span> <span class="n">default_clock</span><span class="o">&gt;</span>
            <span class="kt">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">IConfigPtr</span> <span class="n">cfg</span> <span class="o">=</span> <span class="n">getCurrentContext</span><span class="p">().</span><span class="n">getConfig</span><span class="p">();</span>

                <span class="k">auto</span> <span class="n">env</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">measure_environment</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">();</span>

                <span class="n">getResultCapture</span><span class="p">().</span><span class="n">benchmarkPreparing</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
                <span class="n">CATCH_TRY</span><span class="p">{</span>
                    <span class="k">auto</span> <span class="n">plan</span> <span class="o">=</span> <span class="n">user_code</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="n">prepare</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
                    <span class="p">});</span>

                    <span class="n">BenchmarkInfo</span> <span class="n">info</span> <span class="p">{</span>
                        <span class="n">name</span><span class="p">,</span>
                        <span class="n">plan</span><span class="p">.</span><span class="n">estimated_duration</span><span class="p">.</span><span class="n">count</span><span class="p">(),</span>
                        <span class="n">plan</span><span class="p">.</span><span class="n">iterations_per_sample</span><span class="p">,</span>
                        <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">benchmarkSamples</span><span class="p">(),</span>
                        <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">benchmarkResamples</span><span class="p">(),</span>
                        <span class="n">env</span><span class="p">.</span><span class="n">clock_resolution</span><span class="p">.</span><span class="n">mean</span><span class="p">.</span><span class="n">count</span><span class="p">(),</span>
                        <span class="n">env</span><span class="p">.</span><span class="n">clock_cost</span><span class="p">.</span><span class="n">mean</span><span class="p">.</span><span class="n">count</span><span class="p">()</span>
                    <span class="p">};</span>

                    <span class="n">getResultCapture</span><span class="p">().</span><span class="n">benchmarkStarting</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

                    <span class="k">auto</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">user_code</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="n">plan</span><span class="p">.</span><span class="k">template</span> <span class="n">run</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
                    <span class="p">});</span>

                    <span class="k">auto</span> <span class="n">analysis</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">analyse</span><span class="p">(</span><span class="o">*</span><span class="n">cfg</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">samples</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">samples</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                    <span class="n">BenchmarkStats</span><span class="o">&lt;</span><span class="n">FloatDuration</span><span class="o">&lt;</span><span class="n">Clock</span><span class="o">&gt;&gt;</span> <span class="n">stats</span><span class="p">{</span> <span class="n">info</span><span class="p">,</span> <span class="n">analysis</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">analysis</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">analysis</span><span class="p">.</span><span class="n">standard_deviation</span><span class="p">,</span> <span class="n">analysis</span><span class="p">.</span><span class="n">outliers</span><span class="p">,</span> <span class="n">analysis</span><span class="p">.</span><span class="n">outlier_variance</span> <span class="p">};</span>
                    <span class="n">getResultCapture</span><span class="p">().</span><span class="n">benchmarkEnded</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>

                <span class="p">}</span> <span class="n">CATCH_CATCH_ALL</span><span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">translateActiveException</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">benchmarkErrorMsg</span><span class="p">)</span> <span class="c1">// benchmark errors have been reported, otherwise rethrow.</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// sets lambda to be used in fun *and* executes benchmark!</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fun</span><span class="p">,</span>
                <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">Detail</span><span class="o">::</span><span class="n">is_related</span><span class="o">&lt;</span><span class="n">Fun</span><span class="p">,</span> <span class="n">Benchmark</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&gt;</span>
                <span class="n">Benchmark</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Fun</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fun</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">BenchmarkFunction</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
                <span class="n">run</span><span class="p">();</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="k">private</span><span class="o">:</span>
            <span class="n">Detail</span><span class="o">::</span><span class="n">BenchmarkFunction</span> <span class="n">fun</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="cp">#define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1</span>
<span class="cp">#define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2</span>

<span class="cp">#define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\</span>
<span class="cp">    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \</span>
<span class="cp">        BenchmarkName = [&amp;](int benchmarkIndex)</span>

<span class="cp">#define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\</span>
<span class="cp">    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \</span>
<span class="cp">        BenchmarkName = [&amp;]</span>

<span class="c1">// end catch_benchmark.hpp</span>
<span class="c1">// start catch_constructor.hpp</span>

<span class="c1">// Constructor and destructor helpers</span>


<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">Destruct</span><span class="o">&gt;</span>
            <span class="k">struct</span> <span class="nc">ObjectStorage</span>
            <span class="p">{</span>
                <span class="k">using</span> <span class="n">TStorage</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">alignment_of</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

                <span class="n">ObjectStorage</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">()</span> <span class="p">{}</span>

                <span class="n">ObjectStorage</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjectStorage</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="n">T</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">stored_object</span><span class="p">());</span>
                <span class="p">}</span>

                <span class="n">ObjectStorage</span><span class="p">(</span><span class="n">ObjectStorage</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">stored_object</span><span class="p">()));</span>
                <span class="p">}</span>

                <span class="o">~</span><span class="n">ObjectStorage</span><span class="p">()</span> <span class="p">{</span> <span class="n">destruct_on_exit</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span> <span class="p">}</span>

                <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
                <span class="kt">void</span> <span class="n">construct</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
                <span class="p">}</span>

                <span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">AllowManualDestruction</span> <span class="o">=</span> <span class="o">!</span><span class="n">Destruct</span><span class="o">&gt;</span>
                <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">AllowManualDestruction</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">destruct</span><span class="p">()</span>
                <span class="p">{</span>
                    <span class="n">stored_object</span><span class="p">().</span><span class="o">~</span><span class="n">T</span><span class="p">();</span>
                <span class="p">}</span>

            <span class="k">private</span><span class="o">:</span>
                <span class="c1">// If this is a constructor benchmark, destruct the underlying object</span>
                <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="o">&gt;</span>
                <span class="kt">void</span> <span class="n">destruct_on_exit</span><span class="p">(</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">Destruct</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">destruct</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">();</span> <span class="p">}</span>
                <span class="c1">// Otherwise, don&#39;t</span>
                <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="o">&gt;</span>
                <span class="kt">void</span> <span class="n">destruct_on_exit</span><span class="p">(</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">Destruct</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

                <span class="n">T</span><span class="o">&amp;</span> <span class="n">stored_object</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">));</span>
                <span class="p">}</span>

                <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stored_object</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">));</span>
                <span class="p">}</span>

                <span class="n">TStorage</span> <span class="n">data</span><span class="p">;</span>
            <span class="p">};</span>
        <span class="p">}</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">using</span> <span class="n">storage_for</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">ObjectStorage</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">using</span> <span class="n">destructable_object</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">ObjectStorage</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// end catch_constructor.hpp</span>
<span class="c1">// end catch_benchmarking_all.hpp</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="c1">// ! CATCH_CONFIG_IMPL_ONLY</span>

<span class="cp">#ifdef CATCH_IMPL</span>
<span class="c1">// start catch_impl.hpp</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic push</span>
<span class="cp">#pragma clang diagnostic ignored &quot;-Wweak-vtables&quot;</span>
<span class="cp">#endif</span>

<span class="c1">// Keep these here for external reporters</span>
<span class="c1">// start catch_test_case_tracker.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">TestCaseTracking</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">NameAndLocation</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">SourceLineInfo</span> <span class="n">location</span><span class="p">;</span>

        <span class="n">NameAndLocation</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_location</span> <span class="p">);</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">name</span>
                <span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">.</span><span class="n">location</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">location</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">ITracker</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">ITrackerPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ITracker</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">class</span>  <span class="nc">ITracker</span> <span class="p">{</span>
        <span class="n">NameAndLocation</span> <span class="n">m_nameAndLocation</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">ITracker</span><span class="p">(</span><span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLoc</span><span class="p">)</span> <span class="o">:</span>
            <span class="n">m_nameAndLocation</span><span class="p">(</span><span class="n">nameAndLoc</span><span class="p">)</span>
        <span class="p">{}</span>

        <span class="c1">// static queries</span>
        <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_nameAndLocation</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">virtual</span> <span class="o">~</span><span class="n">ITracker</span><span class="p">();</span>

        <span class="c1">// dynamic queries</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isComplete</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Successfully completed or failed</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isSuccessfullyCompleted</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isOpen</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Started but not complete</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">hasChildren</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">hasStarted</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="n">ITracker</span><span class="o">&amp;</span> <span class="n">parent</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// actions</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">close</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Successfully complete</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fail</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">markAsNeedingAnotherRun</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">addChild</span><span class="p">(</span> <span class="n">ITrackerPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">ITrackerPtr</span> <span class="n">findChild</span><span class="p">(</span> <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">openChild</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// Debug/ checking</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isSectionTracker</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isGeneratorTracker</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">TrackerContext</span> <span class="p">{</span>

        <span class="k">enum</span> <span class="nc">RunState</span> <span class="p">{</span>
            <span class="n">NotStarted</span><span class="p">,</span>
            <span class="n">Executing</span><span class="p">,</span>
            <span class="n">CompletedCycle</span>
        <span class="p">};</span>

        <span class="n">ITrackerPtr</span> <span class="n">m_rootTracker</span><span class="p">;</span>
        <span class="n">ITracker</span><span class="o">*</span> <span class="n">m_currentTracker</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">RunState</span> <span class="n">m_runState</span> <span class="o">=</span> <span class="n">NotStarted</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>

        <span class="n">ITracker</span><span class="o">&amp;</span> <span class="n">startRun</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">endRun</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">startCycle</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">completeCycle</span><span class="p">();</span>

        <span class="kt">bool</span> <span class="nf">completedCycle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">ITracker</span><span class="o">&amp;</span> <span class="nf">currentTracker</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">setCurrentTracker</span><span class="p">(</span> <span class="n">ITracker</span><span class="o">*</span> <span class="n">tracker</span> <span class="p">);</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">TrackerBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ITracker</span> <span class="p">{</span>
    <span class="k">protected</span><span class="o">:</span>
        <span class="k">enum</span> <span class="nc">CycleState</span> <span class="p">{</span>
            <span class="n">NotStarted</span><span class="p">,</span>
            <span class="n">Executing</span><span class="p">,</span>
            <span class="n">ExecutingChildren</span><span class="p">,</span>
            <span class="n">NeedsAnotherRun</span><span class="p">,</span>
            <span class="n">CompletedSuccessfully</span><span class="p">,</span>
            <span class="n">Failed</span>
        <span class="p">};</span>

        <span class="k">using</span> <span class="n">Children</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ITrackerPtr</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="n">TrackerContext</span><span class="o">&amp;</span> <span class="n">m_ctx</span><span class="p">;</span>
        <span class="n">ITracker</span><span class="o">*</span> <span class="n">m_parent</span><span class="p">;</span>
        <span class="n">Children</span> <span class="n">m_children</span><span class="p">;</span>
        <span class="n">CycleState</span> <span class="n">m_runState</span> <span class="o">=</span> <span class="n">NotStarted</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">TrackerBase</span><span class="p">(</span> <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span><span class="p">,</span> <span class="n">TrackerContext</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ITracker</span><span class="o">*</span> <span class="n">parent</span> <span class="p">);</span>

        <span class="kt">bool</span> <span class="nf">isComplete</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">isSuccessfullyCompleted</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">isOpen</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">hasChildren</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">hasStarted</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_runState</span> <span class="o">!=</span> <span class="n">NotStarted</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">addChild</span><span class="p">(</span> <span class="n">ITrackerPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="n">ITrackerPtr</span> <span class="nf">findChild</span><span class="p">(</span> <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">ITracker</span><span class="o">&amp;</span> <span class="nf">parent</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">openChild</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">isSectionTracker</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">isGeneratorTracker</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">open</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">close</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">fail</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">markAsNeedingAnotherRun</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">moveToParent</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">moveToThis</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">SectionTracker</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TrackerBase</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m_filters</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_trimmed_name</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">SectionTracker</span><span class="p">(</span> <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span><span class="p">,</span> <span class="n">TrackerContext</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ITracker</span><span class="o">*</span> <span class="n">parent</span> <span class="p">);</span>

        <span class="kt">bool</span> <span class="nf">isSectionTracker</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">isComplete</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="k">static</span> <span class="n">SectionTracker</span><span class="o">&amp;</span> <span class="n">acquire</span><span class="p">(</span> <span class="n">TrackerContext</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span> <span class="p">);</span>

        <span class="kt">void</span> <span class="nf">tryOpen</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">addInitialFilters</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filters</span> <span class="p">);</span>
        <span class="kt">void</span> <span class="nf">addNextFilters</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filters</span> <span class="p">);</span>
        <span class="c1">//! Returns filters active in this tracker</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getFilters</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="c1">//! Returns whitespace-trimmed name of the tracked section</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">trimmedName</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace TestCaseTracking</span>

<span class="k">using</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">ITracker</span><span class="p">;</span>
<span class="k">using</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">TrackerContext</span><span class="p">;</span>
<span class="k">using</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">SectionTracker</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_test_case_tracker.h</span>

<span class="c1">// start catch_leak_detector.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">LeakDetector</span> <span class="p">{</span>
        <span class="n">LeakDetector</span><span class="p">();</span>
        <span class="o">~</span><span class="n">LeakDetector</span><span class="p">();</span>
    <span class="p">};</span>

<span class="p">}</span>
<span class="c1">// end catch_leak_detector.h</span>
<span class="c1">// Cpp files will be included in the single-header file here</span>
<span class="c1">// start catch_stats.cpp</span>

<span class="c1">// Statistical analysis tools</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>

<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp"></span>

<span class="cp">#if defined(CATCH_CONFIG_USE_ASYNC)</span>
<span class="cp">#include</span> <span class="cpf">&lt;future&gt;</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="nf">erf_inv</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Code accompanying the article &quot;Approximating the erfinv function&quot; in GPU Computing Gems, Volume 2</span>
        <span class="kt">double</span> <span class="n">w</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>

        <span class="n">w</span> <span class="o">=</span> <span class="o">-</span><span class="n">log</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">x</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mf">6.250000</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">-</span> <span class="mf">3.125000</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-3.6444120640178196996e-21</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-1.685059138182016589e-19</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.2858480715256400167e-18</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.115787767802518096e-17</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-1.333171662854620906e-16</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">2.0972767875968561637e-17</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">6.6376381343583238325e-15</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-4.0545662729752068639e-14</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-8.1519341976054721522e-14</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">2.6335093153082322977e-12</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-1.2975133253453532498e-11</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-5.4154120542946279317e-11</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.051212273321532285e-09</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-4.1126339803469836976e-09</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-2.9070369957882005086e-08</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">4.2347877827932403518e-07</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-1.3654692000834678645e-06</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-1.3882523362786468719e-05</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">0.0001867342080340571352</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-0.00074070253416626697512</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-0.0060336708714301490533</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">0.24015818242558961693</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.6536545626831027356</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mf">16.000000</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">3.250000</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">2.2137376921775787049e-09</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">9.0756561938885390979e-08</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-2.7517406297064545428e-07</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.8239629214389227755e-08</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.5027403968909827627e-06</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-4.013867526981545969e-06</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">2.9234449089955446044e-06</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.2475304481671778723e-05</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-4.7318229009055733981e-05</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">6.8284851459573175448e-05</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">2.4031110387097893999e-05</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-0.0003550375203628474796</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">0.00095328937973738049703</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-0.0016882755560235047313</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">0.0024914420961078508066</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-0.0037512085075692412107</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">0.005370914553590063617</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.0052589676941592334</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">3.0838856104922207635</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">5.000000</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-2.7109920616438573243e-11</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-2.5556418169965252055e-10</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.5076572693500548083e-09</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-3.7894654401267369937e-09</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">7.6157012080783393804e-09</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-1.4960026627149240478e-08</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">2.9147953450901080826e-08</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-6.7711997758452339498e-08</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">2.2900482228026654717e-07</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-9.9298272942317002539e-07</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">4.5260625972231537039e-06</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-1.9681778105531670567e-05</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">7.5995277030017761139e-05</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-0.00021503011930044477347</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">-0.00013871931833623122026</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.0103004648645343977</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">4.8499064014085844221</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">p</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">double</span> <span class="nf">standard_deviation</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Benchmark</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">mean</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">variance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="p">[</span><span class="n">m</span><span class="p">](</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">m</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">diff</span><span class="p">;</span>
            <span class="p">})</span> <span class="o">/</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Benchmark</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>

            <span class="kt">double</span> <span class="nf">weighted_average_quantile</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">q</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">count</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
                <span class="kt">double</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
                <span class="kt">double</span> <span class="n">g</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">j</span><span class="p">;</span>
                <span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">first</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
                <span class="k">auto</span> <span class="n">xj</span> <span class="o">=</span> <span class="n">first</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">xj</span><span class="p">;</span>

                <span class="k">auto</span> <span class="n">xj1</span> <span class="o">=</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">last</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">xj</span> <span class="o">+</span> <span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">xj1</span> <span class="o">-</span> <span class="n">xj</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="kt">double</span> <span class="nf">erfc_inv</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">erf_inv</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="kt">double</span> <span class="nf">normal_quantile</span><span class="p">(</span><span class="kt">double</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">static</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">ROOT_TWO</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span>

                <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">erfc_inv</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">p</span><span class="p">);</span>
                <span class="c1">// result *= normal distribution standard deviation (1.0) * sqrt(2)</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="cm">/*sd * */</span> <span class="n">ROOT_TWO</span><span class="p">;</span>
                <span class="c1">// result += normal disttribution mean (0)</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">double</span> <span class="nf">outlier_variance</span><span class="p">(</span><span class="n">Estimate</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">mean</span><span class="p">,</span> <span class="n">Estimate</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">stddev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">double</span> <span class="n">sb</span> <span class="o">=</span> <span class="n">stddev</span><span class="p">.</span><span class="n">point</span><span class="p">;</span>
                <span class="kt">double</span> <span class="n">mn</span> <span class="o">=</span> <span class="n">mean</span><span class="p">.</span><span class="n">point</span> <span class="o">/</span> <span class="n">n</span><span class="p">;</span>
                <span class="kt">double</span> <span class="n">mg_min</span> <span class="o">=</span> <span class="n">mn</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">;</span>
                <span class="kt">double</span> <span class="n">sg</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">)(</span><span class="n">mg_min</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="n">sb</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
                <span class="kt">double</span> <span class="n">sg2</span> <span class="o">=</span> <span class="n">sg</span> <span class="o">*</span> <span class="n">sg</span><span class="p">;</span>
                <span class="kt">double</span> <span class="n">sb2</span> <span class="o">=</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">sb</span><span class="p">;</span>

                <span class="k">auto</span> <span class="n">c_max</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">sb2</span><span class="p">,</span> <span class="n">sg2</span><span class="p">](</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">double</span> <span class="p">{</span>
                    <span class="kt">double</span> <span class="n">k</span> <span class="o">=</span> <span class="n">mn</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
                    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
                    <span class="kt">double</span> <span class="n">nd</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
                    <span class="kt">double</span> <span class="n">k0</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span> <span class="o">*</span> <span class="n">nd</span><span class="p">;</span>
                    <span class="kt">double</span> <span class="n">k1</span> <span class="o">=</span> <span class="n">sb2</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">sg2</span> <span class="o">+</span> <span class="n">nd</span><span class="p">;</span>
                    <span class="kt">double</span> <span class="n">det</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">k1</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sg2</span> <span class="o">*</span> <span class="n">k0</span><span class="p">;</span>
                    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mf">-2.</span> <span class="o">*</span> <span class="n">k0</span> <span class="o">/</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">det</span><span class="p">)));</span>
                <span class="p">};</span>

                <span class="k">auto</span> <span class="n">var_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">sb2</span><span class="p">,</span> <span class="n">sg2</span><span class="p">](</span><span class="kt">double</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">double</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">nc</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sb2</span> <span class="o">-</span> <span class="n">nc</span> <span class="o">*</span> <span class="n">sg2</span><span class="p">);</span>
                <span class="p">};</span>

                <span class="k">return</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">)(</span><span class="n">var_out</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">var_out</span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">)(</span><span class="n">c_max</span><span class="p">(</span><span class="mf">0.</span><span class="p">),</span> <span class="n">c_max</span><span class="p">(</span><span class="n">mg_min</span><span class="p">))))</span> <span class="o">/</span> <span class="n">sb2</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">bootstrap_analysis</span> <span class="nf">analyse_samples</span><span class="p">(</span><span class="kt">double</span> <span class="n">confidence_level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n_resamples</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">CATCH_INTERNAL_START_WARNINGS_SUPPRESSION</span>
                <span class="n">CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS</span>
                <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">entropy</span><span class="p">;</span>
                <span class="n">CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION</span>

                <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">);</span> <span class="c1">// seriously, one can&#39;t use integral types without hell in C++</span>

                <span class="k">auto</span> <span class="n">mean</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Detail</span><span class="o">::</span><span class="n">mean</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span><span class="p">;</span>
                <span class="k">auto</span> <span class="n">stddev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">standard_deviation</span><span class="p">;</span>

<span class="cp">#if defined(CATCH_CONFIG_USE_ASYNC)</span>
                <span class="k">auto</span> <span class="n">Estimate</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">double</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">))</span> <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">();</span>
                    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">rng</span><span class="p">(</span><span class="n">seed</span><span class="p">);</span>
                        <span class="k">auto</span> <span class="n">resampled</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">n_resamples</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
                        <span class="k">return</span> <span class="n">bootstrap</span><span class="p">(</span><span class="n">confidence_level</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">resampled</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
                    <span class="p">});</span>
                <span class="p">};</span>

                <span class="k">auto</span> <span class="n">mean_future</span> <span class="o">=</span> <span class="n">Estimate</span><span class="p">(</span><span class="n">mean</span><span class="p">);</span>
                <span class="k">auto</span> <span class="n">stddev_future</span> <span class="o">=</span> <span class="n">Estimate</span><span class="p">(</span><span class="n">stddev</span><span class="p">);</span>

                <span class="k">auto</span> <span class="n">mean_estimate</span> <span class="o">=</span> <span class="n">mean_future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
                <span class="k">auto</span> <span class="n">stddev_estimate</span> <span class="o">=</span> <span class="n">stddev_future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="cp">#else</span>
                <span class="k">auto</span> <span class="n">Estimate</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">double</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">))</span> <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">();</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">rng</span><span class="p">(</span><span class="n">seed</span><span class="p">);</span>
                    <span class="k">auto</span> <span class="n">resampled</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">n_resamples</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
                    <span class="k">return</span> <span class="n">bootstrap</span><span class="p">(</span><span class="n">confidence_level</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">resampled</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
                <span class="p">};</span>

                <span class="k">auto</span> <span class="n">mean_estimate</span> <span class="o">=</span> <span class="n">Estimate</span><span class="p">(</span><span class="n">mean</span><span class="p">);</span>
                <span class="k">auto</span> <span class="n">stddev_estimate</span> <span class="o">=</span> <span class="n">Estimate</span><span class="p">(</span><span class="n">stddev</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// CATCH_USE_ASYNC</span>

                <span class="kt">double</span> <span class="n">outlier_variance</span> <span class="o">=</span> <span class="n">Detail</span><span class="o">::</span><span class="n">outlier_variance</span><span class="p">(</span><span class="n">mean_estimate</span><span class="p">,</span> <span class="n">stddev_estimate</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

                <span class="k">return</span> <span class="p">{</span> <span class="n">mean_estimate</span><span class="p">,</span> <span class="n">stddev_estimate</span><span class="p">,</span> <span class="n">outlier_variance</span> <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="c1">// namespace Detail</span>
    <span class="p">}</span> <span class="c1">// namespace Benchmark</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>
<span class="c1">// end catch_stats.cpp</span>
<span class="c1">// start catch_approx.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="p">{</span>

<span class="c1">// Performs equivalent check of std::fabs(lhs - rhs) &lt;= margin</span>
<span class="c1">// But without the subtraction to allow for INFINITY in comparison</span>
<span class="kt">bool</span> <span class="nf">marginComparison</span><span class="p">(</span><span class="kt">double</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">double</span> <span class="n">rhs</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">lhs</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&gt;=</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rhs</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&gt;=</span> <span class="n">lhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>

    <span class="n">Approx</span><span class="o">::</span><span class="n">Approx</span> <span class="p">(</span> <span class="kt">double</span> <span class="n">value</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_epsilon</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">epsilon</span><span class="p">()</span><span class="o">*</span><span class="mi">100</span> <span class="p">),</span>
        <span class="n">m_margin</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">),</span>
        <span class="n">m_scale</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">),</span>
        <span class="n">m_value</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">Approx</span> <span class="n">Approx</span><span class="o">::</span><span class="n">custom</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Approx</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Approx</span> <span class="n">Approx</span><span class="o">::</span><span class="k">operator</span><span class="o">-</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="nf">temp</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        <span class="n">temp</span><span class="p">.</span><span class="n">m_value</span> <span class="o">=</span> <span class="o">-</span><span class="n">temp</span><span class="p">.</span><span class="n">m_value</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Approx</span><span class="o">::</span><span class="n">toString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
        <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Approx( &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">m_value</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; )&quot;</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">Approx</span><span class="o">::</span><span class="n">equalityComparisonImpl</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// First try with fixed margin, then compute margin based on epsilon, scale and Approx&#39;s value</span>
        <span class="c1">// Thanks to Richard Harris for his help refining the scaled margin value</span>
        <span class="k">return</span> <span class="nf">marginComparison</span><span class="p">(</span><span class="n">m_value</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">m_margin</span><span class="p">)</span>
            <span class="o">||</span> <span class="n">marginComparison</span><span class="p">(</span><span class="n">m_value</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">m_epsilon</span> <span class="o">*</span> <span class="p">(</span><span class="n">m_scale</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isinf</span><span class="p">(</span><span class="n">m_value</span><span class="p">)</span><span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">m_value</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Approx</span><span class="o">::</span><span class="n">setMargin</span><span class="p">(</span><span class="kt">double</span> <span class="n">newMargin</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">CATCH_ENFORCE</span><span class="p">(</span><span class="n">newMargin</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s">&quot;Invalid Approx::margin: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">newMargin</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;.&#39;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; Approx::Margin has to be non-negative.&quot;</span><span class="p">);</span>
        <span class="n">m_margin</span> <span class="o">=</span> <span class="n">newMargin</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Approx</span><span class="o">::</span><span class="n">setEpsilon</span><span class="p">(</span><span class="kt">double</span> <span class="n">newEpsilon</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">CATCH_ENFORCE</span><span class="p">(</span><span class="n">newEpsilon</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">newEpsilon</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span>
            <span class="s">&quot;Invalid Approx::epsilon: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">newEpsilon</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;.&#39;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; Approx::epsilon has to be in [0, 1]&quot;</span><span class="p">);</span>
        <span class="n">m_epsilon</span> <span class="o">=</span> <span class="n">newEpsilon</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Detail</span>

<span class="k">namespace</span> <span class="n">literals</span> <span class="p">{</span>
    <span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span> <span class="k">operator</span> <span class="s">&quot;&quot;</span> <span class="n">_a</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span> <span class="k">operator</span> <span class="s">&quot;&quot;</span> <span class="n">_a</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// end namespace literals</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">toString</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_approx.cpp</span>
<span class="c1">// start catch_assertionhandler.cpp</span>

<span class="c1">// start catch_debugger.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">isDebuggerActive</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#ifdef CATCH_PLATFORM_MAC</span>

    <span class="cp">#if defined(__i386__) || defined(__x86_64__)</span>
        <span class="cp">#define CATCH_TRAP() __asm__(&quot;int $3\n&quot; : : ) </span><span class="cm">/* NOLINT */</span><span class="cp"></span>
    <span class="cp">#elif defined(__aarch64__)</span>
        <span class="cp">#define CATCH_TRAP()  __asm__(&quot;.inst 0xd4200000&quot;)</span>
    <span class="cp">#endif</span>

<span class="cp">#elif defined(CATCH_PLATFORM_IPHONE)</span>

    <span class="c1">// use inline assembler</span>
    <span class="cp">#if defined(__i386__) || defined(__x86_64__)</span>
        <span class="cp">#define CATCH_TRAP()  __asm__(&quot;int $3&quot;)</span>
    <span class="cp">#elif defined(__aarch64__)</span>
        <span class="cp">#define CATCH_TRAP()  __asm__(&quot;.inst 0xd4200000&quot;)</span>
    <span class="cp">#elif defined(__arm__) &amp;&amp; !defined(__thumb__)</span>
        <span class="cp">#define CATCH_TRAP()  __asm__(&quot;.inst 0xe7f001f0&quot;)</span>
    <span class="cp">#elif defined(__arm__) &amp;&amp;  defined(__thumb__)</span>
        <span class="cp">#define CATCH_TRAP()  __asm__(&quot;.inst 0xde01&quot;)</span>
    <span class="cp">#endif</span>

<span class="cp">#elif defined(CATCH_PLATFORM_LINUX)</span>
    <span class="c1">// If we can use inline assembler, do it because this allows us to break</span>
    <span class="c1">// directly at the location of the failing check instead of breaking inside</span>
    <span class="c1">// raise() called from it, i.e. one stack frame below.</span>
    <span class="cp">#if defined(__GNUC__) &amp;&amp; (defined(__i386) || defined(__x86_64))</span>
        <span class="cp">#define CATCH_TRAP() asm volatile (&quot;int $3&quot;) </span><span class="cm">/* NOLINT */</span><span class="cp"></span>
    <span class="cp">#else </span><span class="c1">// Fall back to the generic way.</span>
        <span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

        <span class="cp">#define CATCH_TRAP() raise(SIGTRAP)</span>
    <span class="cp">#endif</span>
<span class="cp">#elif defined(_MSC_VER)</span>
    <span class="cp">#define CATCH_TRAP() __debugbreak()</span>
<span class="cp">#elif defined(__MINGW32__)</span>
    <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span> <span class="kt">void</span> <span class="kr">__stdcall</span> <span class="n">DebugBreak</span><span class="p">();</span>
    <span class="cp">#define CATCH_TRAP() DebugBreak()</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CATCH_BREAK_INTO_DEBUGGER</span>
    <span class="cp">#ifdef CATCH_TRAP</span>
        <span class="cp">#define CATCH_BREAK_INTO_DEBUGGER() []{ if( Catch::isDebuggerActive() ) { CATCH_TRAP(); } }()</span>
    <span class="cp">#else</span>
        <span class="cp">#define CATCH_BREAK_INTO_DEBUGGER() []{}()</span>
    <span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_debugger.h</span>
<span class="c1">// start catch_run_context.h</span>

<span class="c1">// start catch_fatal_condition.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="c1">// Wrapper for platform-specific fatal error (signals/SEH) handlers</span>
    <span class="c1">//</span>
    <span class="c1">// Tries to be cooperative with other handlers, and not step over</span>
    <span class="c1">// other handlers. This means that unknown structured exceptions</span>
    <span class="c1">// are passed on, previous signal handlers are called, and so on.</span>
    <span class="c1">//</span>
    <span class="c1">// Can only be instantiated once, and assumes that once a signal</span>
    <span class="c1">// is caught, the binary will end up terminating. Thus, there</span>
    <span class="k">class</span> <span class="nc">FatalConditionHandler</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">m_started</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="c1">// Install/disengage implementation for specific platform.</span>
        <span class="c1">// Should be if-defed to work on current platform, can assume</span>
        <span class="c1">// engage-disengage 1:1 pairing.</span>
        <span class="kt">void</span> <span class="nf">engage_platform</span><span class="p">();</span>
        <span class="kt">void</span> <span class="nf">disengage_platform</span><span class="p">();</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// Should also have platform-specific implementations as needed</span>
        <span class="n">FatalConditionHandler</span><span class="p">();</span>
        <span class="o">~</span><span class="n">FatalConditionHandler</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">engage</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_started</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Handler cannot be installed twice.&quot;</span><span class="p">);</span>
            <span class="n">m_started</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">engage_platform</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">disengage</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">m_started</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Handler cannot be uninstalled without being installed first&quot;</span><span class="p">);</span>
            <span class="n">m_started</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">disengage_platform</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">//! Simple RAII guard for (dis)engaging the FatalConditionHandler</span>
    <span class="k">class</span> <span class="nc">FatalConditionHandlerGuard</span> <span class="p">{</span>
        <span class="n">FatalConditionHandler</span><span class="o">*</span> <span class="n">m_handler</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">FatalConditionHandlerGuard</span><span class="p">(</span><span class="n">FatalConditionHandler</span><span class="o">*</span> <span class="n">handler</span><span class="p">)</span><span class="o">:</span>
            <span class="n">m_handler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_handler</span><span class="o">-&gt;</span><span class="n">engage</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="o">~</span><span class="n">FatalConditionHandlerGuard</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">m_handler</span><span class="o">-&gt;</span><span class="n">disengage</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_fatal_condition.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">IMutableContext</span><span class="p">;</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////</span>

    <span class="k">class</span> <span class="nc">RunContext</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IResultCapture</span><span class="p">,</span> <span class="k">public</span> <span class="n">IRunner</span> <span class="p">{</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">RunContext</span><span class="p">(</span> <span class="n">RunContext</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">RunContext</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span><span class="p">(</span> <span class="n">RunContext</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">RunContext</span><span class="p">(</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_config</span><span class="p">,</span> <span class="n">IStreamingReporterPtr</span><span class="o">&amp;&amp;</span> <span class="n">reporter</span> <span class="p">);</span>

        <span class="o">~</span><span class="n">RunContext</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">testGroupStarting</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">groupIndex</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">groupsCount</span> <span class="p">);</span>
        <span class="kt">void</span> <span class="nf">testGroupEnded</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">totals</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">groupIndex</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">groupsCount</span> <span class="p">);</span>

        <span class="n">Totals</span> <span class="nf">runTest</span><span class="p">(</span><span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span><span class="p">);</span>

        <span class="n">IConfigPtr</span> <span class="nf">config</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">IStreamingReporter</span><span class="o">&amp;</span> <span class="nf">reporter</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span> <span class="c1">// IResultCapture</span>

        <span class="c1">// Assertion handlers</span>
        <span class="kt">void</span> <span class="n">handleExpr</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
                    <span class="n">ITransientExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">expr</span><span class="p">,</span>
                    <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">handleMessage</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
                    <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span>
                    <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">,</span>
                    <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">handleUnexpectedExceptionNotThrown</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
                    <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">handleUnexpectedInflightException</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">,</span>
                    <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">handleIncomplete</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">handleNonExpr</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span>
                    <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span>
                    <span class="n">AssertionReaction</span> <span class="o">&amp;</span><span class="n">reaction</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">sectionStarted</span><span class="p">(</span> <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionInfo</span><span class="p">,</span> <span class="n">Counts</span><span class="o">&amp;</span> <span class="n">assertions</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">sectionEnded</span><span class="p">(</span> <span class="n">SectionEndInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">endInfo</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">sectionEndedEarly</span><span class="p">(</span> <span class="n">SectionEndInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">endInfo</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="k">auto</span> <span class="nf">acquireGeneratorTracker</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">generatorName</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IGeneratorTracker</span><span class="o">&amp;</span> <span class="k">override</span><span class="p">;</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
        <span class="kt">void</span> <span class="nf">benchmarkPreparing</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkStarting</span><span class="p">(</span> <span class="n">BenchmarkInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkEnded</span><span class="p">(</span> <span class="n">BenchmarkStats</span><span class="o">&lt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stats</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkFailed</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">error</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

        <span class="kt">void</span> <span class="nf">pushScopedMessage</span><span class="p">(</span> <span class="n">MessageInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">popScopedMessage</span><span class="p">(</span> <span class="n">MessageInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">emplaceUnscopedMessage</span><span class="p">(</span> <span class="n">MessageBuilder</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">builder</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getCurrentTestName</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="k">const</span> <span class="n">AssertionResult</span><span class="o">*</span> <span class="n">getLastResult</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">exceptionEarlyReported</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">handleFatalErrorCondition</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">message</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nf">lastAssertionPassed</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">assertionPassed</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// !TBD We need to do this another way!</span>
        <span class="kt">bool</span> <span class="n">aborting</span><span class="p">()</span> <span class="k">const</span> <span class="k">final</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>

        <span class="kt">void</span> <span class="n">runCurrentTest</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">redirectedCout</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">redirectedCerr</span> <span class="p">);</span>
        <span class="kt">void</span> <span class="nf">invokeActiveTestCase</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">resetAssertionInfo</span><span class="p">();</span>
        <span class="kt">bool</span> <span class="nf">testForMissingAssertions</span><span class="p">(</span> <span class="n">Counts</span><span class="o">&amp;</span> <span class="n">assertions</span> <span class="p">);</span>

        <span class="kt">void</span> <span class="nf">assertionEnded</span><span class="p">(</span> <span class="n">AssertionResult</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">result</span> <span class="p">);</span>
        <span class="kt">void</span> <span class="nf">reportExpr</span>
                <span class="p">(</span>   <span class="n">AssertionInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span>
                    <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span>
                    <span class="n">ITransientExpression</span> <span class="k">const</span> <span class="o">*</span><span class="n">expr</span><span class="p">,</span>
                    <span class="kt">bool</span> <span class="n">negated</span> <span class="p">);</span>

        <span class="kt">void</span> <span class="nf">populateReaction</span><span class="p">(</span> <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span> <span class="p">);</span>

    <span class="k">private</span><span class="o">:</span>

        <span class="kt">void</span> <span class="n">handleUnfinishedSections</span><span class="p">();</span>

        <span class="n">TestRunInfo</span> <span class="n">m_runInfo</span><span class="p">;</span>
        <span class="n">IMutableContext</span><span class="o">&amp;</span> <span class="n">m_context</span><span class="p">;</span>
        <span class="n">TestCase</span> <span class="k">const</span><span class="o">*</span> <span class="n">m_activeTestCase</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">ITracker</span><span class="o">*</span> <span class="n">m_testCaseTracker</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">Option</span><span class="o">&lt;</span><span class="n">AssertionResult</span><span class="o">&gt;</span> <span class="n">m_lastResult</span><span class="p">;</span>

        <span class="n">IConfigPtr</span> <span class="n">m_config</span><span class="p">;</span>
        <span class="n">Totals</span> <span class="n">m_totals</span><span class="p">;</span>
        <span class="n">IStreamingReporterPtr</span> <span class="n">m_reporter</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MessageInfo</span><span class="o">&gt;</span> <span class="n">m_messages</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ScopedMessage</span><span class="o">&gt;</span> <span class="n">m_messageScopes</span><span class="p">;</span> <span class="cm">/* Keeps owners of so-called unscoped messages. */</span>
        <span class="n">AssertionInfo</span> <span class="n">m_lastAssertionInfo</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SectionEndInfo</span><span class="o">&gt;</span> <span class="n">m_unfinishedSections</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ITracker</span><span class="o">*&gt;</span> <span class="n">m_activeSections</span><span class="p">;</span>
        <span class="n">TrackerContext</span> <span class="n">m_trackerContext</span><span class="p">;</span>
        <span class="n">FatalConditionHandler</span> <span class="n">m_fatalConditionhandler</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_lastAssertionPassed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_shouldReportUnexpected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_includeSuccessfulResults</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">seedRng</span><span class="p">(</span><span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rngSeed</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_run_context.h</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">ITransientExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">expr</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">expr</span><span class="p">.</span><span class="n">streamReconstructedExpression</span><span class="p">(</span> <span class="n">os</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">LazyExpression</span><span class="o">::</span><span class="n">LazyExpression</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">isNegated</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_isNegated</span><span class="p">(</span> <span class="n">isNegated</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">LazyExpression</span><span class="o">::</span><span class="n">LazyExpression</span><span class="p">(</span> <span class="n">LazyExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_isNegated</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">m_isNegated</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="n">LazyExpression</span><span class="o">::</span><span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_transientExpression</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">LazyExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lazyExpr</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">lazyExpr</span><span class="p">.</span><span class="n">m_isNegated</span> <span class="p">)</span>
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;!&quot;</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">lazyExpr</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">lazyExpr</span><span class="p">.</span><span class="n">m_isNegated</span> <span class="o">&amp;&amp;</span> <span class="n">lazyExpr</span><span class="p">.</span><span class="n">m_transientExpression</span><span class="o">-&gt;</span><span class="n">isBinaryExpression</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;(&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">lazyExpr</span><span class="p">.</span><span class="n">m_transientExpression</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">lazyExpr</span><span class="p">.</span><span class="n">m_transientExpression</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{** error - unchecked empty expression requested **}&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">AssertionHandler</span>
        <span class="p">(</span>   <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">macroName</span><span class="p">,</span>
            <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span><span class="p">,</span>
            <span class="n">StringRef</span> <span class="n">capturedExpression</span><span class="p">,</span>
            <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Flags</span> <span class="n">resultDisposition</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_assertionInfo</span><span class="p">{</span> <span class="n">macroName</span><span class="p">,</span> <span class="n">lineInfo</span><span class="p">,</span> <span class="n">capturedExpression</span><span class="p">,</span> <span class="n">resultDisposition</span> <span class="p">},</span>
        <span class="n">m_resultCapture</span><span class="p">(</span> <span class="n">getResultCapture</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">handleExpr</span><span class="p">(</span> <span class="n">ITransientExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">expr</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_resultCapture</span><span class="p">.</span><span class="n">handleExpr</span><span class="p">(</span> <span class="n">m_assertionInfo</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">m_reaction</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">handleMessage</span><span class="p">(</span><span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_resultCapture</span><span class="p">.</span><span class="n">handleMessage</span><span class="p">(</span> <span class="n">m_assertionInfo</span><span class="p">,</span> <span class="n">resultType</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">m_reaction</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">allowThrows</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getCurrentContext</span><span class="p">().</span><span class="n">getConfig</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">allowThrows</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">complete</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">setCompleted</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_reaction</span><span class="p">.</span><span class="n">shouldDebugBreak</span> <span class="p">)</span> <span class="p">{</span>

            <span class="c1">// If you find your debugger stopping you here then go one level up on the</span>
            <span class="c1">// call-stack for the code that caused it (typically a failed assertion)</span>

            <span class="c1">// (To go back to the test and change execution, jump over the throw, next)</span>
            <span class="n">CATCH_BREAK_INTO_DEBUGGER</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_reaction</span><span class="p">.</span><span class="n">shouldThrow</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
            <span class="k">throw</span> <span class="n">Catch</span><span class="o">::</span><span class="n">TestFailureException</span><span class="p">();</span>
<span class="cp">#else</span>
            <span class="n">CATCH_ERROR</span><span class="p">(</span> <span class="s">&quot;Test failure requires aborting test!&quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">setCompleted</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_completed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">handleUnexpectedInflightException</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_resultCapture</span><span class="p">.</span><span class="n">handleUnexpectedInflightException</span><span class="p">(</span> <span class="n">m_assertionInfo</span><span class="p">,</span> <span class="n">Catch</span><span class="o">::</span><span class="n">translateActiveException</span><span class="p">(),</span> <span class="n">m_reaction</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">handleExceptionThrownAsExpected</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_resultCapture</span><span class="p">.</span><span class="n">handleNonExpr</span><span class="p">(</span><span class="n">m_assertionInfo</span><span class="p">,</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Ok</span><span class="p">,</span> <span class="n">m_reaction</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">handleExceptionNotThrownAsExpected</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_resultCapture</span><span class="p">.</span><span class="n">handleNonExpr</span><span class="p">(</span><span class="n">m_assertionInfo</span><span class="p">,</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Ok</span><span class="p">,</span> <span class="n">m_reaction</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">handleUnexpectedExceptionNotThrown</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_resultCapture</span><span class="p">.</span><span class="n">handleUnexpectedExceptionNotThrown</span><span class="p">(</span> <span class="n">m_assertionInfo</span><span class="p">,</span> <span class="n">m_reaction</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">AssertionHandler</span><span class="o">::</span><span class="n">handleThrowingCallSkipped</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_resultCapture</span><span class="p">.</span><span class="n">handleNonExpr</span><span class="p">(</span><span class="n">m_assertionInfo</span><span class="p">,</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Ok</span><span class="p">,</span> <span class="n">m_reaction</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// This is the overload that takes a string and infers the Equals matcher from it</span>
    <span class="c1">// The more general overload, that takes any string matcher, is in catch_capture_matchers.cpp</span>
    <span class="kt">void</span> <span class="n">handleExceptionMatchExpr</span><span class="p">(</span> <span class="n">AssertionHandler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matcherString</span>  <span class="p">)</span> <span class="p">{</span>
        <span class="n">handleExceptionMatchExpr</span><span class="p">(</span> <span class="n">handler</span><span class="p">,</span> <span class="n">Matchers</span><span class="o">::</span><span class="n">Equals</span><span class="p">(</span> <span class="n">str</span> <span class="p">),</span> <span class="n">matcherString</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_assertionhandler.cpp</span>
<span class="c1">// start catch_assertionresult.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">AssertionResultData</span><span class="o">::</span><span class="n">AssertionResultData</span><span class="p">(</span><span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">_resultType</span><span class="p">,</span> <span class="n">LazyExpression</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">_lazyExpression</span><span class="p">)</span><span class="o">:</span>
        <span class="n">lazyExpression</span><span class="p">(</span><span class="n">_lazyExpression</span><span class="p">),</span>
        <span class="n">resultType</span><span class="p">(</span><span class="n">_resultType</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">AssertionResultData</span><span class="o">::</span><span class="n">reconstructExpression</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">reconstructedExpression</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">lazyExpression</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
                <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">lazyExpression</span><span class="p">;</span>
                <span class="n">reconstructedExpression</span> <span class="o">=</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">reconstructedExpression</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">AssertionResult</span><span class="o">::</span><span class="n">AssertionResult</span><span class="p">(</span> <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span> <span class="n">AssertionResultData</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">data</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_info</span><span class="p">(</span> <span class="n">info</span> <span class="p">),</span>
        <span class="n">m_resultData</span><span class="p">(</span> <span class="n">data</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="c1">// Result was a success</span>
    <span class="kt">bool</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">succeeded</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Catch</span><span class="o">::</span><span class="n">isOk</span><span class="p">(</span> <span class="n">m_resultData</span><span class="p">.</span><span class="n">resultType</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Result was a success, or failure is suppressed</span>
    <span class="kt">bool</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">isOk</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Catch</span><span class="o">::</span><span class="n">isOk</span><span class="p">(</span> <span class="n">m_resultData</span><span class="p">.</span><span class="n">resultType</span> <span class="p">)</span> <span class="o">||</span> <span class="n">shouldSuppressFailure</span><span class="p">(</span> <span class="n">m_info</span><span class="p">.</span><span class="n">resultDisposition</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">getResultType</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_resultData</span><span class="p">.</span><span class="n">resultType</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">hasExpression</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">m_info</span><span class="p">.</span><span class="n">capturedExpression</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">hasMessage</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">m_resultData</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">getExpression</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// Possibly overallocating by 3 characters should be basically free</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expr</span><span class="p">;</span> <span class="n">expr</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">m_info</span><span class="p">.</span><span class="n">capturedExpression</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isFalseTest</span><span class="p">(</span><span class="n">m_info</span><span class="p">.</span><span class="n">resultDisposition</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">expr</span> <span class="o">+=</span> <span class="s">&quot;!(&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">expr</span> <span class="o">+=</span> <span class="n">m_info</span><span class="p">.</span><span class="n">capturedExpression</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isFalseTest</span><span class="p">(</span><span class="n">m_info</span><span class="p">.</span><span class="n">resultDisposition</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">expr</span> <span class="o">+=</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">expr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">getExpressionInMacro</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expr</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_info</span><span class="p">.</span><span class="n">macroName</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_info</span><span class="p">.</span><span class="n">capturedExpression</span><span class="p">);</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">expr</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="n">m_info</span><span class="p">.</span><span class="n">macroName</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">m_info</span><span class="p">.</span><span class="n">capturedExpression</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span> <span class="p">);</span>
            <span class="n">expr</span> <span class="o">+=</span> <span class="n">m_info</span><span class="p">.</span><span class="n">macroName</span><span class="p">;</span>
            <span class="n">expr</span> <span class="o">+=</span> <span class="s">&quot;( &quot;</span><span class="p">;</span>
            <span class="n">expr</span> <span class="o">+=</span> <span class="n">m_info</span><span class="p">.</span><span class="n">capturedExpression</span><span class="p">;</span>
            <span class="n">expr</span> <span class="o">+=</span> <span class="s">&quot; )&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">expr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">hasExpandedExpression</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">hasExpression</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">getExpandedExpression</span><span class="p">()</span> <span class="o">!=</span> <span class="n">getExpression</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">getExpandedExpression</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">m_resultData</span><span class="p">.</span><span class="n">reconstructExpression</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">expr</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span>
                <span class="o">?</span> <span class="n">getExpression</span><span class="p">()</span>
                <span class="o">:</span> <span class="n">expr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">getMessage</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_resultData</span><span class="p">.</span><span class="n">message</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">SourceLineInfo</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">getSourceInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_info</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">StringRef</span> <span class="n">AssertionResult</span><span class="o">::</span><span class="n">getTestMacroName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_info</span><span class="p">.</span><span class="n">macroName</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_assertionresult.cpp</span>
<span class="c1">// start catch_capture_matchers.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">using</span> <span class="n">StringMatcher</span> <span class="o">=</span> <span class="n">Matchers</span><span class="o">::</span><span class="n">Impl</span><span class="o">::</span><span class="n">MatcherBase</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c1">// This is the general overload that takes a any string matcher</span>
    <span class="c1">// There is another overload, in catch_assertionhandler.h/.cpp, that only takes a string and infers</span>
    <span class="c1">// the Equals matcher (so the header does not mention matchers)</span>
    <span class="kt">void</span> <span class="nf">handleExceptionMatchExpr</span><span class="p">(</span> <span class="n">AssertionHandler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">,</span> <span class="n">StringMatcher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matcherString</span>  <span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">exceptionMessage</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">translateActiveException</span><span class="p">();</span>
        <span class="n">MatchExpr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">StringMatcher</span> <span class="k">const</span><span class="o">&amp;&gt;</span> <span class="n">expr</span><span class="p">(</span> <span class="n">exceptionMessage</span><span class="p">,</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">matcherString</span> <span class="p">);</span>
        <span class="n">handler</span><span class="p">.</span><span class="n">handleExpr</span><span class="p">(</span> <span class="n">expr</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_capture_matchers.cpp</span>
<span class="c1">// start catch_commandline.cpp</span>

<span class="c1">// start catch_commandline.h</span>

<span class="c1">// start catch_clara.h</span>

<span class="c1">// Use Catch&#39;s value for console width (store Clara&#39;s off to the side, if present)</span>
<span class="cp">#ifdef CLARA_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#undef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#endif</span>
<span class="cp">#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH-1</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic push</span>
<span class="cp">#pragma clang diagnostic ignored &quot;-Wweak-vtables&quot;</span>
<span class="cp">#pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;</span>
<span class="cp">#pragma clang diagnostic ignored &quot;-Wshadow&quot;</span>
<span class="cp">#endif</span>

<span class="c1">// start clara.hpp</span>
<span class="c1">// Copyright 2017 Two Blue Cubes Ltd. All rights reserved.</span>
<span class="c1">//</span>
<span class="c1">// Distributed under the Boost Software License, Version 1.0. (See accompanying</span>
<span class="c1">// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="c1">//</span>
<span class="c1">// See https://github.com/philsquared/Clara for more details</span>

<span class="c1">// Clara v1.1.5</span>


<span class="cp">#ifndef CATCH_CLARA_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#define CATCH_CLARA_CONFIG_CONSOLE_WIDTH 80</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CLARA_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef CLARA_CONFIG_OPTIONAL_TYPE</span>
<span class="cp">#ifdef __has_include</span>
<span class="cp">#if __has_include(&lt;optional&gt;) &amp;&amp; __cplusplus &gt;= 201703L</span>
<span class="cp">#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp"></span>
<span class="cp">#define CLARA_CONFIG_OPTIONAL_TYPE std::optional</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="c1">// ----------- #included from clara_textflow.hpp -----------</span>

<span class="c1">// TextFlowCpp</span>
<span class="c1">//</span>
<span class="c1">// A single-header library for wrapping and laying out basic text, by Phil Nash</span>
<span class="c1">//</span>
<span class="c1">// Distributed under the Boost Software License, Version 1.0. (See accompanying</span>
<span class="c1">// file LICENSE.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="c1">//</span>
<span class="c1">// This project is hosted at https://github.com/philsquared/textflowcpp</span>


<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="cp">#ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH 80</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">clara</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">TextFlow</span> <span class="p">{</span>

<span class="kr">inline</span> <span class="k">auto</span> <span class="n">isWhitespace</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">chars</span> <span class="o">=</span> <span class="s">&quot; </span><span class="se">\t\n\r</span><span class="s">&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">chars</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="k">auto</span> <span class="n">isBreakableBefore</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">chars</span> <span class="o">=</span> <span class="s">&quot;[({&lt;|&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">chars</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="k">auto</span> <span class="n">isBreakableAfter</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">chars</span> <span class="o">=</span> <span class="s">&quot;])}&gt;.,:;*+-=&amp;/</span><span class="se">\\</span><span class="s">&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">chars</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Columns</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Column</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m_strings</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">m_width</span> <span class="o">=</span> <span class="n">CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">m_indent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">m_initialIndent</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">class</span> <span class="nc">iterator</span> <span class="p">{</span>
		<span class="k">friend</span> <span class="n">Column</span><span class="p">;</span>

		<span class="n">Column</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m_column</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">m_stringIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">m_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="kt">size_t</span> <span class="n">m_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">m_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">bool</span> <span class="n">m_suffix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">iterator</span><span class="p">(</span><span class="n">Column</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">column</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">stringIndex</span><span class="p">)</span>
			<span class="o">:</span> <span class="n">m_column</span><span class="p">(</span><span class="n">column</span><span class="p">),</span>
			<span class="n">m_stringIndex</span><span class="p">(</span><span class="n">stringIndex</span><span class="p">)</span> <span class="p">{}</span>

		<span class="k">auto</span> <span class="n">line</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_column</span><span class="p">.</span><span class="n">m_strings</span><span class="p">[</span><span class="n">m_stringIndex</span><span class="p">];</span> <span class="p">}</span>

		<span class="k">auto</span> <span class="n">isBoundary</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">at</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">at</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">at</span> <span class="o">&lt;=</span> <span class="n">line</span><span class="p">().</span><span class="n">size</span><span class="p">());</span>

			<span class="k">return</span> <span class="n">at</span> <span class="o">==</span> <span class="n">line</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">isWhitespace</span><span class="p">(</span><span class="n">line</span><span class="p">()[</span><span class="n">at</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isWhitespace</span><span class="p">(</span><span class="n">line</span><span class="p">()[</span><span class="n">at</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">||</span>
				<span class="n">isBreakableBefore</span><span class="p">(</span><span class="n">line</span><span class="p">()[</span><span class="n">at</span><span class="p">])</span> <span class="o">||</span>
				<span class="n">isBreakableAfter</span><span class="p">(</span><span class="n">line</span><span class="p">()[</span><span class="n">at</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>

		<span class="kt">void</span> <span class="n">calcLength</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">m_stringIndex</span> <span class="o">&lt;</span> <span class="n">m_column</span><span class="p">.</span><span class="n">m_strings</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

			<span class="n">m_suffix</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">auto</span> <span class="n">width</span> <span class="o">=</span> <span class="n">m_column</span><span class="p">.</span><span class="n">m_width</span> <span class="o">-</span> <span class="n">indent</span><span class="p">();</span>
			<span class="n">m_end</span> <span class="o">=</span> <span class="n">m_pos</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">()[</span><span class="n">m_pos</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">++</span><span class="n">m_end</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">m_end</span> <span class="o">&lt;</span> <span class="n">line</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">line</span><span class="p">()[</span><span class="n">m_end</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
				<span class="o">++</span><span class="n">m_end</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">m_end</span> <span class="o">&lt;</span> <span class="n">m_pos</span> <span class="o">+</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">m_len</span> <span class="o">=</span> <span class="n">m_end</span> <span class="o">-</span> <span class="n">m_pos</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isBoundary</span><span class="p">(</span><span class="n">m_pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">))</span>
					<span class="o">--</span><span class="n">len</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">isWhitespace</span><span class="p">(</span><span class="n">line</span><span class="p">()[</span><span class="n">m_pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
					<span class="o">--</span><span class="n">len</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">m_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">m_suffix</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="n">m_len</span> <span class="o">=</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">auto</span> <span class="n">indent</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">size_t</span> <span class="p">{</span>
			<span class="k">auto</span> <span class="n">initial</span> <span class="o">=</span> <span class="n">m_pos</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m_stringIndex</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">m_column</span><span class="p">.</span><span class="nl">m_initialIndent</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">initial</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="o">?</span> <span class="n">m_column</span><span class="p">.</span><span class="nl">m_indent</span> <span class="p">:</span> <span class="n">initial</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">auto</span> <span class="n">addIndentAndSuffix</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">plain</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">indent</span><span class="p">(),</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">m_suffix</span> <span class="o">?</span> <span class="n">plain</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">:</span> <span class="n">plain</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="k">public</span><span class="o">:</span>
		<span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">;</span>
		<span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
		<span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">value_type</span> <span class="o">*</span> <span class="p">;</span>
		<span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">value_type</span> <span class="o">&amp;</span> <span class="p">;</span>
		<span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward_iterator_tag</span><span class="p">;</span>

		<span class="k">explicit</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">Column</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">column</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">m_column</span><span class="p">.</span><span class="n">m_width</span> <span class="o">&gt;</span> <span class="n">m_column</span><span class="p">.</span><span class="n">m_indent</span><span class="p">);</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">m_column</span><span class="p">.</span><span class="n">m_initialIndent</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="o">||</span> <span class="n">m_column</span><span class="p">.</span><span class="n">m_width</span> <span class="o">&gt;</span> <span class="n">m_column</span><span class="p">.</span><span class="n">m_initialIndent</span><span class="p">);</span>
			<span class="n">calcLength</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">m_stringIndex</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Empty string</span>
		<span class="p">}</span>

		<span class="k">auto</span> <span class="k">operator</span> <span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">m_stringIndex</span> <span class="o">&lt;</span> <span class="n">m_column</span><span class="p">.</span><span class="n">m_strings</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">m_pos</span> <span class="o">&lt;=</span> <span class="n">m_end</span><span class="p">);</span>
			<span class="k">return</span> <span class="nf">addIndentAndSuffix</span><span class="p">(</span><span class="n">line</span><span class="p">().</span><span class="n">substr</span><span class="p">(</span><span class="n">m_pos</span><span class="p">,</span> <span class="n">m_len</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">auto</span> <span class="k">operator</span> <span class="o">++</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="p">{</span>
			<span class="n">m_pos</span> <span class="o">+=</span> <span class="n">m_len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_pos</span> <span class="o">&lt;</span> <span class="n">line</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">line</span><span class="p">()[</span><span class="n">m_pos</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
				<span class="n">m_pos</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="nf">while</span> <span class="p">(</span><span class="n">m_pos</span> <span class="o">&lt;</span> <span class="n">line</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">isWhitespace</span><span class="p">(</span><span class="n">line</span><span class="p">()[</span><span class="n">m_pos</span><span class="p">]))</span>
					<span class="o">++</span><span class="n">m_pos</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">m_pos</span> <span class="o">==</span> <span class="n">line</span><span class="p">().</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
				<span class="n">m_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="o">++</span><span class="n">m_stringIndex</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_stringIndex</span> <span class="o">&lt;</span> <span class="n">m_column</span><span class="p">.</span><span class="n">m_strings</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
				<span class="n">calcLength</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">auto</span> <span class="k">operator</span> <span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">iterator</span> <span class="p">{</span>
			<span class="n">iterator</span> <span class="nf">prev</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
			<span class="k">operator</span><span class="o">++</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">auto</span> <span class="k">operator</span> <span class="o">==</span><span class="p">(</span><span class="n">iterator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="k">return</span>
				<span class="n">m_pos</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">m_pos</span> <span class="o">&amp;&amp;</span>
				<span class="n">m_stringIndex</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">m_stringIndex</span> <span class="o">&amp;&amp;</span>
				<span class="o">&amp;</span><span class="n">m_column</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">m_column</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">auto</span> <span class="k">operator</span> <span class="o">!=</span><span class="p">(</span><span class="n">iterator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">!</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">};</span>
	<span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="n">iterator</span><span class="p">;</span>

	<span class="k">explicit</span> <span class="nf">Column</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_strings</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">text</span><span class="p">);</span> <span class="p">}</span>

	<span class="k">auto</span> <span class="nf">width</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">newWidth</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="o">&amp;</span> <span class="p">{</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">newWidth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">m_width</span> <span class="o">=</span> <span class="n">newWidth</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">auto</span> <span class="nf">indent</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">newIndent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="o">&amp;</span> <span class="p">{</span>
		<span class="n">m_indent</span> <span class="o">=</span> <span class="n">newIndent</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">auto</span> <span class="nf">initialIndent</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">newIndent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="o">&amp;</span> <span class="p">{</span>
		<span class="n">m_initialIndent</span> <span class="o">=</span> <span class="n">newIndent</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="nf">width</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">size_t</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_width</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">auto</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">iterator</span> <span class="p">{</span> <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
	<span class="k">auto</span> <span class="nf">end</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">iterator</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">m_strings</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">};</span> <span class="p">}</span>

	<span class="kr">inline</span> <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">Column</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">line</span> <span class="p">:</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
				<span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
			<span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">line</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">os</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="n">Column</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Columns</span><span class="p">;</span>

	<span class="k">auto</span> <span class="nf">toString</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
		<span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Spacer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Column</span> <span class="p">{</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">Spacer</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">spaceWidth</span><span class="p">)</span> <span class="o">:</span> <span class="n">Column</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">width</span><span class="p">(</span><span class="n">spaceWidth</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Columns</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Column</span><span class="o">&gt;</span> <span class="n">m_columns</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

	<span class="k">class</span> <span class="nc">iterator</span> <span class="p">{</span>
		<span class="k">friend</span> <span class="n">Columns</span><span class="p">;</span>
		<span class="k">struct</span> <span class="nc">EndTag</span> <span class="p">{};</span>

		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Column</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m_columns</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Column</span><span class="o">::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">m_iterators</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">m_activeIterators</span><span class="p">;</span>

		<span class="n">iterator</span><span class="p">(</span><span class="n">Columns</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">columns</span><span class="p">,</span> <span class="n">EndTag</span><span class="p">)</span>
			<span class="o">:</span> <span class="n">m_columns</span><span class="p">(</span><span class="n">columns</span><span class="p">.</span><span class="n">m_columns</span><span class="p">),</span>
			<span class="n">m_activeIterators</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m_iterators</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">m_columns</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">col</span> <span class="p">:</span> <span class="n">m_columns</span><span class="p">)</span>
				<span class="n">m_iterators</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
		<span class="p">}</span>

	<span class="k">public</span><span class="o">:</span>
		<span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">;</span>
		<span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
		<span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">value_type</span> <span class="o">*</span> <span class="p">;</span>
		<span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">value_type</span> <span class="o">&amp;</span> <span class="p">;</span>
		<span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward_iterator_tag</span><span class="p">;</span>

		<span class="k">explicit</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">Columns</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">columns</span><span class="p">)</span>
			<span class="o">:</span> <span class="n">m_columns</span><span class="p">(</span><span class="n">columns</span><span class="p">.</span><span class="n">m_columns</span><span class="p">),</span>
			<span class="n">m_activeIterators</span><span class="p">(</span><span class="n">m_columns</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">m_iterators</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">m_columns</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">col</span> <span class="p">:</span> <span class="n">m_columns</span><span class="p">)</span>
				<span class="n">m_iterators</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
		<span class="p">}</span>

		<span class="k">auto</span> <span class="k">operator</span> <span class="o">==</span><span class="p">(</span><span class="n">iterator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">m_iterators</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">m_iterators</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">auto</span> <span class="k">operator</span> <span class="o">!=</span><span class="p">(</span><span class="n">iterator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">m_iterators</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_iterators</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">auto</span> <span class="k">operator</span> <span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">row</span><span class="p">,</span> <span class="n">padding</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_columns</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">auto</span> <span class="n">width</span> <span class="o">=</span> <span class="n">m_columns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">width</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">m_iterators</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">m_columns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">col</span> <span class="o">=</span> <span class="o">*</span><span class="n">m_iterators</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
					<span class="n">row</span> <span class="o">+=</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">col</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span>
						<span class="n">padding</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="n">col</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
					<span class="k">else</span>
						<span class="n">padding</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">padding</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">row</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">auto</span> <span class="k">operator</span> <span class="o">++</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_columns</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">m_iterators</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">m_columns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">())</span>
					<span class="o">++</span><span class="n">m_iterators</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">auto</span> <span class="k">operator</span> <span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">iterator</span> <span class="p">{</span>
			<span class="n">iterator</span> <span class="nf">prev</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
			<span class="k">operator</span><span class="o">++</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">};</span>
	<span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="n">iterator</span><span class="p">;</span>

	<span class="k">auto</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">iterator</span> <span class="p">{</span> <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
	<span class="k">auto</span> <span class="nf">end</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">iterator</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">iterator</span><span class="o">::</span><span class="n">EndTag</span><span class="p">()</span> <span class="p">};</span> <span class="p">}</span>

	<span class="k">auto</span> <span class="k">operator</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Column</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">col</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Columns</span><span class="o">&amp;</span> <span class="p">{</span>
		<span class="n">m_columns</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">col</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">auto</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="n">Column</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">col</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Columns</span> <span class="p">{</span>
		<span class="n">Columns</span> <span class="n">combined</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
		<span class="n">combined</span> <span class="o">+=</span> <span class="n">col</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">combined</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kr">inline</span> <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">Columns</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>

		<span class="kt">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">line</span> <span class="p">:</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
				<span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
			<span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">line</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">os</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
		<span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kr">inline</span> <span class="k">auto</span> <span class="n">Column</span><span class="o">::</span><span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="n">Column</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Columns</span> <span class="p">{</span>
	<span class="n">Columns</span> <span class="n">cols</span><span class="p">;</span>
	<span class="n">cols</span> <span class="o">+=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="n">cols</span> <span class="o">+=</span> <span class="n">other</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cols</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ----------- end of #include from clara_textflow.hpp -----------</span>
<span class="c1">// ........... back in clara.hpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="cp">#if !defined(CATCH_PLATFORM_WINDOWS) &amp;&amp; ( defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) )</span>
<span class="cp">#define CATCH_PLATFORM_WINDOWS</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">clara</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>

    <span class="c1">// Traits for extracting arg and return type of lambdas (for single argument lambdas)</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">L</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">UnaryLambdaTraits</span> <span class="o">:</span> <span class="n">UnaryLambdaTraits</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">L</span><span class="o">::</span><span class="k">operator</span><span class="p">()</span> <span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ClassT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ReturnT</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">UnaryLambdaTraits</span><span class="o">&lt;</span><span class="n">ReturnT</span><span class="p">(</span> <span class="n">ClassT</span><span class="o">::*</span> <span class="p">)(</span> <span class="n">Args</span><span class="p">...</span> <span class="p">)</span> <span class="k">const</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">isValid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ClassT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ReturnT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ArgT</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">UnaryLambdaTraits</span><span class="o">&lt;</span><span class="n">ReturnT</span><span class="p">(</span> <span class="n">ClassT</span><span class="o">::*</span> <span class="p">)(</span> <span class="n">ArgT</span> <span class="p">)</span> <span class="k">const</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">isValid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">ArgType</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">remove_const</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">ArgT</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="n">ReturnT</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">TokenStream</span><span class="p">;</span>

    <span class="c1">// Transport for raw args (copied from main args, or supplied via init list for testing)</span>
    <span class="k">class</span> <span class="nc">Args</span> <span class="p">{</span>
        <span class="k">friend</span> <span class="n">TokenStream</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_exeName</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m_args</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">Args</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">argv</span> <span class="p">)</span>
            <span class="o">:</span> <span class="n">m_exeName</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
              <span class="n">m_args</span><span class="p">(</span><span class="n">argv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">argv</span> <span class="o">+</span> <span class="n">argc</span><span class="p">)</span> <span class="p">{}</span>

        <span class="n">Args</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">args</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">m_exeName</span><span class="p">(</span> <span class="o">*</span><span class="n">args</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">),</span>
            <span class="n">m_args</span><span class="p">(</span> <span class="n">args</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span>
        <span class="p">{}</span>

        <span class="k">auto</span> <span class="n">exeName</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_exeName</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// Wraps a token coming from a token stream. These may not directly correspond to strings as a single string</span>
    <span class="c1">// may encode an option + its argument if the : or = form is used</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">TokenType</span> <span class="p">{</span>
        <span class="n">Option</span><span class="p">,</span> <span class="n">Argument</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="nc">Token</span> <span class="p">{</span>
        <span class="n">TokenType</span> <span class="n">type</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">token</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kr">inline</span> <span class="k">auto</span> <span class="n">isOptPrefix</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span>
<span class="cp">#ifdef CATCH_PLATFORM_WINDOWS</span>
            <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span>
<span class="cp">#endif</span>
        <span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled</span>
    <span class="k">class</span> <span class="nc">TokenStream</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">Iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="p">;</span>
        <span class="n">Iterator</span> <span class="n">it</span><span class="p">;</span>
        <span class="n">Iterator</span> <span class="n">itEnd</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="n">m_tokenBuffer</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">loadBuffer</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>

            <span class="c1">// Skip any empty strings</span>
            <span class="k">while</span><span class="p">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">itEnd</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                <span class="o">++</span><span class="n">it</span><span class="p">;</span>

            <span class="k">if</span><span class="p">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">itEnd</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">isOptPrefix</span><span class="p">(</span> <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">delimiterPos</span> <span class="o">=</span> <span class="n">next</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span> <span class="s">&quot; :=&quot;</span> <span class="p">);</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">delimiterPos</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="p">{</span> <span class="n">TokenType</span><span class="o">::</span><span class="n">Option</span><span class="p">,</span> <span class="n">next</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delimiterPos</span> <span class="p">)</span> <span class="p">}</span> <span class="p">);</span>
                        <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="p">{</span> <span class="n">TokenType</span><span class="o">::</span><span class="n">Argument</span><span class="p">,</span> <span class="n">next</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">delimiterPos</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">}</span> <span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">if</span><span class="p">(</span> <span class="n">next</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;-&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">next</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">opt</span> <span class="o">=</span> <span class="s">&quot;- &quot;</span><span class="p">;</span>
                            <span class="k">for</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">next</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
                                <span class="n">opt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                                <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="p">{</span> <span class="n">TokenType</span><span class="o">::</span><span class="n">Option</span><span class="p">,</span> <span class="n">opt</span> <span class="p">}</span> <span class="p">);</span>
                            <span class="p">}</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="p">{</span> <span class="n">TokenType</span><span class="o">::</span><span class="n">Option</span><span class="p">,</span> <span class="n">next</span> <span class="p">}</span> <span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="p">{</span> <span class="n">TokenType</span><span class="o">::</span><span class="n">Argument</span><span class="p">,</span> <span class="n">next</span> <span class="p">}</span> <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="k">explicit</span> <span class="n">TokenStream</span><span class="p">(</span> <span class="n">Args</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">args</span> <span class="p">)</span> <span class="o">:</span> <span class="n">TokenStream</span><span class="p">(</span> <span class="n">args</span><span class="p">.</span><span class="n">m_args</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">args</span><span class="p">.</span><span class="n">m_args</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="n">TokenStream</span><span class="p">(</span> <span class="n">Iterator</span> <span class="n">it</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">itEnd</span> <span class="p">)</span> <span class="o">:</span> <span class="n">it</span><span class="p">(</span> <span class="n">it</span> <span class="p">),</span> <span class="n">itEnd</span><span class="p">(</span> <span class="n">itEnd</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">loadBuffer</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">itEnd</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">count</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">size_t</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">itEnd</span> <span class="o">-</span> <span class="n">it</span><span class="p">);</span> <span class="p">}</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Token</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span> <span class="o">!</span><span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Token</span> <span class="k">const</span> <span class="o">*</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span> <span class="o">!</span><span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">);</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">TokenStream</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">m_tokenBuffer</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">itEnd</span> <span class="p">)</span>
                    <span class="o">++</span><span class="n">it</span><span class="p">;</span>
                <span class="n">loadBuffer</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">ResultBase</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">enum</span> <span class="nc">Type</span> <span class="p">{</span>
            <span class="n">Ok</span><span class="p">,</span> <span class="n">LogicError</span><span class="p">,</span> <span class="n">RuntimeError</span>
        <span class="p">};</span>

    <span class="k">protected</span><span class="o">:</span>
        <span class="n">ResultBase</span><span class="p">(</span> <span class="n">Type</span> <span class="n">type</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_type</span><span class="p">(</span> <span class="n">type</span> <span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">ResultBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">enforceOk</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">Type</span> <span class="n">m_type</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">ResultValueBase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ResultBase</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">auto</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">enforceOk</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">protected</span><span class="o">:</span>
        <span class="n">ResultValueBase</span><span class="p">(</span> <span class="n">Type</span> <span class="n">type</span> <span class="p">)</span> <span class="o">:</span> <span class="n">ResultBase</span><span class="p">(</span> <span class="n">type</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="n">ResultValueBase</span><span class="p">(</span> <span class="n">ResultValueBase</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="o">:</span> <span class="n">ResultBase</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_type</span> <span class="o">==</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Ok</span> <span class="p">)</span>
                <span class="k">new</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">m_value</span> <span class="p">)</span> <span class="n">T</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">m_value</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">ResultValueBase</span><span class="p">(</span> <span class="n">Type</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">value</span> <span class="p">)</span> <span class="o">:</span> <span class="n">ResultBase</span><span class="p">(</span> <span class="n">Ok</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">new</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">m_value</span> <span class="p">)</span> <span class="n">T</span><span class="p">(</span> <span class="n">value</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">ResultValueBase</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResultValueBase</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_type</span> <span class="o">==</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Ok</span> <span class="p">)</span>
                <span class="n">m_value</span><span class="p">.</span><span class="o">~</span><span class="n">T</span><span class="p">();</span>
            <span class="n">ResultBase</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_type</span> <span class="o">==</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Ok</span> <span class="p">)</span>
                <span class="k">new</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">m_value</span> <span class="p">)</span> <span class="n">T</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">m_value</span> <span class="p">);</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">ResultValueBase</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_type</span> <span class="o">==</span> <span class="n">Ok</span> <span class="p">)</span>
                <span class="n">m_value</span><span class="p">.</span><span class="o">~</span><span class="n">T</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">union</span> <span class="p">{</span>
            <span class="n">T</span> <span class="n">m_value</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">class</span> <span class="nc">ResultValueBase</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ResultBase</span> <span class="p">{</span>
    <span class="k">protected</span><span class="o">:</span>
        <span class="k">using</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">ResultBase</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">BasicResult</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ResultValueBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="o">&gt;</span>
        <span class="k">explicit</span> <span class="n">BasicResult</span><span class="p">(</span> <span class="n">BasicResult</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">ResultValueBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="p">),</span>
            <span class="n">m_errorMessage</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">errorMessage</span><span class="p">()</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span> <span class="n">type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Ok</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="o">&gt;</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">ok</span><span class="p">(</span> <span class="n">U</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">value</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BasicResult</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Ok</span><span class="p">,</span> <span class="n">value</span> <span class="p">};</span> <span class="p">}</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">ok</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">BasicResult</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Ok</span> <span class="p">};</span> <span class="p">}</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">logicError</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">message</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BasicResult</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">LogicError</span><span class="p">,</span> <span class="n">message</span> <span class="p">};</span> <span class="p">}</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">runtimeError</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">message</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BasicResult</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">RuntimeError</span><span class="p">,</span> <span class="n">message</span> <span class="p">};</span> <span class="p">}</span>

        <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_type</span> <span class="o">==</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Ok</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">auto</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Type</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_type</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">auto</span> <span class="n">errorMessage</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_errorMessage</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">protected</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">enforceOk</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>

            <span class="c1">// Errors shouldn&#39;t reach this point, but if they do</span>
            <span class="c1">// the actual error message will be in m_errorMessage</span>
            <span class="n">assert</span><span class="p">(</span> <span class="n">m_type</span> <span class="o">!=</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">LogicError</span> <span class="p">);</span>
            <span class="n">assert</span><span class="p">(</span> <span class="n">m_type</span> <span class="o">!=</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">RuntimeError</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_type</span> <span class="o">!=</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Ok</span> <span class="p">)</span>
                <span class="n">std</span><span class="o">::</span><span class="n">abort</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_errorMessage</span><span class="p">;</span> <span class="c1">// Only populated if resultType is an error</span>

        <span class="n">BasicResult</span><span class="p">(</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Type</span> <span class="n">type</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">message</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">ResultValueBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">type</span><span class="p">),</span>
            <span class="n">m_errorMessage</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span> <span class="n">m_type</span> <span class="o">!=</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">Ok</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">using</span> <span class="n">ResultValueBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ResultValueBase</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">ResultBase</span><span class="o">::</span><span class="n">m_type</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">enum</span> <span class="k">class</span> <span class="nc">ParseResultType</span> <span class="p">{</span>
        <span class="n">Matched</span><span class="p">,</span> <span class="n">NoMatch</span><span class="p">,</span> <span class="n">ShortCircuitAll</span><span class="p">,</span> <span class="n">ShortCircuitSame</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">ParseState</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>

        <span class="n">ParseState</span><span class="p">(</span> <span class="n">ParseResultType</span> <span class="n">type</span><span class="p">,</span> <span class="n">TokenStream</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">remainingTokens</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">m_type</span><span class="p">(</span><span class="n">type</span><span class="p">),</span>
          <span class="n">m_remainingTokens</span><span class="p">(</span> <span class="n">remainingTokens</span> <span class="p">)</span>
        <span class="p">{}</span>

        <span class="k">auto</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">ParseResultType</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_type</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">auto</span> <span class="n">remainingTokens</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_remainingTokens</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">ParseResultType</span> <span class="n">m_type</span><span class="p">;</span>
        <span class="n">TokenStream</span> <span class="n">m_remainingTokens</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">using</span> <span class="n">Result</span> <span class="o">=</span> <span class="n">BasicResult</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ParserResult</span> <span class="o">=</span> <span class="n">BasicResult</span><span class="o">&lt;</span><span class="n">ParseResultType</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">InternalParseResult</span> <span class="o">=</span> <span class="n">BasicResult</span><span class="o">&lt;</span><span class="n">ParseState</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">HelpColumns</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="kr">inline</span> <span class="k">auto</span> <span class="n">convertInto</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">target</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="n">source</span><span class="p">;</span>
        <span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">target</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">ss</span><span class="p">.</span><span class="n">fail</span><span class="p">()</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;Unable to convert &#39;&quot;</span> <span class="o">+</span> <span class="n">source</span> <span class="o">+</span> <span class="s">&quot;&#39; to destination type&quot;</span> <span class="p">);</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kr">inline</span> <span class="k">auto</span> <span class="n">convertInto</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">target</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="p">{</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">source</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kr">inline</span> <span class="k">auto</span> <span class="n">convertInto</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">target</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">srcLC</span> <span class="o">=</span> <span class="n">source</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span> <span class="n">srcLC</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">srcLC</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">srcLC</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[](</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">tolower</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">);</span> <span class="p">}</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">srcLC</span> <span class="o">==</span> <span class="s">&quot;y&quot;</span> <span class="o">||</span> <span class="n">srcLC</span> <span class="o">==</span> <span class="s">&quot;1&quot;</span> <span class="o">||</span> <span class="n">srcLC</span> <span class="o">==</span> <span class="s">&quot;true&quot;</span> <span class="o">||</span> <span class="n">srcLC</span> <span class="o">==</span> <span class="s">&quot;yes&quot;</span> <span class="o">||</span> <span class="n">srcLC</span> <span class="o">==</span> <span class="s">&quot;on&quot;</span><span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">srcLC</span> <span class="o">==</span> <span class="s">&quot;n&quot;</span> <span class="o">||</span> <span class="n">srcLC</span> <span class="o">==</span> <span class="s">&quot;0&quot;</span> <span class="o">||</span> <span class="n">srcLC</span> <span class="o">==</span> <span class="s">&quot;false&quot;</span> <span class="o">||</span> <span class="n">srcLC</span> <span class="o">==</span> <span class="s">&quot;no&quot;</span> <span class="o">||</span> <span class="n">srcLC</span> <span class="o">==</span> <span class="s">&quot;off&quot;</span><span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;Expected a boolean value but did not recognise: &#39;&quot;</span> <span class="o">+</span> <span class="n">source</span> <span class="o">+</span> <span class="s">&quot;&#39;&quot;</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#ifdef CLARA_CONFIG_OPTIONAL_TYPE</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="kr">inline</span> <span class="k">auto</span> <span class="n">convertInto</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">,</span> <span class="n">CLARA_CONFIG_OPTIONAL_TYPE</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">target</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">temp</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">convertInto</span><span class="p">(</span> <span class="n">source</span><span class="p">,</span> <span class="n">temp</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">result</span> <span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CLARA_CONFIG_OPTIONAL_TYPE</span>

    <span class="k">struct</span> <span class="nc">NonCopyable</span> <span class="p">{</span>
        <span class="n">NonCopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">NonCopyable</span><span class="p">(</span> <span class="n">NonCopyable</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">NonCopyable</span><span class="p">(</span> <span class="n">NonCopyable</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">NonCopyable</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">NonCopyable</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">NonCopyable</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">NonCopyable</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">BoundRef</span> <span class="o">:</span> <span class="n">NonCopyable</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">BoundRef</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">isContainer</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">isFlag</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="nc">BoundValueRefBase</span> <span class="o">:</span> <span class="n">BoundRef</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">setValue</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">arg</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="nc">BoundFlagRefBase</span> <span class="o">:</span> <span class="n">BoundRef</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">setFlag</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">flag</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">isFlag</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">BoundValueRef</span> <span class="o">:</span> <span class="n">BoundValueRefBase</span> <span class="p">{</span>
        <span class="n">T</span> <span class="o">&amp;</span><span class="n">m_ref</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">BoundValueRef</span><span class="p">(</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_ref</span><span class="p">(</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">auto</span> <span class="nf">setValue</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">arg</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">convertInto</span><span class="p">(</span> <span class="n">arg</span><span class="p">,</span> <span class="n">m_ref</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">BoundValueRef</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">:</span> <span class="n">BoundValueRefBase</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m_ref</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">BoundValueRef</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_ref</span><span class="p">(</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">auto</span> <span class="nf">isContainer</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">auto</span> <span class="nf">setValue</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">arg</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">T</span> <span class="n">temp</span><span class="p">;</span>
            <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">convertInto</span><span class="p">(</span> <span class="n">arg</span><span class="p">,</span> <span class="n">temp</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">result</span> <span class="p">)</span>
                <span class="n">m_ref</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">temp</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">BoundFlagRef</span> <span class="o">:</span> <span class="n">BoundFlagRefBase</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">m_ref</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">BoundFlagRef</span><span class="p">(</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_ref</span><span class="p">(</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">auto</span> <span class="nf">setFlag</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">flag</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">m_ref</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ReturnType</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">LambdaInvoker</span> <span class="p">{</span>
        <span class="k">static_assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="p">,</span> <span class="n">ParserResult</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">&quot;Lambda must return void or clara::ParserResult&quot;</span> <span class="p">);</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">L</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ArgType</span><span class="o">&gt;</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">invoke</span><span class="p">(</span> <span class="n">L</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">lambda</span><span class="p">,</span> <span class="n">ArgType</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">arg</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">lambda</span><span class="p">(</span> <span class="n">arg</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="nc">LambdaInvoker</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">L</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">ArgType</span><span class="o">&gt;</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">invoke</span><span class="p">(</span> <span class="n">L</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">lambda</span><span class="p">,</span> <span class="n">ArgType</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">arg</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="p">{</span>
            <span class="n">lambda</span><span class="p">(</span> <span class="n">arg</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ArgType</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">L</span><span class="o">&gt;</span>
    <span class="kr">inline</span> <span class="k">auto</span> <span class="n">invokeLambda</span><span class="p">(</span> <span class="n">L</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">lambda</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">arg</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="p">{</span>
        <span class="n">ArgType</span> <span class="n">temp</span><span class="p">{};</span>
        <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">convertInto</span><span class="p">(</span> <span class="n">arg</span><span class="p">,</span> <span class="n">temp</span> <span class="p">);</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">result</span>
           <span class="o">?</span> <span class="nl">result</span>
           <span class="p">:</span> <span class="n">LambdaInvoker</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">UnaryLambdaTraits</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;::</span><span class="n">ReturnType</span><span class="o">&gt;::</span><span class="n">invoke</span><span class="p">(</span> <span class="n">lambda</span><span class="p">,</span> <span class="n">temp</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">L</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">BoundLambda</span> <span class="o">:</span> <span class="n">BoundValueRefBase</span> <span class="p">{</span>
        <span class="n">L</span> <span class="n">m_lambda</span><span class="p">;</span>

        <span class="k">static_assert</span><span class="p">(</span> <span class="n">UnaryLambdaTraits</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;::</span><span class="n">isValid</span><span class="p">,</span> <span class="s">&quot;Supplied lambda must take exactly one argument&quot;</span> <span class="p">);</span>
        <span class="k">explicit</span> <span class="nf">BoundLambda</span><span class="p">(</span> <span class="n">L</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">lambda</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_lambda</span><span class="p">(</span> <span class="n">lambda</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">auto</span> <span class="nf">setValue</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">arg</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">invokeLambda</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">UnaryLambdaTraits</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;::</span><span class="n">ArgType</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">m_lambda</span><span class="p">,</span> <span class="n">arg</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">L</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">BoundFlagLambda</span> <span class="o">:</span> <span class="n">BoundFlagRefBase</span> <span class="p">{</span>
        <span class="n">L</span> <span class="n">m_lambda</span><span class="p">;</span>

        <span class="k">static_assert</span><span class="p">(</span> <span class="n">UnaryLambdaTraits</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;::</span><span class="n">isValid</span><span class="p">,</span> <span class="s">&quot;Supplied lambda must take exactly one argument&quot;</span> <span class="p">);</span>
        <span class="k">static_assert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">UnaryLambdaTraits</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;::</span><span class="n">ArgType</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">&quot;flags must be boolean&quot;</span> <span class="p">);</span>

        <span class="k">explicit</span> <span class="nf">BoundFlagLambda</span><span class="p">(</span> <span class="n">L</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">lambda</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_lambda</span><span class="p">(</span> <span class="n">lambda</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">auto</span> <span class="nf">setFlag</span><span class="p">(</span> <span class="kt">bool</span> <span class="n">flag</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">LambdaInvoker</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">UnaryLambdaTraits</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;::</span><span class="n">ReturnType</span><span class="o">&gt;::</span><span class="n">invoke</span><span class="p">(</span> <span class="n">m_lambda</span><span class="p">,</span> <span class="n">flag</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">enum</span> <span class="k">class</span> <span class="nc">Optionality</span> <span class="p">{</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Required</span> <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">Parser</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">ParserBase</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">ParserBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">validate</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Result</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Result</span><span class="o">::</span><span class="n">ok</span><span class="p">();</span> <span class="p">}</span>
        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">parse</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">exeName</span><span class="p">,</span> <span class="n">TokenStream</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">tokens</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">InternalParseResult</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="k">auto</span> <span class="n">cardinality</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">size_t</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">auto</span> <span class="n">parse</span><span class="p">(</span> <span class="n">Args</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">args</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">InternalParseResult</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">parse</span><span class="p">(</span> <span class="n">args</span><span class="p">.</span><span class="n">exeName</span><span class="p">(),</span> <span class="n">TokenStream</span><span class="p">(</span> <span class="n">args</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">DerivedT</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">ComposableParserImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ParserBase</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Parser</span><span class="p">;</span>

		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Parser</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="c1">// Common code and state for Args and Opts</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">DerivedT</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">ParserRefImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ComposableParserImpl</span><span class="o">&lt;</span><span class="n">DerivedT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">protected</span><span class="o">:</span>
        <span class="n">Optionality</span> <span class="n">m_optionality</span> <span class="o">=</span> <span class="n">Optionality</span><span class="o">::</span><span class="n">Optional</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">BoundRef</span><span class="o">&gt;</span> <span class="n">m_ref</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_hint</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_description</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">ParserRefImpl</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">BoundRef</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_ref</span><span class="p">(</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">ParserRefImpl</span><span class="p">(</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">hint</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">m_ref</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BoundValueRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">),</span>
            <span class="n">m_hint</span><span class="p">(</span> <span class="n">hint</span> <span class="p">)</span>
        <span class="p">{}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LambdaT</span><span class="o">&gt;</span>
        <span class="n">ParserRefImpl</span><span class="p">(</span> <span class="n">LambdaT</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">hint</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">m_ref</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BoundLambda</span><span class="o">&lt;</span><span class="n">LambdaT</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">),</span>
            <span class="n">m_hint</span><span class="p">(</span><span class="n">hint</span><span class="p">)</span>
        <span class="p">{}</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="p">()(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">description</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DerivedT</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">m_description</span> <span class="o">=</span> <span class="n">description</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DerivedT</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">optional</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">DerivedT</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">m_optionality</span> <span class="o">=</span> <span class="n">Optionality</span><span class="o">::</span><span class="n">Optional</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DerivedT</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
        <span class="p">};</span>

        <span class="k">auto</span> <span class="nf">required</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">DerivedT</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">m_optionality</span> <span class="o">=</span> <span class="n">Optionality</span><span class="o">::</span><span class="n">Required</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DerivedT</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
        <span class="p">};</span>

        <span class="k">auto</span> <span class="nf">isOptional</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_optionality</span> <span class="o">==</span> <span class="n">Optionality</span><span class="o">::</span><span class="n">Optional</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="nf">cardinality</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">size_t</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_ref</span><span class="o">-&gt;</span><span class="n">isContainer</span><span class="p">()</span> <span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="nf">hint</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_hint</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">ExeName</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ComposableParserImpl</span><span class="o">&lt;</span><span class="n">ExeName</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m_name</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">BoundValueRefBase</span><span class="o">&gt;</span> <span class="n">m_ref</span><span class="p">;</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LambdaT</span><span class="o">&gt;</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">makeRef</span><span class="p">(</span><span class="n">LambdaT</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">lambda</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">BoundValueRefBase</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BoundLambda</span><span class="o">&lt;</span><span class="n">LambdaT</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="n">lambda</span><span class="p">)</span> <span class="p">;</span>
        <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">ExeName</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_name</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span> <span class="s">&quot;&lt;executable&gt;&quot;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">explicit</span> <span class="n">ExeName</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="p">)</span> <span class="o">:</span> <span class="n">ExeName</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">m_ref</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BoundValueRef</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="n">ref</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LambdaT</span><span class="o">&gt;</span>
        <span class="k">explicit</span> <span class="n">ExeName</span><span class="p">(</span> <span class="n">LambdaT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lambda</span> <span class="p">)</span> <span class="o">:</span> <span class="n">ExeName</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">m_ref</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BoundLambda</span><span class="o">&lt;</span><span class="n">LambdaT</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="n">lambda</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// The exe name is not parsed out of the normal tokens, but is handled specially</span>
        <span class="k">auto</span> <span class="n">parse</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">TokenStream</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">tokens</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">InternalParseResult</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseState</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">NoMatch</span><span class="p">,</span> <span class="n">tokens</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">m_name</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">auto</span> <span class="n">set</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">newName</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserResult</span> <span class="p">{</span>

            <span class="k">auto</span> <span class="n">lastSlash</span> <span class="o">=</span> <span class="n">newName</span><span class="p">.</span><span class="n">find_last_of</span><span class="p">(</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">/&quot;</span> <span class="p">);</span>
            <span class="k">auto</span> <span class="n">filename</span> <span class="o">=</span> <span class="p">(</span> <span class="n">lastSlash</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="p">)</span>
                    <span class="o">?</span> <span class="nl">newName</span>
                    <span class="p">:</span> <span class="n">newName</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">lastSlash</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>

            <span class="o">*</span><span class="n">m_name</span> <span class="o">=</span> <span class="n">filename</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_ref</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">m_ref</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span> <span class="n">filename</span> <span class="p">);</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Arg</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ParserRefImpl</span><span class="o">&lt;</span><span class="n">Arg</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">using</span> <span class="n">ParserRefImpl</span><span class="o">::</span><span class="n">ParserRefImpl</span><span class="p">;</span>

        <span class="k">auto</span> <span class="nf">parse</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">TokenStream</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">tokens</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">InternalParseResult</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">validationResult</span> <span class="o">=</span> <span class="n">validate</span><span class="p">();</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">validationResult</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">InternalParseResult</span><span class="p">(</span> <span class="n">validationResult</span> <span class="p">);</span>

            <span class="k">auto</span> <span class="n">remainingTokens</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">;</span>
            <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">token</span> <span class="o">=</span> <span class="o">*</span><span class="n">remainingTokens</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">token</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TokenType</span><span class="o">::</span><span class="n">Argument</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseState</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">NoMatch</span><span class="p">,</span> <span class="n">remainingTokens</span> <span class="p">)</span> <span class="p">);</span>

            <span class="n">assert</span><span class="p">(</span> <span class="o">!</span><span class="n">m_ref</span><span class="o">-&gt;</span><span class="n">isFlag</span><span class="p">()</span> <span class="p">);</span>
            <span class="k">auto</span> <span class="n">valueRef</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">BoundValueRefBase</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">m_ref</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">);</span>

            <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">valueRef</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span> <span class="n">remainingTokens</span><span class="o">-&gt;</span><span class="n">token</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">result</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">InternalParseResult</span><span class="p">(</span> <span class="n">result</span> <span class="p">);</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseState</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span><span class="p">,</span> <span class="o">++</span><span class="n">remainingTokens</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="kr">inline</span> <span class="k">auto</span> <span class="n">normaliseOpt</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">optName</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
<span class="cp">#ifdef CATCH_PLATFORM_WINDOWS</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">optName</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">)</span>
            <span class="k">return</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">optName</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
        <span class="k">else</span>
<span class="cp">#endif</span>
            <span class="k">return</span> <span class="n">optName</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">Opt</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ParserRefImpl</span><span class="o">&lt;</span><span class="n">Opt</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">protected</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m_optNames</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LambdaT</span><span class="o">&gt;</span>
        <span class="k">explicit</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">LambdaT</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="p">)</span> <span class="o">:</span> <span class="n">ParserRefImpl</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BoundFlagLambda</span><span class="o">&lt;</span><span class="n">LambdaT</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">explicit</span> <span class="n">Opt</span><span class="p">(</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="p">)</span> <span class="o">:</span> <span class="n">ParserRefImpl</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">BoundFlagRef</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LambdaT</span><span class="o">&gt;</span>
        <span class="n">Opt</span><span class="p">(</span> <span class="n">LambdaT</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">hint</span> <span class="p">)</span> <span class="o">:</span> <span class="n">ParserRefImpl</span><span class="p">(</span> <span class="n">ref</span><span class="p">,</span> <span class="n">hint</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="n">Opt</span><span class="p">(</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">hint</span> <span class="p">)</span> <span class="o">:</span> <span class="n">ParserRefImpl</span><span class="p">(</span> <span class="n">ref</span><span class="p">,</span> <span class="n">hint</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">optName</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Opt</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">m_optNames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">optName</span> <span class="p">);</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">getHelpColumns</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HelpColumns</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">opt</span> <span class="p">:</span> <span class="n">m_optNames</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
                    <span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
                <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">opt</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">m_hint</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &lt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_hint</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;&quot;</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">{</span> <span class="p">{</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span> <span class="n">m_description</span> <span class="p">}</span> <span class="p">};</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">isMatch</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">optToken</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">normalisedToken</span> <span class="o">=</span> <span class="n">normaliseOpt</span><span class="p">(</span> <span class="n">optToken</span> <span class="p">);</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">name</span> <span class="p">:</span> <span class="n">m_optNames</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">normaliseOpt</span><span class="p">(</span> <span class="n">name</span> <span class="p">)</span> <span class="o">==</span> <span class="n">normalisedToken</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">using</span> <span class="n">ParserBase</span><span class="o">::</span><span class="n">parse</span><span class="p">;</span>

        <span class="k">auto</span> <span class="nf">parse</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">TokenStream</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">tokens</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">InternalParseResult</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">validationResult</span> <span class="o">=</span> <span class="n">validate</span><span class="p">();</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">validationResult</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">InternalParseResult</span><span class="p">(</span> <span class="n">validationResult</span> <span class="p">);</span>

            <span class="k">auto</span> <span class="n">remainingTokens</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">remainingTokens</span> <span class="o">&amp;&amp;</span> <span class="n">remainingTokens</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TokenType</span><span class="o">::</span><span class="n">Option</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">token</span> <span class="o">=</span> <span class="o">*</span><span class="n">remainingTokens</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">isMatch</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">token</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">m_ref</span><span class="o">-&gt;</span><span class="n">isFlag</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="k">auto</span> <span class="n">flagRef</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">BoundFlagRefBase</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">m_ref</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">);</span>
                        <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">flagRef</span><span class="o">-&gt;</span><span class="n">setFlag</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
                        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">result</span> <span class="p">)</span>
                            <span class="k">return</span> <span class="n">InternalParseResult</span><span class="p">(</span> <span class="n">result</span> <span class="p">);</span>
                        <span class="k">if</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">ShortCircuitAll</span> <span class="p">)</span>
                            <span class="k">return</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseState</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">remainingTokens</span> <span class="p">)</span> <span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">auto</span> <span class="n">valueRef</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">BoundValueRefBase</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">m_ref</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">);</span>
                        <span class="o">++</span><span class="n">remainingTokens</span><span class="p">;</span>
                        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">remainingTokens</span> <span class="p">)</span>
                            <span class="k">return</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;Expected argument following &quot;</span> <span class="o">+</span> <span class="n">token</span><span class="p">.</span><span class="n">token</span> <span class="p">);</span>
                        <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">argToken</span> <span class="o">=</span> <span class="o">*</span><span class="n">remainingTokens</span><span class="p">;</span>
                        <span class="k">if</span><span class="p">(</span> <span class="n">argToken</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TokenType</span><span class="o">::</span><span class="n">Argument</span> <span class="p">)</span>
                            <span class="k">return</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;Expected argument following &quot;</span> <span class="o">+</span> <span class="n">token</span><span class="p">.</span><span class="n">token</span> <span class="p">);</span>
                        <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">valueRef</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span> <span class="n">argToken</span><span class="p">.</span><span class="n">token</span> <span class="p">);</span>
                        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">result</span> <span class="p">)</span>
                            <span class="k">return</span> <span class="n">InternalParseResult</span><span class="p">(</span> <span class="n">result</span> <span class="p">);</span>
                        <span class="k">if</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">ShortCircuitAll</span> <span class="p">)</span>
                            <span class="k">return</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseState</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">remainingTokens</span> <span class="p">)</span> <span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">return</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseState</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span><span class="p">,</span> <span class="o">++</span><span class="n">remainingTokens</span> <span class="p">)</span> <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseState</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">NoMatch</span><span class="p">,</span> <span class="n">remainingTokens</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="nf">validate</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Result</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_optNames</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">Result</span><span class="o">::</span><span class="n">logicError</span><span class="p">(</span> <span class="s">&quot;No options supplied to Opt&quot;</span> <span class="p">);</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">name</span> <span class="p">:</span> <span class="n">m_optNames</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">name</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">Result</span><span class="o">::</span><span class="n">logicError</span><span class="p">(</span> <span class="s">&quot;Option name cannot be empty&quot;</span> <span class="p">);</span>
<span class="cp">#ifdef CATCH_PLATFORM_WINDOWS</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;-&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">Result</span><span class="o">::</span><span class="n">logicError</span><span class="p">(</span> <span class="s">&quot;Option name must begin with &#39;-&#39; or &#39;/&#39;&quot;</span> <span class="p">);</span>
<span class="cp">#else</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;-&#39;</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">Result</span><span class="o">::</span><span class="n">logicError</span><span class="p">(</span> <span class="s">&quot;Option name must begin with &#39;-&#39;&quot;</span> <span class="p">);</span>
<span class="cp">#endif</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">ParserRefImpl</span><span class="o">::</span><span class="n">validate</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">Help</span> <span class="o">:</span> <span class="n">Opt</span> <span class="p">{</span>
        <span class="n">Help</span><span class="p">(</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">showHelpFlag</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">Opt</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span> <span class="kt">bool</span> <span class="n">flag</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">showHelpFlag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">ShortCircuitAll</span> <span class="p">);</span>
            <span class="p">})</span>
        <span class="p">{</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Opt</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">)</span>
                    <span class="p">(</span><span class="s">&quot;display usage information&quot;</span><span class="p">)</span>
                    <span class="p">[</span><span class="s">&quot;-?&quot;</span><span class="p">][</span><span class="s">&quot;-h&quot;</span><span class="p">][</span><span class="s">&quot;--help&quot;</span><span class="p">]</span>
                    <span class="p">.</span><span class="n">optional</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">Parser</span> <span class="o">:</span> <span class="n">ParserBase</span> <span class="p">{</span>

        <span class="k">mutable</span> <span class="n">ExeName</span> <span class="n">m_exeName</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Opt</span><span class="o">&gt;</span> <span class="n">m_options</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Arg</span><span class="o">&gt;</span> <span class="n">m_args</span><span class="p">;</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="o">|=</span><span class="p">(</span> <span class="n">ExeName</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">exeName</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Parser</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">m_exeName</span> <span class="o">=</span> <span class="n">exeName</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="o">|=</span><span class="p">(</span> <span class="n">Arg</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">arg</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Parser</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">m_args</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="o">|=</span><span class="p">(</span> <span class="n">Opt</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">opt</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Parser</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">m_options</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">opt</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="k">operator</span><span class="o">|=</span><span class="p">(</span> <span class="n">Parser</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Parser</span> <span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">m_options</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">m_options</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">other</span><span class="p">.</span><span class="n">m_options</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">other</span><span class="p">.</span><span class="n">m_options</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
            <span class="n">m_args</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">m_args</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">other</span><span class="p">.</span><span class="n">m_args</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">other</span><span class="p">.</span><span class="n">m_args</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Parser</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Parser</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">)</span> <span class="o">|=</span> <span class="n">other</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Forward deprecated interface with &#39;+&#39; instead of &#39;|&#39;</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Parser</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="k">operator</span><span class="o">|=</span><span class="p">(</span> <span class="n">other</span> <span class="p">);</span> <span class="p">}</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">auto</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Parser</span> <span class="p">{</span> <span class="k">return</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span> <span class="n">other</span> <span class="p">);</span> <span class="p">}</span>

        <span class="k">auto</span> <span class="n">getHelpColumns</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HelpColumns</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HelpColumns</span><span class="o">&gt;</span> <span class="n">cols</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">o</span> <span class="p">:</span> <span class="n">m_options</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">childCols</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">getHelpColumns</span><span class="p">();</span>
                <span class="n">cols</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">cols</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">childCols</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">childCols</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">cols</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">writeToStream</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_exeName</span><span class="p">.</span><span class="n">name</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;usage:</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_exeName</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
                <span class="kt">bool</span> <span class="n">required</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">arg</span> <span class="p">:</span> <span class="n">m_args</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
                        <span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">else</span>
                        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">arg</span><span class="p">.</span><span class="n">isOptional</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">required</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span><span class="p">;</span>
                        <span class="n">required</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span><span class="p">.</span><span class="n">hint</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;&quot;</span><span class="p">;</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">arg</span><span class="p">.</span><span class="n">cardinality</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
                        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; ... &quot;</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">required</span> <span class="p">)</span>
                    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">m_options</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; options&quot;</span><span class="p">;</span>
                <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">where options are:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">auto</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">getHelpColumns</span><span class="p">();</span>
            <span class="kt">size_t</span> <span class="n">consoleWidth</span> <span class="o">=</span> <span class="n">CATCH_CLARA_CONFIG_CONSOLE_WIDTH</span><span class="p">;</span>
            <span class="kt">size_t</span> <span class="n">optWidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">cols</span> <span class="p">:</span> <span class="n">rows</span> <span class="p">)</span>
                <span class="n">optWidth</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">)(</span><span class="n">optWidth</span><span class="p">,</span> <span class="n">cols</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

            <span class="n">optWidth</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">)(</span><span class="n">optWidth</span><span class="p">,</span> <span class="n">consoleWidth</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">cols</span> <span class="p">:</span> <span class="n">rows</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">row</span> <span class="o">=</span>
                        <span class="n">TextFlow</span><span class="o">::</span><span class="n">Column</span><span class="p">(</span> <span class="n">cols</span><span class="p">.</span><span class="n">left</span> <span class="p">).</span><span class="n">width</span><span class="p">(</span> <span class="n">optWidth</span> <span class="p">).</span><span class="n">indent</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">+</span>
                        <span class="n">TextFlow</span><span class="o">::</span><span class="n">Spacer</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span>
                        <span class="n">TextFlow</span><span class="o">::</span><span class="n">Column</span><span class="p">(</span> <span class="n">cols</span><span class="p">.</span><span class="n">right</span> <span class="p">).</span><span class="n">width</span><span class="p">(</span> <span class="n">consoleWidth</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">-</span> <span class="n">optWidth</span> <span class="p">);</span>
                <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">row</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">friend</span> <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">Parser</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">parser</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="p">{</span>
            <span class="n">parser</span><span class="p">.</span><span class="n">writeToStream</span><span class="p">(</span> <span class="n">os</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">validate</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Result</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">opt</span> <span class="p">:</span> <span class="n">m_options</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">opt</span><span class="p">.</span><span class="n">validate</span><span class="p">();</span>
                <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">result</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">arg</span> <span class="p">:</span> <span class="n">m_args</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="n">validate</span><span class="p">();</span>
                <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">result</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">Result</span><span class="o">::</span><span class="n">ok</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">using</span> <span class="n">ParserBase</span><span class="o">::</span><span class="n">parse</span><span class="p">;</span>

        <span class="k">auto</span> <span class="nf">parse</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">exeName</span><span class="p">,</span> <span class="n">TokenStream</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">tokens</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">InternalParseResult</span> <span class="k">override</span> <span class="p">{</span>

            <span class="k">struct</span> <span class="nc">ParserInfo</span> <span class="p">{</span>
                <span class="n">ParserBase</span> <span class="k">const</span><span class="o">*</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
                <span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">};</span>
            <span class="k">const</span> <span class="kt">size_t</span> <span class="n">totalParsers</span> <span class="o">=</span> <span class="n">m_options</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">m_args</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="n">assert</span><span class="p">(</span> <span class="n">totalParsers</span> <span class="o">&lt;</span> <span class="mi">512</span> <span class="p">);</span>
            <span class="c1">// ParserInfo parseInfos[totalParsers]; // &lt;-- this is what we really want to do</span>
            <span class="n">ParserInfo</span> <span class="n">parseInfos</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>

            <span class="p">{</span>
                <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">opt</span> <span class="p">:</span> <span class="n">m_options</span><span class="p">)</span> <span class="n">parseInfos</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">].</span><span class="n">parser</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="nl">arg</span> <span class="p">:</span> <span class="n">m_args</span><span class="p">)</span> <span class="n">parseInfos</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">].</span><span class="n">parser</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">m_exeName</span><span class="p">.</span><span class="n">set</span><span class="p">(</span> <span class="n">exeName</span> <span class="p">);</span>

            <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseState</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">NoMatch</span><span class="p">,</span> <span class="n">tokens</span> <span class="p">)</span> <span class="p">);</span>
            <span class="k">while</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">remainingTokens</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                <span class="kt">bool</span> <span class="n">tokenParsed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

                <span class="k">for</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">totalParsers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">auto</span><span class="o">&amp;</span>  <span class="n">parseInfo</span> <span class="o">=</span> <span class="n">parseInfos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">parseInfo</span><span class="p">.</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">cardinality</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">parseInfo</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">parseInfo</span><span class="p">.</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">cardinality</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">parseInfo</span><span class="p">.</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">parse</span><span class="p">(</span><span class="n">exeName</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">remainingTokens</span><span class="p">());</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
                            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">NoMatch</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">tokenParsed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                            <span class="o">++</span><span class="n">parseInfo</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
                            <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="k">if</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">ShortCircuitAll</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">tokenParsed</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">InternalParseResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;Unrecognised token: &quot;</span> <span class="o">+</span> <span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">remainingTokens</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">token</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// !TBD Check missing required options</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">DerivedT</span><span class="o">&gt;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="n">ComposableParserImpl</span><span class="o">&lt;</span><span class="n">DerivedT</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">|</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">Parser</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Parser</span><span class="p">()</span> <span class="o">|</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DerivedT</span> <span class="k">const</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">)</span> <span class="o">|</span> <span class="n">other</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace detail</span>

<span class="c1">// A Combined parser</span>
<span class="k">using</span> <span class="n">detail</span><span class="o">::</span><span class="n">Parser</span><span class="p">;</span>

<span class="c1">// A parser for options</span>
<span class="k">using</span> <span class="n">detail</span><span class="o">::</span><span class="n">Opt</span><span class="p">;</span>

<span class="c1">// A parser for arguments</span>
<span class="k">using</span> <span class="n">detail</span><span class="o">::</span><span class="n">Arg</span><span class="p">;</span>

<span class="c1">// Wrapper for argc, argv from main()</span>
<span class="k">using</span> <span class="n">detail</span><span class="o">::</span><span class="n">Args</span><span class="p">;</span>

<span class="c1">// Specifies the name of the executable</span>
<span class="k">using</span> <span class="n">detail</span><span class="o">::</span><span class="n">ExeName</span><span class="p">;</span>

<span class="c1">// Convenience wrapper for option parser that specifies the help option</span>
<span class="k">using</span> <span class="n">detail</span><span class="o">::</span><span class="n">Help</span><span class="p">;</span>

<span class="c1">// enum of result types from a parse</span>
<span class="k">using</span> <span class="n">detail</span><span class="o">::</span><span class="n">ParseResultType</span><span class="p">;</span>

<span class="c1">// Result type for parser operation</span>
<span class="k">using</span> <span class="n">detail</span><span class="o">::</span><span class="n">ParserResult</span><span class="p">;</span>

<span class="p">}}</span> <span class="c1">// namespace Catch::clara</span>

<span class="c1">// end clara.hpp</span>
<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic pop</span>
<span class="cp">#endif</span>

<span class="c1">// Restore Clara&#39;s value for console width, if present</span>
<span class="cp">#ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_clara.h</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">clara</span><span class="o">::</span><span class="n">Parser</span> <span class="n">makeCommandLineParser</span><span class="p">(</span> <span class="n">ConfigData</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_commandline.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">clara</span><span class="o">::</span><span class="n">Parser</span> <span class="n">makeCommandLineParser</span><span class="p">(</span> <span class="n">ConfigData</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="p">{</span>

        <span class="k">using</span> <span class="k">namespace</span> <span class="n">clara</span><span class="p">;</span>

        <span class="k">auto</span> <span class="k">const</span> <span class="n">setWarning</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">warning</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">warningSet</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">warning</span> <span class="o">==</span> <span class="s">&quot;NoAssertions&quot;</span> <span class="p">)</span>
                        <span class="k">return</span> <span class="n">WarnAbout</span><span class="o">::</span><span class="n">NoAssertions</span><span class="p">;</span>

                    <span class="k">if</span> <span class="p">(</span> <span class="n">warning</span> <span class="o">==</span> <span class="s">&quot;NoTests&quot;</span> <span class="p">)</span>
                        <span class="k">return</span> <span class="n">WarnAbout</span><span class="o">::</span><span class="n">NoTests</span><span class="p">;</span>

                    <span class="k">return</span> <span class="n">WarnAbout</span><span class="o">::</span><span class="n">Nothing</span><span class="p">;</span>
                <span class="p">}();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">warningSet</span> <span class="o">==</span> <span class="n">WarnAbout</span><span class="o">::</span><span class="n">Nothing</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;Unrecognised warning: &#39;&quot;</span> <span class="o">+</span> <span class="n">warning</span> <span class="o">+</span> <span class="s">&quot;&#39;&quot;</span> <span class="p">);</span>
                <span class="n">config</span><span class="p">.</span><span class="n">warnings</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">WarnAbout</span><span class="o">::</span><span class="n">What</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">warnings</span> <span class="o">|</span> <span class="n">warningSet</span> <span class="p">);</span>
                <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
            <span class="p">};</span>
        <span class="k">auto</span> <span class="k">const</span> <span class="n">loadTestNamesFromFile</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filename</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">f</span><span class="p">(</span> <span class="n">filename</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="p">);</span>
                <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">f</span><span class="p">.</span><span class="n">is_open</span><span class="p">()</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;Unable to load input file: &#39;&quot;</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s">&quot;&#39;&quot;</span> <span class="p">);</span>

                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
                <span class="k">while</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="n">line</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">trim</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
                    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">line</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">startsWith</span><span class="p">(</span> <span class="n">line</span><span class="p">,</span> <span class="sc">&#39;#&#39;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">startsWith</span><span class="p">(</span> <span class="n">line</span><span class="p">,</span> <span class="sc">&#39;&quot;&#39;</span> <span class="p">)</span> <span class="p">)</span>
                            <span class="n">line</span> <span class="o">=</span> <span class="sc">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">line</span> <span class="o">+</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">;</span>
                        <span class="n">config</span><span class="p">.</span><span class="n">testsOrTags</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">line</span> <span class="p">);</span>
                        <span class="n">config</span><span class="p">.</span><span class="n">testsOrTags</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="s">&quot;,&quot;</span> <span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="c1">//Remove comma in the end</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">config</span><span class="p">.</span><span class="n">testsOrTags</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
                    <span class="n">config</span><span class="p">.</span><span class="n">testsOrTags</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">testsOrTags</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="mi">-1</span> <span class="p">);</span>

                <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
            <span class="p">};</span>
        <span class="k">auto</span> <span class="k">const</span> <span class="n">setTestOrder</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">order</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">startsWith</span><span class="p">(</span> <span class="s">&quot;declared&quot;</span><span class="p">,</span> <span class="n">order</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">config</span><span class="p">.</span><span class="n">runOrder</span> <span class="o">=</span> <span class="n">RunTests</span><span class="o">::</span><span class="n">InDeclarationOrder</span><span class="p">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">startsWith</span><span class="p">(</span> <span class="s">&quot;lexical&quot;</span><span class="p">,</span> <span class="n">order</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">config</span><span class="p">.</span><span class="n">runOrder</span> <span class="o">=</span> <span class="n">RunTests</span><span class="o">::</span><span class="n">InLexicographicalOrder</span><span class="p">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">startsWith</span><span class="p">(</span> <span class="s">&quot;random&quot;</span><span class="p">,</span> <span class="n">order</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">config</span><span class="p">.</span><span class="n">runOrder</span> <span class="o">=</span> <span class="n">RunTests</span><span class="o">::</span><span class="n">InRandomOrder</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="k">return</span> <span class="n">clara</span><span class="o">::</span><span class="n">ParserResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;Unrecognised ordering: &#39;&quot;</span> <span class="o">+</span> <span class="n">order</span> <span class="o">+</span> <span class="s">&quot;&#39;&quot;</span> <span class="p">);</span>
                <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
            <span class="p">};</span>
        <span class="k">auto</span> <span class="k">const</span> <span class="n">setRngSeed</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">seed</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">seed</span> <span class="o">!=</span> <span class="s">&quot;time&quot;</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">clara</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">convertInto</span><span class="p">(</span> <span class="n">seed</span><span class="p">,</span> <span class="n">config</span><span class="p">.</span><span class="n">rngSeed</span> <span class="p">);</span>
                <span class="n">config</span><span class="p">.</span><span class="n">rngSeed</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">time</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">);</span>
                <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
            <span class="p">};</span>
        <span class="k">auto</span> <span class="k">const</span> <span class="n">setColourUsage</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">useColour</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">useColour</span> <span class="p">);</span>

                    <span class="k">if</span><span class="p">(</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&quot;yes&quot;</span> <span class="p">)</span>
                        <span class="n">config</span><span class="p">.</span><span class="n">useColour</span> <span class="o">=</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">Yes</span><span class="p">;</span>
                    <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&quot;no&quot;</span> <span class="p">)</span>
                        <span class="n">config</span><span class="p">.</span><span class="n">useColour</span> <span class="o">=</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">No</span><span class="p">;</span>
                    <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&quot;auto&quot;</span> <span class="p">)</span>
                        <span class="n">config</span><span class="p">.</span><span class="n">useColour</span> <span class="o">=</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">Auto</span><span class="p">;</span>
                    <span class="k">else</span>
                        <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;colour mode must be one of: auto, yes or no. &#39;&quot;</span> <span class="o">+</span> <span class="n">useColour</span> <span class="o">+</span> <span class="s">&quot;&#39; not recognised&quot;</span> <span class="p">);</span>
                <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
            <span class="p">};</span>
        <span class="k">auto</span> <span class="k">const</span> <span class="n">setWaitForKeypress</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">keypress</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">keypressLc</span> <span class="o">=</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">keypress</span> <span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">keypressLc</span> <span class="o">==</span> <span class="s">&quot;never&quot;</span><span class="p">)</span>
                    <span class="n">config</span><span class="p">.</span><span class="n">waitForKeypress</span> <span class="o">=</span> <span class="n">WaitForKeypress</span><span class="o">::</span><span class="n">Never</span><span class="p">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">keypressLc</span> <span class="o">==</span> <span class="s">&quot;start&quot;</span> <span class="p">)</span>
                    <span class="n">config</span><span class="p">.</span><span class="n">waitForKeypress</span> <span class="o">=</span> <span class="n">WaitForKeypress</span><span class="o">::</span><span class="n">BeforeStart</span><span class="p">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">keypressLc</span> <span class="o">==</span> <span class="s">&quot;exit&quot;</span> <span class="p">)</span>
                    <span class="n">config</span><span class="p">.</span><span class="n">waitForKeypress</span> <span class="o">=</span> <span class="n">WaitForKeypress</span><span class="o">::</span><span class="n">BeforeExit</span><span class="p">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">keypressLc</span> <span class="o">==</span> <span class="s">&quot;both&quot;</span> <span class="p">)</span>
                    <span class="n">config</span><span class="p">.</span><span class="n">waitForKeypress</span> <span class="o">=</span> <span class="n">WaitForKeypress</span><span class="o">::</span><span class="n">BeforeStartAndExit</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;keypress argument must be one of: never, start, exit or both. &#39;&quot;</span> <span class="o">+</span> <span class="n">keypress</span> <span class="o">+</span> <span class="s">&quot;&#39; not recognised&quot;</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
            <span class="p">};</span>
        <span class="k">auto</span> <span class="k">const</span> <span class="n">setVerbosity</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">verbosity</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">lcVerbosity</span> <span class="o">=</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">verbosity</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">lcVerbosity</span> <span class="o">==</span> <span class="s">&quot;quiet&quot;</span> <span class="p">)</span>
                <span class="n">config</span><span class="p">.</span><span class="n">verbosity</span> <span class="o">=</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">Quiet</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">lcVerbosity</span> <span class="o">==</span> <span class="s">&quot;normal&quot;</span> <span class="p">)</span>
                <span class="n">config</span><span class="p">.</span><span class="n">verbosity</span> <span class="o">=</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">Normal</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">lcVerbosity</span> <span class="o">==</span> <span class="s">&quot;high&quot;</span> <span class="p">)</span>
                <span class="n">config</span><span class="p">.</span><span class="n">verbosity</span> <span class="o">=</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">High</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;Unrecognised verbosity, &#39;&quot;</span> <span class="o">+</span> <span class="n">verbosity</span> <span class="o">+</span> <span class="s">&quot;&#39;&quot;</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
        <span class="p">};</span>
        <span class="k">auto</span> <span class="k">const</span> <span class="n">setReporter</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">reporter</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">IReporterRegistry</span><span class="o">::</span><span class="n">FactoryMap</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">factories</span> <span class="o">=</span> <span class="n">getRegistryHub</span><span class="p">().</span><span class="n">getReporterRegistry</span><span class="p">().</span><span class="n">getFactories</span><span class="p">();</span>

            <span class="k">auto</span> <span class="n">lcReporter</span> <span class="o">=</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">reporter</span> <span class="p">);</span>
            <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">factories</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">lcReporter</span> <span class="p">);</span>

            <span class="k">if</span><span class="p">(</span> <span class="n">factories</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">!=</span> <span class="n">result</span> <span class="p">)</span>
                <span class="n">config</span><span class="p">.</span><span class="n">reporterName</span> <span class="o">=</span> <span class="n">lcReporter</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">runtimeError</span><span class="p">(</span> <span class="s">&quot;Unrecognized reporter, &#39;&quot;</span> <span class="o">+</span> <span class="n">reporter</span> <span class="o">+</span> <span class="s">&quot;&#39;. Check available with --list-reporters&quot;</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">ParserResult</span><span class="o">::</span><span class="n">ok</span><span class="p">(</span> <span class="n">ParseResultType</span><span class="o">::</span><span class="n">Matched</span> <span class="p">);</span>
        <span class="p">};</span>

        <span class="k">auto</span> <span class="n">cli</span>
            <span class="o">=</span> <span class="n">ExeName</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">processName</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Help</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">showHelp</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">listTests</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-l&quot;</span><span class="p">][</span><span class="s">&quot;--list-tests&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;list all/matching test cases&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">listTags</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-t&quot;</span><span class="p">][</span><span class="s">&quot;--list-tags&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;list all/matching tags&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">showSuccessfulTests</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-s&quot;</span><span class="p">][</span><span class="s">&quot;--success&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;include successful tests in output&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">shouldDebugBreak</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-b&quot;</span><span class="p">][</span><span class="s">&quot;--break&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;break into debugger on failure&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">noThrow</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-e&quot;</span><span class="p">][</span><span class="s">&quot;--nothrow&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;skip exception tests&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">showInvisibles</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-i&quot;</span><span class="p">][</span><span class="s">&quot;--invisibles&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;show invisibles (tabs, newlines)&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">outputFilename</span><span class="p">,</span> <span class="s">&quot;filename&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-o&quot;</span><span class="p">][</span><span class="s">&quot;--out&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;output filename&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">setReporter</span><span class="p">,</span> <span class="s">&quot;name&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-r&quot;</span><span class="p">][</span><span class="s">&quot;--reporter&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;reporter to use (defaults to console)&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;name&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-n&quot;</span><span class="p">][</span><span class="s">&quot;--name&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;suite name&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="kt">bool</span> <span class="p">){</span> <span class="n">config</span><span class="p">.</span><span class="n">abortAfter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-a&quot;</span><span class="p">][</span><span class="s">&quot;--abort&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;abort at first failure&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">){</span> <span class="n">config</span><span class="p">.</span><span class="n">abortAfter</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">},</span> <span class="s">&quot;no. failures&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-x&quot;</span><span class="p">][</span><span class="s">&quot;--abortx&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;abort after x failures&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">setWarning</span><span class="p">,</span> <span class="s">&quot;warning name&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-w&quot;</span><span class="p">][</span><span class="s">&quot;--warn&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;enable warnings&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="kt">bool</span> <span class="n">flag</span> <span class="p">)</span> <span class="p">{</span> <span class="n">config</span><span class="p">.</span><span class="n">showDurations</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">?</span> <span class="n">ShowDurations</span><span class="o">::</span><span class="nl">Always</span> <span class="p">:</span> <span class="n">ShowDurations</span><span class="o">::</span><span class="n">Never</span><span class="p">;</span> <span class="p">},</span> <span class="s">&quot;yes|no&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-d&quot;</span><span class="p">][</span><span class="s">&quot;--durations&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;show test durations&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">minDuration</span><span class="p">,</span> <span class="s">&quot;seconds&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-D&quot;</span><span class="p">][</span><span class="s">&quot;--min-duration&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;show test durations for tests taking at least the given number of seconds&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">loadTestNamesFromFile</span><span class="p">,</span> <span class="s">&quot;filename&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-f&quot;</span><span class="p">][</span><span class="s">&quot;--input-file&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;load test names to run from a file&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">filenamesAsTags</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-#&quot;</span><span class="p">][</span><span class="s">&quot;--filenames-as-tags&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;adds a tag for the filename&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">sectionsToRun</span><span class="p">,</span> <span class="s">&quot;section name&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-c&quot;</span><span class="p">][</span><span class="s">&quot;--section&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;specify section to run&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">setVerbosity</span><span class="p">,</span> <span class="s">&quot;quiet|normal|high&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;-v&quot;</span><span class="p">][</span><span class="s">&quot;--verbosity&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;set output verbosity&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">listTestNamesOnly</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--list-test-names-only&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;list all/matching test cases names only&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">listReporters</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--list-reporters&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;list all reporters&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">setTestOrder</span><span class="p">,</span> <span class="s">&quot;decl|lex|rand&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--order&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;test case order (defaults to decl)&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">setRngSeed</span><span class="p">,</span> <span class="s">&quot;&#39;time&#39;|number&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--rng-seed&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;set a specific seed for random numbers&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">setColourUsage</span><span class="p">,</span> <span class="s">&quot;yes|no&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--use-colour&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;should output be colourised&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">libIdentify</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--libidentify&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;report name and version according to libidentify standard&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">setWaitForKeypress</span><span class="p">,</span> <span class="s">&quot;never|start|exit|both&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--wait-for-keypress&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;waits for a keypress before exiting&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">benchmarkSamples</span><span class="p">,</span> <span class="s">&quot;samples&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--benchmark-samples&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;number of samples to collect (default: 100)&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">benchmarkResamples</span><span class="p">,</span> <span class="s">&quot;resamples&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--benchmark-resamples&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;number of resamples for the bootstrap (default: 100000)&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">benchmarkConfidenceInterval</span><span class="p">,</span> <span class="s">&quot;confidence interval&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--benchmark-confidence-interval&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;confidence interval for the bootstrap (between 0 and 1, default: 0.95)&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">benchmarkNoAnalysis</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--benchmark-no-analysis&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;perform only measurements; do not perform any analysis&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Opt</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">benchmarkWarmupTime</span><span class="p">,</span> <span class="s">&quot;benchmarkWarmupTime&quot;</span> <span class="p">)</span>
                <span class="p">[</span><span class="s">&quot;--benchmark-warmup-time&quot;</span><span class="p">]</span>
                <span class="p">(</span> <span class="s">&quot;amount of time in milliseconds spent on warming up each test (default: 100)&quot;</span> <span class="p">)</span>
            <span class="o">|</span> <span class="n">Arg</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">testsOrTags</span><span class="p">,</span> <span class="s">&quot;test name|pattern|tags&quot;</span> <span class="p">)</span>
                <span class="p">(</span> <span class="s">&quot;which test or tests to use&quot;</span> <span class="p">);</span>

        <span class="k">return</span> <span class="n">cli</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_commandline.cpp</span>
<span class="c1">// start catch_common.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="kt">bool</span> <span class="n">SourceLineInfo</span><span class="o">::</span><span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">line</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">line</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">file</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">strcmp</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">file</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">SourceLineInfo</span><span class="o">::</span><span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="c1">// We can assume that the same file will usually have the same pointer.</span>
        <span class="c1">// Thus, if the pointers are the same, there is no point in calling the strcmp</span>
        <span class="k">return</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">line</span> <span class="o">||</span> <span class="p">(</span> <span class="n">line</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">line</span> <span class="o">&amp;&amp;</span> <span class="n">file</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">strcmp</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">file</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span> <span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef __GNUG__</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;(&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">line</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
<span class="cp">#else</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">line</span><span class="p">;</span>
<span class="cp">#endif</span>
        <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StreamEndStop</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">NonCopyable</span><span class="o">::</span><span class="n">NonCopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">NonCopyable</span><span class="o">::~</span><span class="n">NonCopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="p">}</span>
<span class="c1">// end catch_common.cpp</span>
<span class="c1">// start catch_config.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">Config</span><span class="o">::</span><span class="n">Config</span><span class="p">(</span> <span class="n">ConfigData</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">data</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_data</span><span class="p">(</span> <span class="n">data</span> <span class="p">),</span>
        <span class="n">m_stream</span><span class="p">(</span> <span class="n">openStream</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// We need to trim filter specs to avoid trouble with superfluous</span>
        <span class="c1">// whitespace (esp. important for bdd macros, as those are manually</span>
        <span class="c1">// aligned with whitespace).</span>

        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">m_data</span><span class="p">.</span><span class="n">testsOrTags</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">trim</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">m_data</span><span class="p">.</span><span class="n">sectionsToRun</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">trim</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">TestSpecParser</span> <span class="n">parser</span><span class="p">(</span><span class="n">ITagAliasRegistry</span><span class="o">::</span><span class="n">get</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_data</span><span class="p">.</span><span class="n">testsOrTags</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">m_hasTestFilters</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">testOrTags</span> <span class="p">:</span> <span class="n">m_data</span><span class="p">.</span><span class="n">testsOrTags</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">parser</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">testOrTags</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">m_testSpec</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">testSpec</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Config</span><span class="o">::</span><span class="n">getFilename</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">outputFilename</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">listTests</span><span class="p">()</span> <span class="k">const</span>          <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">listTests</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">listTestNamesOnly</span><span class="p">()</span> <span class="k">const</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">listTestNamesOnly</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">listTags</span><span class="p">()</span> <span class="k">const</span>           <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">listTags</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">listReporters</span><span class="p">()</span> <span class="k">const</span>      <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">listReporters</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Config</span><span class="o">::</span><span class="n">getProcessName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">processName</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Config</span><span class="o">::</span><span class="n">getReporterName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">reporterName</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Config</span><span class="o">::</span><span class="n">getTestsOrTags</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">testsOrTags</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Config</span><span class="o">::</span><span class="n">getSectionsToRun</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">sectionsToRun</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Config</span><span class="o">::</span><span class="n">testSpec</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_testSpec</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">hasTestFilters</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_hasTestFilters</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">showHelp</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">showHelp</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// IConfig interface</span>
    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">allowThrows</span><span class="p">()</span> <span class="k">const</span>                   <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">m_data</span><span class="p">.</span><span class="n">noThrow</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">Config</span><span class="o">::</span><span class="n">stream</span><span class="p">()</span> <span class="k">const</span>               <span class="p">{</span> <span class="k">return</span> <span class="n">m_stream</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">();</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Config</span><span class="o">::</span><span class="n">name</span><span class="p">()</span> <span class="k">const</span>                   <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="n">m_data</span><span class="p">.</span><span class="nl">processName</span> <span class="p">:</span> <span class="n">m_data</span><span class="p">.</span><span class="n">name</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">includeSuccessfulResults</span><span class="p">()</span> <span class="k">const</span>      <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">showSuccessfulTests</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">warnAboutMissingAssertions</span><span class="p">()</span> <span class="k">const</span>    <span class="p">{</span> <span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">m_data</span><span class="p">.</span><span class="n">warnings</span> <span class="o">&amp;</span> <span class="n">WarnAbout</span><span class="o">::</span><span class="n">NoAssertions</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">warnAboutNoTests</span><span class="p">()</span> <span class="k">const</span>              <span class="p">{</span> <span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">m_data</span><span class="p">.</span><span class="n">warnings</span> <span class="o">&amp;</span> <span class="n">WarnAbout</span><span class="o">::</span><span class="n">NoTests</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">ShowDurations</span><span class="o">::</span><span class="n">OrNot</span> <span class="n">Config</span><span class="o">::</span><span class="n">showDurations</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">showDurations</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">double</span> <span class="n">Config</span><span class="o">::</span><span class="n">minDuration</span><span class="p">()</span> <span class="k">const</span>                 <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">minDuration</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">RunTests</span><span class="o">::</span><span class="n">InWhatOrder</span> <span class="n">Config</span><span class="o">::</span><span class="n">runOrder</span><span class="p">()</span> <span class="k">const</span>     <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">runOrder</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Config</span><span class="o">::</span><span class="n">rngSeed</span><span class="p">()</span> <span class="k">const</span>               <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">rngSeed</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">UseColour</span><span class="o">::</span><span class="n">YesOrNo</span> <span class="n">Config</span><span class="o">::</span><span class="n">useColour</span><span class="p">()</span> <span class="k">const</span>       <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">useColour</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">shouldDebugBreak</span><span class="p">()</span> <span class="k">const</span>              <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">shouldDebugBreak</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">Config</span><span class="o">::</span><span class="n">abortAfter</span><span class="p">()</span> <span class="k">const</span>                     <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">abortAfter</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">showInvisibles</span><span class="p">()</span> <span class="k">const</span>                <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">showInvisibles</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">Verbosity</span> <span class="n">Config</span><span class="o">::</span><span class="n">verbosity</span><span class="p">()</span> <span class="k">const</span>                <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">verbosity</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">Config</span><span class="o">::</span><span class="n">benchmarkNoAnalysis</span><span class="p">()</span> <span class="k">const</span>                      <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">benchmarkNoAnalysis</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">Config</span><span class="o">::</span><span class="n">benchmarkSamples</span><span class="p">()</span> <span class="k">const</span>                          <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">benchmarkSamples</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">double</span> <span class="n">Config</span><span class="o">::</span><span class="n">benchmarkConfidenceInterval</span><span class="p">()</span> <span class="k">const</span>            <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">benchmarkConfidenceInterval</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Config</span><span class="o">::</span><span class="n">benchmarkResamples</span><span class="p">()</span> <span class="k">const</span>               <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">.</span><span class="n">benchmarkResamples</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">Config</span><span class="o">::</span><span class="n">benchmarkWarmupTime</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="n">m_data</span><span class="p">.</span><span class="n">benchmarkWarmupTime</span><span class="p">);</span> <span class="p">}</span>

    <span class="n">IStream</span> <span class="k">const</span><span class="o">*</span> <span class="n">Config</span><span class="o">::</span><span class="n">openStream</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Catch</span><span class="o">::</span><span class="n">makeStream</span><span class="p">(</span><span class="n">m_data</span><span class="p">.</span><span class="n">outputFilename</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_config.cpp</span>
<span class="c1">// start catch_console_colour.cpp</span>

<span class="cp">#if defined(__clang__)</span>
<span class="cp">#    pragma clang diagnostic push</span>
<span class="cp">#    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;</span>
<span class="cp">#endif</span>

<span class="c1">// start catch_errno_guard.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">ErrnoGuard</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">ErrnoGuard</span><span class="p">();</span>
        <span class="o">~</span><span class="n">ErrnoGuard</span><span class="p">();</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">m_oldErrno</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span>

<span class="c1">// end catch_errno_guard.h</span>
<span class="c1">// start catch_windows_h_proxy.h</span>


<span class="cp">#if defined(CATCH_PLATFORM_WINDOWS)</span>

<span class="cp">#if !defined(NOMINMAX) &amp;&amp; !defined(CATCH_CONFIG_NO_NOMINMAX)</span>
<span class="cp">#  define CATCH_DEFINED_NOMINMAX</span>
<span class="cp">#  define NOMINMAX</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined(WIN32_LEAN_AND_MEAN) &amp;&amp; !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)</span>
<span class="cp">#  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN</span>
<span class="cp">#  define WIN32_LEAN_AND_MEAN</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __AFXDLL</span>
<span class="cp">#include</span> <span class="cpf">&lt;AfxWin.h&gt;</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CATCH_DEFINED_NOMINMAX</span>
<span class="cp">#  undef NOMINMAX</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN</span>
<span class="cp">#  undef WIN32_LEAN_AND_MEAN</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="c1">// defined(CATCH_PLATFORM_WINDOWS)</span>

<span class="c1">// end catch_windows_h_proxy.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="p">{</span>

        <span class="k">struct</span> <span class="nc">IColourImpl</span> <span class="p">{</span>
            <span class="k">virtual</span> <span class="o">~</span><span class="n">IColourImpl</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
            <span class="k">virtual</span> <span class="kt">void</span> <span class="n">use</span><span class="p">(</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="n">_colourCode</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">struct</span> <span class="nc">NoColourImpl</span> <span class="o">:</span> <span class="n">IColourImpl</span> <span class="p">{</span>
            <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{}</span>

            <span class="k">static</span> <span class="n">IColourImpl</span><span class="o">*</span> <span class="n">instance</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">static</span> <span class="n">NoColourImpl</span> <span class="n">s_instance</span><span class="p">;</span>
                <span class="k">return</span> <span class="o">&amp;</span><span class="n">s_instance</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

    <span class="p">}</span> <span class="c1">// anon namespace</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="cp">#if !defined( CATCH_CONFIG_COLOUR_NONE ) &amp;&amp; !defined( CATCH_CONFIG_COLOUR_WINDOWS ) &amp;&amp; !defined( CATCH_CONFIG_COLOUR_ANSI )</span>
<span class="cp">#   ifdef CATCH_PLATFORM_WINDOWS</span>
<span class="cp">#       define CATCH_CONFIG_COLOUR_WINDOWS</span>
<span class="cp">#   else</span>
<span class="cp">#       define CATCH_CONFIG_COLOUR_ANSI</span>
<span class="cp">#   endif</span>
<span class="cp">#endif</span>

<span class="cp">#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) </span><span class="c1">/////////////////////////////////////////</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">Win32ColourImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IColourImpl</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Win32ColourImpl</span><span class="p">()</span> <span class="o">:</span> <span class="n">stdoutHandle</span><span class="p">(</span> <span class="n">GetStdHandle</span><span class="p">(</span><span class="n">STD_OUTPUT_HANDLE</span><span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">CONSOLE_SCREEN_BUFFER_INFO</span> <span class="n">csbiInfo</span><span class="p">;</span>
            <span class="n">GetConsoleScreenBufferInfo</span><span class="p">(</span> <span class="n">stdoutHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">csbiInfo</span> <span class="p">);</span>
            <span class="n">originalForegroundAttributes</span> <span class="o">=</span> <span class="n">csbiInfo</span><span class="p">.</span><span class="n">wAttributes</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span> <span class="n">BACKGROUND_GREEN</span> <span class="o">|</span> <span class="n">BACKGROUND_RED</span> <span class="o">|</span> <span class="n">BACKGROUND_BLUE</span> <span class="o">|</span> <span class="n">BACKGROUND_INTENSITY</span> <span class="p">);</span>
            <span class="n">originalBackgroundAttributes</span> <span class="o">=</span> <span class="n">csbiInfo</span><span class="p">.</span><span class="n">wAttributes</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span> <span class="n">FOREGROUND_GREEN</span> <span class="o">|</span> <span class="n">FOREGROUND_RED</span> <span class="o">|</span> <span class="n">FOREGROUND_BLUE</span> <span class="o">|</span> <span class="n">FOREGROUND_INTENSITY</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">use</span><span class="p">(</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="n">_colourCode</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">switch</span><span class="p">(</span> <span class="n">_colourCode</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">None</span><span class="p">:</span>      <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">originalForegroundAttributes</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">White</span><span class="p">:</span>     <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_GREEN</span> <span class="o">|</span> <span class="n">FOREGROUND_RED</span> <span class="o">|</span> <span class="n">FOREGROUND_BLUE</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Red</span><span class="p">:</span>       <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_RED</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Green</span><span class="p">:</span>     <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_GREEN</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Blue</span><span class="p">:</span>      <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_BLUE</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Cyan</span><span class="p">:</span>      <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_BLUE</span> <span class="o">|</span> <span class="n">FOREGROUND_GREEN</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Yellow</span><span class="p">:</span>    <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_RED</span> <span class="o">|</span> <span class="n">FOREGROUND_GREEN</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Grey</span><span class="p">:</span>      <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>

                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">LightGrey</span><span class="p">:</span>     <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_INTENSITY</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">BrightRed</span><span class="p">:</span>     <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_INTENSITY</span> <span class="o">|</span> <span class="n">FOREGROUND_RED</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">BrightGreen</span><span class="p">:</span>   <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_INTENSITY</span> <span class="o">|</span> <span class="n">FOREGROUND_GREEN</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">BrightWhite</span><span class="p">:</span>   <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_INTENSITY</span> <span class="o">|</span> <span class="n">FOREGROUND_GREEN</span> <span class="o">|</span> <span class="n">FOREGROUND_RED</span> <span class="o">|</span> <span class="n">FOREGROUND_BLUE</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">BrightYellow</span><span class="p">:</span>  <span class="k">return</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">FOREGROUND_INTENSITY</span> <span class="o">|</span> <span class="n">FOREGROUND_RED</span> <span class="o">|</span> <span class="n">FOREGROUND_GREEN</span> <span class="p">);</span>

                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Bright</span><span class="p">:</span> <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span> <span class="s">&quot;not a colour&quot;</span> <span class="p">);</span>

                <span class="k">default</span><span class="o">:</span>
                    <span class="n">CATCH_ERROR</span><span class="p">(</span> <span class="s">&quot;Unknown colour requested&quot;</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">setTextAttribute</span><span class="p">(</span> <span class="n">WORD</span> <span class="n">_textAttribute</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">SetConsoleTextAttribute</span><span class="p">(</span> <span class="n">stdoutHandle</span><span class="p">,</span> <span class="n">_textAttribute</span> <span class="o">|</span> <span class="n">originalBackgroundAttributes</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">HANDLE</span> <span class="n">stdoutHandle</span><span class="p">;</span>
        <span class="n">WORD</span> <span class="n">originalForegroundAttributes</span><span class="p">;</span>
        <span class="n">WORD</span> <span class="n">originalBackgroundAttributes</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">IColourImpl</span><span class="o">*</span> <span class="nf">platformColourInstance</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">Win32ColourImpl</span> <span class="n">s_instance</span><span class="p">;</span>

        <span class="n">IConfigPtr</span> <span class="n">config</span> <span class="o">=</span> <span class="n">getCurrentContext</span><span class="p">().</span><span class="n">getConfig</span><span class="p">();</span>
        <span class="n">UseColour</span><span class="o">::</span><span class="n">YesOrNo</span> <span class="n">colourMode</span> <span class="o">=</span> <span class="n">config</span>
            <span class="o">?</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">useColour</span><span class="p">()</span>
            <span class="o">:</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">Auto</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">colourMode</span> <span class="o">==</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">Auto</span> <span class="p">)</span>
            <span class="n">colourMode</span> <span class="o">=</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">Yes</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">colourMode</span> <span class="o">==</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">Yes</span>
            <span class="o">?</span> <span class="o">&amp;</span><span class="nl">s_instance</span>
            <span class="p">:</span> <span class="n">NoColourImpl</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end anon namespace</span>
<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#elif defined( CATCH_CONFIG_COLOUR_ANSI ) </span><span class="c1">//////////////////////////////////////</span>

<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>

    <span class="c1">// use POSIX/ ANSI console terminal codes</span>
    <span class="c1">// Thanks to Adam Strzelecki for original contribution</span>
    <span class="c1">// (http://github.com/nanoant)</span>
    <span class="c1">// https://github.com/philsquared/Catch/pull/131</span>
    <span class="k">class</span> <span class="nc">PosixColourImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IColourImpl</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">use</span><span class="p">(</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="n">_colourCode</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">switch</span><span class="p">(</span> <span class="n">_colourCode</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">None</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">White</span><span class="p">:</span>     <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[0m&quot;</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Red</span><span class="p">:</span>       <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[0;31m&quot;</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Green</span><span class="p">:</span>     <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[0;32m&quot;</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Blue</span><span class="p">:</span>      <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[0;34m&quot;</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Cyan</span><span class="p">:</span>      <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[0;36m&quot;</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Yellow</span><span class="p">:</span>    <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[0;33m&quot;</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Grey</span><span class="p">:</span>      <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[1;30m&quot;</span> <span class="p">);</span>

                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">LightGrey</span><span class="p">:</span>     <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[0;37m&quot;</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">BrightRed</span><span class="p">:</span>     <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[1;31m&quot;</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">BrightGreen</span><span class="p">:</span>   <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[1;32m&quot;</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">BrightWhite</span><span class="p">:</span>   <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[1;37m&quot;</span> <span class="p">);</span>
                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">BrightYellow</span><span class="p">:</span>  <span class="k">return</span> <span class="n">setColour</span><span class="p">(</span> <span class="s">&quot;[1;33m&quot;</span> <span class="p">);</span>

                <span class="k">case</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">Bright</span><span class="p">:</span> <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span> <span class="s">&quot;not a colour&quot;</span> <span class="p">);</span>
                <span class="k">default</span><span class="o">:</span> <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span> <span class="s">&quot;Unknown colour requested&quot;</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">static</span> <span class="n">IColourImpl</span><span class="o">*</span> <span class="n">instance</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">static</span> <span class="n">PosixColourImpl</span> <span class="n">s_instance</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">s_instance</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">setColour</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">_escapeCode</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">getCurrentContext</span><span class="p">().</span><span class="n">getConfig</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="sc">&#39;\033&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">_escapeCode</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">bool</span> <span class="nf">useColourOnPlatform</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span>
<span class="cp">#if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)</span>
            <span class="o">!</span><span class="n">isDebuggerActive</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
<span class="cp">#endif</span>
<span class="cp">#if !(defined(__DJGPP__) &amp;&amp; defined(__STRICT_ANSI__))</span>
            <span class="n">isatty</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">)</span>
<span class="cp">#else</span>
            <span class="nb">false</span>
<span class="cp">#endif</span>
            <span class="p">;</span>
    <span class="p">}</span>
    <span class="n">IColourImpl</span><span class="o">*</span> <span class="nf">platformColourInstance</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">ErrnoGuard</span> <span class="n">guard</span><span class="p">;</span>
        <span class="n">IConfigPtr</span> <span class="n">config</span> <span class="o">=</span> <span class="n">getCurrentContext</span><span class="p">().</span><span class="n">getConfig</span><span class="p">();</span>
        <span class="n">UseColour</span><span class="o">::</span><span class="n">YesOrNo</span> <span class="n">colourMode</span> <span class="o">=</span> <span class="n">config</span>
            <span class="o">?</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">useColour</span><span class="p">()</span>
            <span class="o">:</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">Auto</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">colourMode</span> <span class="o">==</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">Auto</span> <span class="p">)</span>
            <span class="n">colourMode</span> <span class="o">=</span> <span class="n">useColourOnPlatform</span><span class="p">()</span>
                <span class="o">?</span> <span class="n">UseColour</span><span class="o">::</span><span class="nl">Yes</span>
                <span class="p">:</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">No</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">colourMode</span> <span class="o">==</span> <span class="n">UseColour</span><span class="o">::</span><span class="n">Yes</span>
            <span class="o">?</span> <span class="n">PosixColourImpl</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
            <span class="o">:</span> <span class="n">NoColourImpl</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end anon namespace</span>
<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#else  </span><span class="c1">// not Windows or ANSI ///////////////////////////////////////////////</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">static</span> <span class="n">IColourImpl</span><span class="o">*</span> <span class="n">platformColourInstance</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">NoColourImpl</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span> <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#endif </span><span class="c1">// Windows/ ANSI/ None</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">Colour</span><span class="o">::</span><span class="n">Colour</span><span class="p">(</span> <span class="n">Code</span> <span class="n">_colourCode</span> <span class="p">)</span> <span class="p">{</span> <span class="n">use</span><span class="p">(</span> <span class="n">_colourCode</span> <span class="p">);</span> <span class="p">}</span>
    <span class="n">Colour</span><span class="o">::</span><span class="n">Colour</span><span class="p">(</span> <span class="n">Colour</span><span class="o">&amp;&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">m_moved</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_moved</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">m_moved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Colour</span><span class="o">&amp;</span> <span class="n">Colour</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">Colour</span><span class="o">&amp;&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">m_moved</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_moved</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">m_moved</span>  <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Colour</span><span class="o">::~</span><span class="n">Colour</span><span class="p">(){</span> <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">m_moved</span> <span class="p">)</span> <span class="n">use</span><span class="p">(</span> <span class="n">None</span> <span class="p">);</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Colour</span><span class="o">::</span><span class="n">use</span><span class="p">(</span> <span class="n">Code</span> <span class="n">_colourCode</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">IColourImpl</span><span class="o">*</span> <span class="n">impl</span> <span class="o">=</span> <span class="n">platformColourInstance</span><span class="p">();</span>
        <span class="c1">// Strictly speaking, this cannot possibly happen.</span>
        <span class="c1">// However, under some conditions it does happen (see #1626),</span>
        <span class="c1">// and this change is small enough that we can let practicality</span>
        <span class="c1">// triumph over purity in this case.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">impl</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">impl</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">(</span> <span class="n">_colourCode</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">Colour</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#if defined(__clang__)</span>
<span class="cp">#    pragma clang diagnostic pop</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_console_colour.cpp</span>
<span class="c1">// start catch_context.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">Context</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IMutableContext</span><span class="p">,</span> <span class="n">NonCopyable</span> <span class="p">{</span>

    <span class="k">public</span><span class="o">:</span> <span class="c1">// IContext</span>
        <span class="n">IResultCapture</span><span class="o">*</span> <span class="n">getResultCapture</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_resultCapture</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">IRunner</span><span class="o">*</span> <span class="n">getRunner</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_runner</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getConfig</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_config</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">Context</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span> <span class="c1">// IMutableContext</span>
        <span class="kt">void</span> <span class="n">setResultCapture</span><span class="p">(</span> <span class="n">IResultCapture</span><span class="o">*</span> <span class="n">resultCapture</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">m_resultCapture</span> <span class="o">=</span> <span class="n">resultCapture</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">setRunner</span><span class="p">(</span> <span class="n">IRunner</span><span class="o">*</span> <span class="n">runner</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">m_runner</span> <span class="o">=</span> <span class="n">runner</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">setConfig</span><span class="p">(</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
            <span class="n">m_config</span> <span class="o">=</span> <span class="n">config</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">friend</span> <span class="n">IMutableContext</span><span class="o">&amp;</span> <span class="n">getCurrentMutableContext</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">IConfigPtr</span> <span class="n">m_config</span><span class="p">;</span>
        <span class="n">IRunner</span><span class="o">*</span> <span class="n">m_runner</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">IResultCapture</span><span class="o">*</span> <span class="n">m_resultCapture</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">IMutableContext</span> <span class="o">*</span><span class="n">IMutableContext</span><span class="o">::</span><span class="n">currentContext</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">IMutableContext</span><span class="o">::</span><span class="n">createContext</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">currentContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Context</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">cleanUpContext</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="n">IMutableContext</span><span class="o">::</span><span class="n">currentContext</span><span class="p">;</span>
        <span class="n">IMutableContext</span><span class="o">::</span><span class="n">currentContext</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">IContext</span><span class="o">::~</span><span class="n">IContext</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">IMutableContext</span><span class="o">::~</span><span class="n">IMutableContext</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Context</span><span class="o">::~</span><span class="n">Context</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">SimplePcg32</span><span class="o">&amp;</span> <span class="nf">rng</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">SimplePcg32</span> <span class="n">s_rng</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">s_rng</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="c1">// end catch_context.cpp</span>
<span class="c1">// start catch_debug_console.cpp</span>

<span class="c1">// start catch_debug_console.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">writeToDebugConsole</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// end catch_debug_console.h</span>
<span class="cp">#if defined(CATCH_CONFIG_ANDROID_LOGWRITE)</span>
<span class="cp">#include</span> <span class="cpf">&lt;android/log.h&gt;</span><span class="cp"></span>

    <span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="nf">writeToDebugConsole</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">__android_log_write</span><span class="p">(</span> <span class="n">ANDROID_LOG_DEBUG</span><span class="p">,</span> <span class="s">&quot;Catch&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="cp">#elif defined(CATCH_PLATFORM_WINDOWS)</span>

    <span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="nf">writeToDebugConsole</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">::</span><span class="n">OutputDebugStringA</span><span class="p">(</span> <span class="n">text</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="cp">#else</span>

    <span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="nf">writeToDebugConsole</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span> <span class="p">)</span> <span class="p">{</span>
            <span class="c1">// !TBD: Need a version for Mac/ XCode and other IDEs</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">text</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="cp">#endif </span><span class="c1">// Platform</span>
<span class="c1">// end catch_debug_console.cpp</span>
<span class="c1">// start catch_debugger.cpp</span>

<span class="cp">#if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)</span>

<span class="cp">#  include &lt;cassert&gt;</span>
<span class="cp">#  include &lt;sys/types.h&gt;</span>
<span class="cp">#  include &lt;unistd.h&gt;</span>
<span class="cp">#  include &lt;cstddef&gt;</span>
<span class="cp">#  include &lt;ostream&gt;</span>

<span class="cp">#ifdef __apple_build_version__</span>
    <span class="c1">// These headers will only compile with AppleClang (XCode)</span>
    <span class="c1">// For other compilers (Clang, GCC, ... ) we need to exclude them</span>
<span class="cp">#  include &lt;sys/sysctl.h&gt;</span>
<span class="cp">#endif</span>

    <span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
        <span class="cp">#ifdef __apple_build_version__</span>
        <span class="c1">// The following function is taken directly from the following technical note:</span>
        <span class="c1">// https://developer.apple.com/library/archive/qa/qa1361/_index.html</span>

        <span class="c1">// Returns true if the current process is being debugged (either</span>
        <span class="c1">// running under the debugger or has a debugger attached post facto).</span>
        <span class="kt">bool</span> <span class="nf">isDebuggerActive</span><span class="p">(){</span>
            <span class="kt">int</span>                 <span class="n">mib</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
            <span class="k">struct</span> <span class="nc">kinfo_proc</span>   <span class="n">info</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span>         <span class="n">size</span><span class="p">;</span>

            <span class="c1">// Initialize the flags so that, if sysctl fails for some bizarre</span>
            <span class="c1">// reason, we get a predictable result.</span>

            <span class="n">info</span><span class="p">.</span><span class="n">kp_proc</span><span class="p">.</span><span class="n">p_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="c1">// Initialize mib, which tells sysctl the info we want, in this case</span>
            <span class="c1">// we&#39;re looking for information about a specific process ID.</span>

            <span class="n">mib</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CTL_KERN</span><span class="p">;</span>
            <span class="n">mib</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">KERN_PROC</span><span class="p">;</span>
            <span class="n">mib</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">KERN_PROC_PID</span><span class="p">;</span>
            <span class="n">mib</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>

            <span class="c1">// Call sysctl.</span>

            <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">sysctl</span><span class="p">(</span><span class="n">mib</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mib</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mib</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">Catch</span><span class="o">::</span><span class="n">cerr</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">** Call to sysctl failed - unable to determine if debugger is active **</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// We&#39;re being debugged if the P_TRACED flag is set.</span>

            <span class="k">return</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">kp_proc</span><span class="p">.</span><span class="n">p_flag</span> <span class="o">&amp;</span> <span class="n">P_TRACED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="cp">#else</span>
        <span class="kt">bool</span> <span class="nf">isDebuggerActive</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// We need to find another way to determine this for non-appleclang compilers on macOS</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cp">#endif</span>
    <span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="cp">#elif defined(CATCH_PLATFORM_LINUX)</span>
    <span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

    <span class="k">namespace</span> <span class="n">Catch</span><span class="p">{</span>
        <span class="c1">// The standard POSIX way of detecting a debugger is to attempt to</span>
        <span class="c1">// ptrace() the process, but this needs to be done from a child and not</span>
        <span class="c1">// this process itself to still allow attaching to this process later</span>
        <span class="c1">// if wanted, so is rather heavy. Under Linux we have the PID of the</span>
        <span class="c1">// &quot;debugger&quot; (which doesn&#39;t need to be gdb, of course, it could also</span>
        <span class="c1">// be strace, for example) in /proc/$PID/status, so just get it from</span>
        <span class="c1">// there instead.</span>
        <span class="kt">bool</span> <span class="nf">isDebuggerActive</span><span class="p">(){</span>
            <span class="c1">// Libstdc++ has a bug, where std::ifstream sets errno to 0</span>
            <span class="c1">// This way our users can properly assert over errno values</span>
            <span class="n">ErrnoGuard</span> <span class="n">guard</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">in</span><span class="p">(</span><span class="s">&quot;/proc/self/status&quot;</span><span class="p">);</span>
            <span class="k">for</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">PREFIX_LEN</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">line</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PREFIX_LEN</span><span class="p">,</span> <span class="s">&quot;TracerPid:</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// We&#39;re traced if the PID is not 0 and no other PID starts</span>
                    <span class="c1">// with 0 digit, so it&#39;s enough to check for just a single</span>
                    <span class="c1">// character.</span>
                    <span class="k">return</span> <span class="n">line</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">PREFIX_LEN</span> <span class="o">&amp;&amp;</span> <span class="n">line</span><span class="p">[</span><span class="n">PREFIX_LEN</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="cp">#elif defined(_MSC_VER)</span>
    <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span> <span class="kt">int</span> <span class="kr">__stdcall</span> <span class="n">IsDebuggerPresent</span><span class="p">();</span>
    <span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="nf">isDebuggerActive</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">IsDebuggerPresent</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="cp">#elif defined(__MINGW32__)</span>
    <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span> <span class="kt">int</span> <span class="kr">__stdcall</span> <span class="n">IsDebuggerPresent</span><span class="p">();</span>
    <span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="nf">isDebuggerActive</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">IsDebuggerPresent</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="cp">#else</span>
    <span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
       <span class="kt">bool</span> <span class="nf">isDebuggerActive</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// Platform</span>
<span class="c1">// end catch_debugger.cpp</span>
<span class="c1">// start catch_decomposer.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">ITransientExpression</span><span class="o">::~</span><span class="n">ITransientExpression</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">formatReconstructedExpression</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">op</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">lhs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">40</span> <span class="o">&amp;&amp;</span>
                <span class="n">lhs</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="o">&amp;&amp;</span>
                <span class="n">rhs</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="p">)</span>
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">lhs</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">op</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">rhs</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">lhs</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">op</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// end catch_decomposer.cpp</span>
<span class="c1">// start catch_enforce.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="cp">#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) &amp;&amp; !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)</span>
    <span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">throw_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">cerr</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Catch will terminate because it needed to throw an exception.</span><span class="se">\n</span><span class="s">&quot;</span>
                      <span class="o">&lt;&lt;</span> <span class="s">&quot;The message was: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">terminate</span><span class="p">();</span>
    <span class="p">}</span>
<span class="cp">#endif</span>

    <span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">throw_logic_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">throw_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">throw_domain_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">throw_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">throw_runtime_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">throw_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Catch;</span>
<span class="c1">// end catch_enforce.cpp</span>
<span class="c1">// start catch_enum_values_registry.cpp</span>
<span class="c1">// start catch_enum_values_registry.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>

        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EnumInfo</span><span class="o">&gt;</span> <span class="n">makeEnumInfo</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">enumName</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">allValueNames</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">values</span> <span class="p">);</span>

        <span class="k">class</span> <span class="nc">EnumValuesRegistry</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IMutableEnumValuesRegistry</span> <span class="p">{</span>

            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EnumInfo</span><span class="o">&gt;&gt;</span> <span class="n">m_enumInfos</span><span class="p">;</span>

            <span class="n">EnumInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">registerEnum</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">enumName</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">allEnums</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">values</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">StringRef</span><span class="o">&gt;</span> <span class="n">parseEnums</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">enums</span> <span class="p">);</span>

    <span class="p">}</span> <span class="c1">// Detail</span>

<span class="p">}</span> <span class="c1">// Catch</span>

<span class="c1">// end catch_enum_values_registry.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">IMutableEnumValuesRegistry</span><span class="o">::~</span><span class="n">IMutableEnumValuesRegistry</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>

        <span class="k">namespace</span> <span class="p">{</span>
            <span class="c1">// Extracts the actual name part of an enum instance</span>
            <span class="c1">// In other words, it returns the Blue part of Bikeshed::Colour::Blue</span>
            <span class="n">StringRef</span> <span class="nf">extractInstanceName</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">enumInstance</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Find last occurrence of &quot;:&quot;</span>
                <span class="kt">size_t</span> <span class="n">name_start</span> <span class="o">=</span> <span class="n">enumInstance</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">name_start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">enumInstance</span><span class="p">[</span><span class="n">name_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;:&#39;</span><span class="p">)</span> <span class="p">{</span>
                    <span class="o">--</span><span class="n">name_start</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">enumInstance</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">name_start</span><span class="p">,</span> <span class="n">enumInstance</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">name_start</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">StringRef</span><span class="o">&gt;</span> <span class="n">parseEnums</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">enums</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">enumValues</span> <span class="o">=</span> <span class="n">splitStringRef</span><span class="p">(</span> <span class="n">enums</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span> <span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">StringRef</span><span class="o">&gt;</span> <span class="n">parsed</span><span class="p">;</span>
            <span class="n">parsed</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="n">enumValues</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">enumValue</span> <span class="p">:</span> <span class="n">enumValues</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">parsed</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">trim</span><span class="p">(</span><span class="n">extractInstanceName</span><span class="p">(</span><span class="n">enumValue</span><span class="p">)));</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">parsed</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">EnumInfo</span><span class="o">::~</span><span class="n">EnumInfo</span><span class="p">()</span> <span class="p">{}</span>

        <span class="n">StringRef</span> <span class="n">EnumInfo</span><span class="o">::</span><span class="n">lookup</span><span class="p">(</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">valueToName</span> <span class="p">:</span> <span class="n">m_values</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">valueToName</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">value</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="n">valueToName</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="s">&quot;{** unexpected enum value **}&quot;</span><span class="n">_sr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EnumInfo</span><span class="o">&gt;</span> <span class="n">makeEnumInfo</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">enumName</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">allValueNames</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">values</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EnumInfo</span><span class="o">&gt;</span> <span class="n">enumInfo</span><span class="p">(</span> <span class="k">new</span> <span class="n">EnumInfo</span> <span class="p">);</span>
            <span class="n">enumInfo</span><span class="o">-&gt;</span><span class="n">m_name</span> <span class="o">=</span> <span class="n">enumName</span><span class="p">;</span>
            <span class="n">enumInfo</span><span class="o">-&gt;</span><span class="n">m_values</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

            <span class="k">const</span> <span class="k">auto</span> <span class="n">valueNames</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">parseEnums</span><span class="p">(</span> <span class="n">allValueNames</span> <span class="p">);</span>
            <span class="n">assert</span><span class="p">(</span> <span class="n">valueNames</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="nl">value</span> <span class="p">:</span> <span class="n">values</span> <span class="p">)</span>
                <span class="n">enumInfo</span><span class="o">-&gt;</span><span class="n">m_values</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">valueNames</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>

            <span class="k">return</span> <span class="n">enumInfo</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">EnumInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">EnumValuesRegistry</span><span class="o">::</span><span class="n">registerEnum</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">enumName</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">allValueNames</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">values</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_enumInfos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">makeEnumInfo</span><span class="p">(</span><span class="n">enumName</span><span class="p">,</span> <span class="n">allValueNames</span><span class="p">,</span> <span class="n">values</span><span class="p">));</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">m_enumInfos</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="c1">// Detail</span>
<span class="p">}</span> <span class="c1">// Catch</span>

<span class="c1">// end catch_enum_values_registry.cpp</span>
<span class="c1">// start catch_errno_guard.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cerrno&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
        <span class="n">ErrnoGuard</span><span class="o">::</span><span class="n">ErrnoGuard</span><span class="p">()</span><span class="o">:</span><span class="n">m_oldErrno</span><span class="p">(</span><span class="n">errno</span><span class="p">){}</span>
        <span class="n">ErrnoGuard</span><span class="o">::~</span><span class="n">ErrnoGuard</span><span class="p">()</span> <span class="p">{</span> <span class="n">errno</span> <span class="o">=</span> <span class="n">m_oldErrno</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// end catch_errno_guard.cpp</span>
<span class="c1">// start catch_exception_translator_registry.cpp</span>

<span class="c1">// start catch_exception_translator_registry.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">ExceptionTranslatorRegistry</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IExceptionTranslatorRegistry</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="o">~</span><span class="n">ExceptionTranslatorRegistry</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">registerTranslator</span><span class="p">(</span> <span class="k">const</span> <span class="n">IExceptionTranslator</span><span class="o">*</span> <span class="n">translator</span> <span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">translateActiveException</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tryTranslators</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IExceptionTranslator</span> <span class="k">const</span><span class="o">&gt;&gt;</span> <span class="n">m_translators</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// end catch_exception_translator_registry.h</span>
<span class="cp">#ifdef __OBJC__</span>
<span class="cp">#import &quot;Foundation/Foundation.h&quot;</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">ExceptionTranslatorRegistry</span><span class="o">::~</span><span class="n">ExceptionTranslatorRegistry</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ExceptionTranslatorRegistry</span><span class="o">::</span><span class="n">registerTranslator</span><span class="p">(</span> <span class="k">const</span> <span class="n">IExceptionTranslator</span><span class="o">*</span> <span class="n">translator</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_translators</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">IExceptionTranslator</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">translator</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ExceptionTranslatorRegistry</span><span class="o">::</span><span class="n">translateActiveException</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
<span class="cp">#ifdef __OBJC__</span>
            <span class="c1">// In Objective-C try objective-c exceptions first</span>
            <span class="err">@</span><span class="k">try</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">tryTranslators</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="err">@</span><span class="k">catch</span> <span class="p">(</span><span class="n">NSException</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="p">[</span><span class="n">exception</span> <span class="n">description</span><span class="p">]</span> <span class="p">);</span>
            <span class="p">}</span>
<span class="cp">#else</span>
            <span class="c1">// Compiling a mixed mode project with MSVC means that CLR</span>
            <span class="c1">// exceptions will be caught in (...) as well. However, these</span>
            <span class="c1">// do not fill-in std::current_exception and thus lead to crash</span>
            <span class="c1">// when attempting rethrow.</span>
            <span class="c1">// /EHa switch also causes structured exceptions to be caught</span>
            <span class="c1">// here, but they fill-in current_exception properly, so</span>
            <span class="c1">// at worst the output should be a little weird, instead of</span>
            <span class="c1">// causing a crash.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">()</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="s">&quot;Non C++ exception. Possibly a CLR exception.&quot;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">tryTranslators</span><span class="p">();</span>
<span class="cp">#endif</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span> <span class="n">TestFailureException</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">msg</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">msg</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(...)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;Unknown exception&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ExceptionTranslatorRegistry</span><span class="o">::</span><span class="n">tryTranslators</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_translators</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_translators</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">translate</span><span class="p">(</span><span class="n">m_translators</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m_translators</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="cp">#else </span><span class="c1">// ^^ Exceptions are enabled // Exceptions are disabled vv</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ExceptionTranslatorRegistry</span><span class="o">::</span><span class="n">translateActiveException</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span><span class="s">&quot;Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ExceptionTranslatorRegistry</span><span class="o">::</span><span class="n">tryTranslators</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span><span class="s">&quot;Attempted to use exception translators under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif</span>

<span class="p">}</span>
<span class="c1">// end catch_exception_translator_registry.cpp</span>
<span class="c1">// start catch_fatal_condition.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="cp">#if !defined( CATCH_CONFIG_WINDOWS_SEH ) &amp;&amp; !defined( CATCH_CONFIG_POSIX_SIGNALS )</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="c1">// If neither SEH nor signal handling is required, the handler impls</span>
    <span class="c1">// do not have to do anything, and can be empty.</span>
    <span class="kt">void</span> <span class="n">FatalConditionHandler</span><span class="o">::</span><span class="n">engage_platform</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">FatalConditionHandler</span><span class="o">::</span><span class="n">disengage_platform</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">FatalConditionHandler</span><span class="o">::</span><span class="n">FatalConditionHandler</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">FatalConditionHandler</span><span class="o">::~</span><span class="n">FatalConditionHandler</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#endif </span><span class="c1">// !CATCH_CONFIG_WINDOWS_SEH &amp;&amp; !CATCH_CONFIG_POSIX_SIGNALS</span>

<span class="cp">#if defined( CATCH_CONFIG_WINDOWS_SEH ) &amp;&amp; defined( CATCH_CONFIG_POSIX_SIGNALS )</span>
<span class="cp">#error &quot;Inconsistent configuration: Windows&#39; SEH handling and POSIX signals cannot be enabled at the same time&quot;</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_WINDOWS_SEH &amp;&amp; CATCH_CONFIG_POSIX_SIGNALS</span>

<span class="cp">#if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="c1">//! Signals fatal error message to the run context</span>
    <span class="kt">void</span> <span class="nf">reportFatal</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">message</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">getCurrentContext</span><span class="p">().</span><span class="n">getResultCapture</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">handleFatalErrorCondition</span><span class="p">(</span> <span class="n">message</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">//! Minimal size Catch2 needs for its own fatal error handling.</span>
    <span class="c1">//! Picked anecdotally, so it might not be sufficient on all</span>
    <span class="c1">//! platforms, and for all configurations.</span>
    <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">minStackSizeForErrors</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// end unnamed namespace</span>

<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_WINDOWS_SEH || CATCH_CONFIG_POSIX_SIGNALS</span>

<span class="cp">#if defined( CATCH_CONFIG_WINDOWS_SEH )</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">SignalDefs</span> <span class="p">{</span> <span class="n">DWORD</span> <span class="n">id</span><span class="p">;</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span> <span class="p">};</span>

    <span class="c1">// There is no 1-1 mapping between signals and windows exceptions.</span>
    <span class="c1">// Windows can easily distinguish between SO and SigSegV,</span>
    <span class="c1">// but SigInt, SigTerm, etc are handled differently.</span>
    <span class="k">static</span> <span class="n">SignalDefs</span> <span class="n">signalDefs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DWORD</span><span class="o">&gt;</span><span class="p">(</span><span class="n">EXCEPTION_ILLEGAL_INSTRUCTION</span><span class="p">),</span>  <span class="s">&quot;SIGILL - Illegal instruction signal&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DWORD</span><span class="o">&gt;</span><span class="p">(</span><span class="n">EXCEPTION_STACK_OVERFLOW</span><span class="p">),</span> <span class="s">&quot;SIGSEGV - Stack overflow&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DWORD</span><span class="o">&gt;</span><span class="p">(</span><span class="n">EXCEPTION_ACCESS_VIOLATION</span><span class="p">),</span> <span class="s">&quot;SIGSEGV - Segmentation violation signal&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DWORD</span><span class="o">&gt;</span><span class="p">(</span><span class="n">EXCEPTION_INT_DIVIDE_BY_ZERO</span><span class="p">),</span> <span class="s">&quot;Divide by zero error&quot;</span> <span class="p">},</span>
    <span class="p">};</span>

    <span class="k">static</span> <span class="n">LONG</span> <span class="n">CALLBACK</span> <span class="n">handleVectoredException</span><span class="p">(</span><span class="n">PEXCEPTION_POINTERS</span> <span class="n">ExceptionInfo</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">def</span> <span class="p">:</span> <span class="n">signalDefs</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ExceptionInfo</span><span class="o">-&gt;</span><span class="n">ExceptionRecord</span><span class="o">-&gt;</span><span class="n">ExceptionCode</span> <span class="o">==</span> <span class="n">def</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">reportFatal</span><span class="p">(</span><span class="n">def</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// If its not an exception we care about, pass it along.</span>
        <span class="c1">// This stops us from eating debugger breaks etc.</span>
        <span class="k">return</span> <span class="n">EXCEPTION_CONTINUE_SEARCH</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Since we do not support multiple instantiations, we put these</span>
    <span class="c1">// into global variables and rely on cleaning them up in outlined</span>
    <span class="c1">// constructors/destructors</span>
    <span class="k">static</span> <span class="n">PVOID</span> <span class="n">exceptionHandlerHandle</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="c1">// For MSVC, we reserve part of the stack memory for handling</span>
    <span class="c1">// memory overflow structured exception.</span>
    <span class="n">FatalConditionHandler</span><span class="o">::</span><span class="n">FatalConditionHandler</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">ULONG</span> <span class="n">guaranteeSize</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ULONG</span><span class="o">&gt;</span><span class="p">(</span><span class="n">minStackSizeForErrors</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetThreadStackGuarantee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">guaranteeSize</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// We do not want to fully error out, because needing</span>
            <span class="c1">// the stack reserve should be rare enough anyway.</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cerr</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;Failed to reserve piece of stack.&quot;</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot; Stack overflows will not be reported successfully.&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// We do not attempt to unset the stack guarantee, because</span>
    <span class="c1">// Windows does not support lowering the stack size guarantee.</span>
    <span class="n">FatalConditionHandler</span><span class="o">::~</span><span class="n">FatalConditionHandler</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">FatalConditionHandler</span><span class="o">::</span><span class="n">engage_platform</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Register as first handler in current chain</span>
        <span class="n">exceptionHandlerHandle</span> <span class="o">=</span> <span class="n">AddVectoredExceptionHandler</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">handleVectoredException</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exceptionHandlerHandle</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">CATCH_RUNTIME_ERROR</span><span class="p">(</span><span class="s">&quot;Could not register vectored exception handler&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">FatalConditionHandler</span><span class="o">::</span><span class="n">disengage_platform</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RemoveVectoredExceptionHandler</span><span class="p">(</span><span class="n">exceptionHandlerHandle</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">CATCH_RUNTIME_ERROR</span><span class="p">(</span><span class="s">&quot;Could not unregister vectored exception handler&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">exceptionHandlerHandle</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_WINDOWS_SEH</span>

<span class="cp">#if defined( CATCH_CONFIG_POSIX_SIGNALS )</span>

<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">SignalDefs</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">static</span> <span class="n">SignalDefs</span> <span class="n">signalDefs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">SIGINT</span><span class="p">,</span>  <span class="s">&quot;SIGINT - Terminal interrupt signal&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">SIGILL</span><span class="p">,</span>  <span class="s">&quot;SIGILL - Illegal instruction signal&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">SIGFPE</span><span class="p">,</span>  <span class="s">&quot;SIGFPE - Floating point error signal&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="s">&quot;SIGSEGV - Segmentation violation signal&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">SIGTERM</span><span class="p">,</span> <span class="s">&quot;SIGTERM - Termination request signal&quot;</span> <span class="p">},</span>
        <span class="p">{</span> <span class="n">SIGABRT</span><span class="p">,</span> <span class="s">&quot;SIGABRT - Abort (abnormal termination) signal&quot;</span> <span class="p">}</span>
    <span class="p">};</span>

<span class="c1">// Older GCCs trigger -Wmissing-field-initializers for T foo = {}</span>
<span class="c1">// which is zero initialization, but not explicit. We want to avoid</span>
<span class="c1">// that.</span>
<span class="cp">#if defined(__GNUC__)</span>
<span class="cp">#    pragma GCC diagnostic push</span>
<span class="cp">#    pragma GCC diagnostic ignored &quot;-Wmissing-field-initializers&quot;</span>
<span class="cp">#endif</span>

    <span class="k">static</span> <span class="kt">char</span><span class="o">*</span> <span class="n">altStackMem</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">altStackSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">stack_t</span> <span class="n">oldSigStack</span><span class="p">{};</span>
    <span class="k">static</span> <span class="k">struct</span> <span class="nc">sigaction</span> <span class="n">oldSigActions</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">signalDefs</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SignalDefs</span><span class="p">)]{};</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">restorePreviousSignalHandlers</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// We set signal handlers back to the previous ones. Hopefully</span>
        <span class="c1">// nobody overwrote them in the meantime, and doesn&#39;t expect</span>
        <span class="c1">// their signal handlers to live past ours given that they</span>
        <span class="c1">// installed them after ours..</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">signalDefs</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SignalDefs</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sigaction</span><span class="p">(</span><span class="n">signalDefs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldSigActions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">nullptr</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// Return the old stack</span>
        <span class="n">sigaltstack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldSigStack</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">handleSignal</span><span class="p">(</span> <span class="kt">int</span> <span class="n">sig</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&lt;unknown signal&gt;&quot;</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">def</span> <span class="p">:</span> <span class="n">signalDefs</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">def</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">def</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// We need to restore previous signal handlers and let them do</span>
        <span class="c1">// their thing, so that the users can have the debugger break</span>
        <span class="c1">// when a signal is raised, and so on.</span>
        <span class="n">restorePreviousSignalHandlers</span><span class="p">();</span>
        <span class="n">reportFatal</span><span class="p">(</span> <span class="n">name</span> <span class="p">);</span>
        <span class="n">raise</span><span class="p">(</span> <span class="n">sig</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">FatalConditionHandler</span><span class="o">::</span><span class="n">FatalConditionHandler</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">altStackMem</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Cannot initialize POSIX signal handler when one already exists&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">altStackSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">altStackSize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SIGSTKSZ</span><span class="p">),</span> <span class="n">minStackSizeForErrors</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">altStackMem</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">altStackSize</span><span class="p">]();</span>
    <span class="p">}</span>

    <span class="n">FatalConditionHandler</span><span class="o">::~</span><span class="n">FatalConditionHandler</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">altStackMem</span><span class="p">;</span>
        <span class="c1">// We signal that another instance can be constructed by zeroing</span>
        <span class="c1">// out the pointer.</span>
        <span class="n">altStackMem</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">FatalConditionHandler</span><span class="o">::</span><span class="n">engage_platform</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stack_t</span> <span class="n">sigStack</span><span class="p">;</span>
        <span class="n">sigStack</span><span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="n">altStackMem</span><span class="p">;</span>
        <span class="n">sigStack</span><span class="p">.</span><span class="n">ss_size</span> <span class="o">=</span> <span class="n">altStackSize</span><span class="p">;</span>
        <span class="n">sigStack</span><span class="p">.</span><span class="n">ss_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">sigaltstack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigStack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldSigStack</span><span class="p">);</span>
        <span class="k">struct</span> <span class="nc">sigaction</span> <span class="n">sa</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>

        <span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">handleSignal</span><span class="p">;</span>
        <span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_ONSTACK</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">signalDefs</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SignalDefs</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sigaction</span><span class="p">(</span><span class="n">signalDefs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldSigActions</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="cp">#if defined(__GNUC__)</span>
<span class="cp">#    pragma GCC diagnostic pop</span>
<span class="cp">#endif</span>

    <span class="kt">void</span> <span class="n">FatalConditionHandler</span><span class="o">::</span><span class="n">disengage_platform</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">restorePreviousSignalHandlers</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_POSIX_SIGNALS</span>
<span class="c1">// end catch_fatal_condition.cpp</span>
<span class="c1">// start catch_generators.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

<span class="n">IGeneratorTracker</span><span class="o">::~</span><span class="n">IGeneratorTracker</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">GeneratorException</span><span class="o">::</span><span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m_msg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">Generators</span> <span class="p">{</span>

    <span class="n">GeneratorUntypedBase</span><span class="o">::~</span><span class="n">GeneratorUntypedBase</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">auto</span> <span class="n">acquireGeneratorTracker</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">generatorName</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IGeneratorTracker</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getResultCapture</span><span class="p">().</span><span class="n">acquireGeneratorTracker</span><span class="p">(</span> <span class="n">generatorName</span><span class="p">,</span> <span class="n">lineInfo</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Generators</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_generators.cpp</span>
<span class="c1">// start catch_interfaces_capture.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">IResultCapture</span><span class="o">::~</span><span class="n">IResultCapture</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// end catch_interfaces_capture.cpp</span>
<span class="c1">// start catch_interfaces_config.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">IConfig</span><span class="o">::~</span><span class="n">IConfig</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// end catch_interfaces_config.cpp</span>
<span class="c1">// start catch_interfaces_exception.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">IExceptionTranslator</span><span class="o">::~</span><span class="n">IExceptionTranslator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">IExceptionTranslatorRegistry</span><span class="o">::~</span><span class="n">IExceptionTranslatorRegistry</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// end catch_interfaces_exception.cpp</span>
<span class="c1">// start catch_interfaces_registry_hub.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">IRegistryHub</span><span class="o">::~</span><span class="n">IRegistryHub</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">IMutableRegistryHub</span><span class="o">::~</span><span class="n">IMutableRegistryHub</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// end catch_interfaces_registry_hub.cpp</span>
<span class="c1">// start catch_interfaces_reporter.cpp</span>

<span class="c1">// start catch_reporter_listening.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">ListeningReporter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IStreamingReporter</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">Reporters</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IStreamingReporterPtr</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="n">Reporters</span> <span class="n">m_listeners</span><span class="p">;</span>
        <span class="n">IStreamingReporterPtr</span> <span class="n">m_reporter</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">ReporterPreferences</span> <span class="n">m_preferences</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">ListeningReporter</span><span class="p">();</span>

        <span class="kt">void</span> <span class="nf">addListener</span><span class="p">(</span> <span class="n">IStreamingReporterPtr</span><span class="o">&amp;&amp;</span> <span class="n">listener</span> <span class="p">);</span>
        <span class="kt">void</span> <span class="nf">addReporter</span><span class="p">(</span> <span class="n">IStreamingReporterPtr</span><span class="o">&amp;&amp;</span> <span class="n">reporter</span> <span class="p">);</span>

    <span class="k">public</span><span class="o">:</span> <span class="c1">// IStreamingReporter</span>

        <span class="n">ReporterPreferences</span> <span class="n">getPreferences</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">noMatchingTestCases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">spec</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">reportInvalidArguments</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Verbosity</span><span class="o">&gt;</span> <span class="n">getSupportedVerbosities</span><span class="p">();</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
        <span class="kt">void</span> <span class="nf">benchmarkPreparing</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkStarting</span><span class="p">(</span> <span class="n">BenchmarkInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">benchmarkInfo</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkEnded</span><span class="p">(</span> <span class="n">BenchmarkStats</span><span class="o">&lt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">benchmarkStats</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">benchmarkFailed</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

        <span class="kt">void</span> <span class="nf">testRunStarting</span><span class="p">(</span> <span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testRunInfo</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">testGroupStarting</span><span class="p">(</span> <span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">groupInfo</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">testCaseStarting</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">sectionStarting</span><span class="p">(</span> <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionInfo</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">assertionStarting</span><span class="p">(</span> <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionInfo</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="c1">// The return value indicates if the messages buffer should be cleared:</span>
        <span class="kt">bool</span> <span class="nf">assertionEnded</span><span class="p">(</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionStats</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">sectionEnded</span><span class="p">(</span> <span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionStats</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">testCaseEnded</span><span class="p">(</span> <span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseStats</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">testGroupEnded</span><span class="p">(</span> <span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testGroupStats</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">testRunEnded</span><span class="p">(</span> <span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testRunStats</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">skipTest</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">isMulti</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_reporter_listening.h</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">ReporterConfig</span><span class="o">::</span><span class="n">ReporterConfig</span><span class="p">(</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_fullConfig</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_stream</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">_fullConfig</span><span class="o">-&gt;</span><span class="n">stream</span><span class="p">()</span> <span class="p">),</span> <span class="n">m_fullConfig</span><span class="p">(</span> <span class="n">_fullConfig</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="n">ReporterConfig</span><span class="o">::</span><span class="n">ReporterConfig</span><span class="p">(</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_fullConfig</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">_stream</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_stream</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">_stream</span> <span class="p">),</span> <span class="n">m_fullConfig</span><span class="p">(</span> <span class="n">_fullConfig</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">ReporterConfig</span><span class="o">::</span><span class="n">stream</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">m_stream</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">IConfigPtr</span> <span class="n">ReporterConfig</span><span class="o">::</span><span class="n">fullConfig</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_fullConfig</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">TestRunInfo</span><span class="o">::</span><span class="n">TestRunInfo</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span> <span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span> <span class="n">_name</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="n">GroupInfo</span><span class="o">::</span><span class="n">GroupInfo</span><span class="p">(</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">,</span>
                           <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">_groupIndex</span><span class="p">,</span>
                           <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">_groupsCount</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">name</span><span class="p">(</span> <span class="n">_name</span> <span class="p">),</span>
        <span class="n">groupIndex</span><span class="p">(</span> <span class="n">_groupIndex</span> <span class="p">),</span>
        <span class="n">groupsCounts</span><span class="p">(</span> <span class="n">_groupsCount</span> <span class="p">)</span>
    <span class="p">{}</span>

     <span class="n">AssertionStats</span><span class="o">::</span><span class="n">AssertionStats</span><span class="p">(</span> <span class="n">AssertionResult</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_assertionResult</span><span class="p">,</span>
                                     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MessageInfo</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_infoMessages</span><span class="p">,</span>
                                     <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_totals</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">assertionResult</span><span class="p">(</span> <span class="n">_assertionResult</span> <span class="p">),</span>
        <span class="n">infoMessages</span><span class="p">(</span> <span class="n">_infoMessages</span> <span class="p">),</span>
        <span class="n">totals</span><span class="p">(</span> <span class="n">_totals</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assertionResult</span><span class="p">.</span><span class="n">m_resultData</span><span class="p">.</span><span class="n">lazyExpression</span><span class="p">.</span><span class="n">m_transientExpression</span> <span class="o">=</span> <span class="n">_assertionResult</span><span class="p">.</span><span class="n">m_resultData</span><span class="p">.</span><span class="n">lazyExpression</span><span class="p">.</span><span class="n">m_transientExpression</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">assertionResult</span><span class="p">.</span><span class="n">hasMessage</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Copy message into messages list.</span>
            <span class="c1">// !TBD This should have been done earlier, somewhere</span>
            <span class="n">MessageBuilder</span> <span class="nf">builder</span><span class="p">(</span> <span class="n">assertionResult</span><span class="p">.</span><span class="n">getTestMacroName</span><span class="p">(),</span> <span class="n">assertionResult</span><span class="p">.</span><span class="n">getSourceInfo</span><span class="p">(),</span> <span class="n">assertionResult</span><span class="p">.</span><span class="n">getResultType</span><span class="p">()</span> <span class="p">);</span>
            <span class="n">builder</span> <span class="o">&lt;&lt;</span> <span class="n">assertionResult</span><span class="p">.</span><span class="n">getMessage</span><span class="p">();</span>
            <span class="n">builder</span><span class="p">.</span><span class="n">m_info</span><span class="p">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">m_stream</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>

            <span class="n">infoMessages</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">builder</span><span class="p">.</span><span class="n">m_info</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

     <span class="n">AssertionStats</span><span class="o">::~</span><span class="n">AssertionStats</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">SectionStats</span><span class="o">::</span><span class="n">SectionStats</span><span class="p">(</span>  <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_sectionInfo</span><span class="p">,</span>
                                 <span class="n">Counts</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_assertions</span><span class="p">,</span>
                                 <span class="kt">double</span> <span class="n">_durationInSeconds</span><span class="p">,</span>
                                 <span class="kt">bool</span> <span class="n">_missingAssertions</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">sectionInfo</span><span class="p">(</span> <span class="n">_sectionInfo</span> <span class="p">),</span>
        <span class="n">assertions</span><span class="p">(</span> <span class="n">_assertions</span> <span class="p">),</span>
        <span class="n">durationInSeconds</span><span class="p">(</span> <span class="n">_durationInSeconds</span> <span class="p">),</span>
        <span class="n">missingAssertions</span><span class="p">(</span> <span class="n">_missingAssertions</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">SectionStats</span><span class="o">::~</span><span class="n">SectionStats</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">TestCaseStats</span><span class="o">::</span><span class="n">TestCaseStats</span><span class="p">(</span>  <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testInfo</span><span class="p">,</span>
                                   <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_totals</span><span class="p">,</span>
                                   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_stdOut</span><span class="p">,</span>
                                   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_stdErr</span><span class="p">,</span>
                                   <span class="kt">bool</span> <span class="n">_aborting</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">testInfo</span><span class="p">(</span> <span class="n">_testInfo</span> <span class="p">),</span>
        <span class="n">totals</span><span class="p">(</span> <span class="n">_totals</span> <span class="p">),</span>
        <span class="n">stdOut</span><span class="p">(</span> <span class="n">_stdOut</span> <span class="p">),</span>
        <span class="n">stdErr</span><span class="p">(</span> <span class="n">_stdErr</span> <span class="p">),</span>
        <span class="n">aborting</span><span class="p">(</span> <span class="n">_aborting</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">TestCaseStats</span><span class="o">::~</span><span class="n">TestCaseStats</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">TestGroupStats</span><span class="o">::</span><span class="n">TestGroupStats</span><span class="p">(</span> <span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_groupInfo</span><span class="p">,</span>
                                    <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_totals</span><span class="p">,</span>
                                    <span class="kt">bool</span> <span class="n">_aborting</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">groupInfo</span><span class="p">(</span> <span class="n">_groupInfo</span> <span class="p">),</span>
        <span class="n">totals</span><span class="p">(</span> <span class="n">_totals</span> <span class="p">),</span>
        <span class="n">aborting</span><span class="p">(</span> <span class="n">_aborting</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">TestGroupStats</span><span class="o">::</span><span class="n">TestGroupStats</span><span class="p">(</span> <span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_groupInfo</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">groupInfo</span><span class="p">(</span> <span class="n">_groupInfo</span> <span class="p">),</span>
        <span class="n">aborting</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">TestGroupStats</span><span class="o">::~</span><span class="n">TestGroupStats</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">TestRunStats</span><span class="o">::</span><span class="n">TestRunStats</span><span class="p">(</span>   <span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_runInfo</span><span class="p">,</span>
                    <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_totals</span><span class="p">,</span>
                    <span class="kt">bool</span> <span class="n">_aborting</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">runInfo</span><span class="p">(</span> <span class="n">_runInfo</span> <span class="p">),</span>
        <span class="n">totals</span><span class="p">(</span> <span class="n">_totals</span> <span class="p">),</span>
        <span class="n">aborting</span><span class="p">(</span> <span class="n">_aborting</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">TestRunStats</span><span class="o">::~</span><span class="n">TestRunStats</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">IStreamingReporter</span><span class="o">::</span><span class="n">fatalErrorEncountered</span><span class="p">(</span> <span class="n">StringRef</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="kt">bool</span> <span class="n">IStreamingReporter</span><span class="o">::</span><span class="n">isMulti</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">IReporterFactory</span><span class="o">::~</span><span class="n">IReporterFactory</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">IReporterRegistry</span><span class="o">::~</span><span class="n">IReporterRegistry</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_interfaces_reporter.cpp</span>
<span class="c1">// start catch_interfaces_runner.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">IRunner</span><span class="o">::~</span><span class="n">IRunner</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// end catch_interfaces_runner.cpp</span>
<span class="c1">// start catch_interfaces_testcase.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">ITestInvoker</span><span class="o">::~</span><span class="n">ITestInvoker</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">ITestCaseRegistry</span><span class="o">::~</span><span class="n">ITestCaseRegistry</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// end catch_interfaces_testcase.cpp</span>
<span class="c1">// start catch_leak_detector.cpp</span>

<span class="cp">#ifdef CATCH_CONFIG_WINDOWS_CRTDBG</span>
<span class="cp">#include</span> <span class="cpf">&lt;crtdbg.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">LeakDetector</span><span class="o">::</span><span class="n">LeakDetector</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">_CrtSetDbgFlag</span><span class="p">(</span><span class="n">_CRTDBG_REPORT_FLAG</span><span class="p">);</span>
        <span class="n">flag</span> <span class="o">|=</span> <span class="n">_CRTDBG_LEAK_CHECK_DF</span><span class="p">;</span>
        <span class="n">flag</span> <span class="o">|=</span> <span class="n">_CRTDBG_ALLOC_MEM_DF</span><span class="p">;</span>
        <span class="n">_CrtSetDbgFlag</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
        <span class="n">_CrtSetReportMode</span><span class="p">(</span><span class="n">_CRT_WARN</span><span class="p">,</span> <span class="n">_CRTDBG_MODE_FILE</span> <span class="o">|</span> <span class="n">_CRTDBG_MODE_DEBUG</span><span class="p">);</span>
        <span class="n">_CrtSetReportFile</span><span class="p">(</span><span class="n">_CRT_WARN</span><span class="p">,</span> <span class="n">_CRTDBG_FILE_STDERR</span><span class="p">);</span>
        <span class="c1">// Change this to leaking allocation&#39;s number to break there</span>
        <span class="n">_CrtSetBreakAlloc</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>

    <span class="n">Catch</span><span class="o">::</span><span class="n">LeakDetector</span><span class="o">::</span><span class="n">LeakDetector</span><span class="p">()</span> <span class="p">{}</span>

<span class="cp">#endif</span>

<span class="n">Catch</span><span class="o">::</span><span class="n">LeakDetector</span><span class="o">::~</span><span class="n">LeakDetector</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Catch</span><span class="o">::</span><span class="n">cleanUp</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// end catch_leak_detector.cpp</span>
<span class="c1">// start catch_list.cpp</span>

<span class="c1">// start catch_list.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">listTests</span><span class="p">(</span> <span class="n">Config</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">listTestsNamesOnly</span><span class="p">(</span> <span class="n">Config</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>

    <span class="k">struct</span> <span class="nc">TagInfo</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">spelling</span> <span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">all</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">spellings</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">listTags</span><span class="p">(</span> <span class="n">Config</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">listReporters</span><span class="p">();</span>

    <span class="n">Option</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_list.h</span>
<span class="c1">// start catch_text.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">clara</span><span class="o">::</span><span class="n">TextFlow</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// end catch_text.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">listTests</span><span class="p">(</span> <span class="n">Config</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">testSpec</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">hasTestFilters</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Matching test cases:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;All available test cases:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">matchedTestCases</span> <span class="o">=</span> <span class="n">filterTests</span><span class="p">(</span> <span class="n">getAllTestCasesSorted</span><span class="p">(</span> <span class="n">config</span> <span class="p">),</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">config</span> <span class="p">);</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">testCaseInfo</span> <span class="p">:</span> <span class="n">matchedTestCases</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="n">colour</span> <span class="o">=</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">isHidden</span><span class="p">()</span>
                <span class="o">?</span> <span class="n">Colour</span><span class="o">::</span><span class="nl">SecondaryText</span>
                <span class="p">:</span> <span class="n">Colour</span><span class="o">::</span><span class="n">None</span><span class="p">;</span>
            <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span> <span class="n">colour</span> <span class="p">);</span>

            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">name</span> <span class="p">).</span><span class="n">initialIndent</span><span class="p">(</span> <span class="mi">2</span> <span class="p">).</span><span class="n">indent</span><span class="p">(</span> <span class="mi">4</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">verbosity</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">High</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">lineInfo</span> <span class="p">)</span> <span class="p">).</span><span class="n">indent</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">description</span> <span class="o">=</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">description</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">description</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                    <span class="n">description</span> <span class="o">=</span> <span class="s">&quot;(NO DESCRIPTION)&quot;</span><span class="p">;</span>
                <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span> <span class="n">description</span> <span class="p">).</span><span class="n">indent</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">testCaseInfo</span><span class="p">.</span><span class="n">tags</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">tagsAsString</span><span class="p">()</span> <span class="p">).</span><span class="n">indent</span><span class="p">(</span> <span class="mi">6</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">config</span><span class="p">.</span><span class="n">hasTestFilters</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span> <span class="n">matchedTestCases</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;test case&quot;</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span> <span class="n">matchedTestCases</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;matching test case&quot;</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">matchedTestCases</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">listTestsNamesOnly</span><span class="p">(</span> <span class="n">Config</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">testSpec</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">matchedTests</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">matchedTestCases</span> <span class="o">=</span> <span class="n">filterTests</span><span class="p">(</span> <span class="n">getAllTestCasesSorted</span><span class="p">(</span> <span class="n">config</span> <span class="p">),</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">config</span> <span class="p">);</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">testCaseInfo</span> <span class="p">:</span> <span class="n">matchedTestCases</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">matchedTests</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">startsWith</span><span class="p">(</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;#&#39;</span> <span class="p">)</span> <span class="p">)</span>
               <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;&quot;&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">;</span>
            <span class="k">else</span>
               <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">verbosity</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">High</span> <span class="p">)</span>
                <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">@&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">;</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">matchedTests</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TagInfo</span><span class="o">::</span><span class="n">add</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">spelling</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
        <span class="n">spellings</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">spelling</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">TagInfo</span><span class="o">::</span><span class="n">all</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">spelling</span> <span class="p">:</span> <span class="n">spellings</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Add 2 for the brackes</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="n">spelling</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">out</span><span class="p">;</span> <span class="n">out</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">spelling</span> <span class="p">:</span> <span class="n">spellings</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sc">&#39;[&#39;</span><span class="p">;</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">spelling</span><span class="p">;</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sc">&#39;]&#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">listTags</span><span class="p">(</span> <span class="n">Config</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">testSpec</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">hasTestFilters</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Tags for matching test cases:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;All available tags:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">TagInfo</span><span class="o">&gt;</span> <span class="n">tagCounts</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">matchedTestCases</span> <span class="o">=</span> <span class="n">filterTests</span><span class="p">(</span> <span class="n">getAllTestCasesSorted</span><span class="p">(</span> <span class="n">config</span> <span class="p">),</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">config</span> <span class="p">);</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">testCase</span> <span class="p">:</span> <span class="n">matchedTestCases</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">tagName</span> <span class="p">:</span> <span class="n">testCase</span><span class="p">.</span><span class="n">getTestCaseInfo</span><span class="p">().</span><span class="n">tags</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">lcaseTagName</span> <span class="o">=</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">tagName</span> <span class="p">);</span>
                <span class="k">auto</span> <span class="n">countIt</span> <span class="o">=</span> <span class="n">tagCounts</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">lcaseTagName</span> <span class="p">);</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">countIt</span> <span class="o">==</span> <span class="n">tagCounts</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span>
                    <span class="n">countIt</span> <span class="o">=</span> <span class="n">tagCounts</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span> <span class="n">lcaseTagName</span><span class="p">,</span> <span class="n">TagInfo</span><span class="p">()</span> <span class="p">)</span> <span class="p">).</span><span class="n">first</span><span class="p">;</span>
                <span class="n">countIt</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">add</span><span class="p">(</span> <span class="n">tagName</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">tagCount</span> <span class="p">:</span> <span class="n">tagCounts</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tagCount</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span><span class="p">;</span>
            <span class="k">auto</span> <span class="n">str</span> <span class="o">=</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
            <span class="k">auto</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span> <span class="n">tagCount</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">all</span><span class="p">()</span> <span class="p">)</span>
                                                    <span class="p">.</span><span class="n">initialIndent</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span>
                                                    <span class="p">.</span><span class="n">indent</span><span class="p">(</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span>
                                                    <span class="p">.</span><span class="n">width</span><span class="p">(</span> <span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span><span class="mi">-10</span> <span class="p">);</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">wrapper</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span> <span class="n">tagCounts</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;tag&quot;</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">tagCounts</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">listReporters</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Available reporters:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">IReporterRegistry</span><span class="o">::</span><span class="n">FactoryMap</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">factories</span> <span class="o">=</span> <span class="n">getRegistryHub</span><span class="p">().</span><span class="n">getReporterRegistry</span><span class="p">().</span><span class="n">getFactories</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">maxNameLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">factoryKvp</span> <span class="p">:</span> <span class="n">factories</span> <span class="p">)</span>
            <span class="n">maxNameLen</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">)(</span> <span class="n">maxNameLen</span><span class="p">,</span> <span class="n">factoryKvp</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">factoryKvp</span> <span class="p">:</span> <span class="n">factories</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span>
                    <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span> <span class="n">factoryKvp</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="p">)</span>
                            <span class="p">.</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                            <span class="p">.</span><span class="n">width</span><span class="p">(</span> <span class="mi">5</span><span class="o">+</span><span class="n">maxNameLen</span> <span class="p">)</span>
                    <span class="o">+</span>  <span class="n">Column</span><span class="p">(</span> <span class="n">factoryKvp</span><span class="p">.</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">getDescription</span><span class="p">()</span> <span class="p">)</span>
                            <span class="p">.</span><span class="n">initialIndent</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                            <span class="p">.</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                            <span class="p">.</span><span class="n">width</span><span class="p">(</span> <span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span> <span class="o">-</span> <span class="n">maxNameLen</span><span class="mi">-8</span> <span class="p">)</span>
                    <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">factories</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">Option</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">Option</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">listedCount</span><span class="p">;</span>
        <span class="n">getCurrentMutableContext</span><span class="p">().</span><span class="n">setConfig</span><span class="p">(</span> <span class="n">config</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">listTests</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">listedCount</span> <span class="o">=</span> <span class="n">listedCount</span><span class="p">.</span><span class="n">valueOr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">listTests</span><span class="p">(</span> <span class="o">*</span><span class="n">config</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">listTestNamesOnly</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">listedCount</span> <span class="o">=</span> <span class="n">listedCount</span><span class="p">.</span><span class="n">valueOr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">listTestsNamesOnly</span><span class="p">(</span> <span class="o">*</span><span class="n">config</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">listTags</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">listedCount</span> <span class="o">=</span> <span class="n">listedCount</span><span class="p">.</span><span class="n">valueOr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">listTags</span><span class="p">(</span> <span class="o">*</span><span class="n">config</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">listReporters</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">listedCount</span> <span class="o">=</span> <span class="n">listedCount</span><span class="p">.</span><span class="n">valueOr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">listReporters</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">listedCount</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_list.cpp</span>
<span class="c1">// start catch_matchers.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">Impl</span> <span class="p">{</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">MatcherUntypedBase</span><span class="o">::</span><span class="n">toString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_cachedToString</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">m_cachedToString</span> <span class="o">=</span> <span class="n">describe</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">m_cachedToString</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">MatcherUntypedBase</span><span class="o">::~</span><span class="n">MatcherUntypedBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="p">}</span> <span class="c1">// namespace Impl</span>
<span class="p">}</span> <span class="c1">// namespace Matchers</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">Matchers</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Matchers</span><span class="o">::</span><span class="n">Impl</span><span class="o">::</span><span class="n">MatcherBase</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_matchers.cpp</span>
<span class="c1">// start catch_matchers_exception.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Exception</span> <span class="p">{</span>

<span class="kt">bool</span> <span class="n">ExceptionMessageMatcher</span><span class="o">::</span><span class="n">match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">==</span> <span class="n">m_message</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ExceptionMessageMatcher</span><span class="o">::</span><span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;exception message matches </span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">m_message</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>
<span class="n">Exception</span><span class="o">::</span><span class="n">ExceptionMessageMatcher</span> <span class="n">Message</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Exception</span><span class="o">::</span><span class="n">ExceptionMessageMatcher</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// namespace Exception</span>
<span class="p">}</span> <span class="c1">// namespace Matchers</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_matchers_exception.cpp</span>
<span class="c1">// start catch_matchers_floating.cpp</span>

<span class="c1">// start catch_polyfills.hpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">isnan</span><span class="p">(</span><span class="kt">float</span> <span class="n">f</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">isnan</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// end catch_polyfills.hpp</span>
<span class="c1">// start catch_to_string.hpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined(CATCH_CONFIG_CPP11_TO_STRING)</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="cp">#else</span>
        <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
        <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_to_string.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>

    <span class="kt">int32_t</span> <span class="nf">convert</span><span class="p">(</span><span class="kt">float</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int32_t</span><span class="p">),</span> <span class="s">&quot;Important ULP matcher assumption violated&quot;</span><span class="p">);</span>
        <span class="kt">int32_t</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int64_t</span> <span class="nf">convert</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">),</span> <span class="s">&quot;Important ULP matcher assumption violated&quot;</span><span class="p">);</span>
        <span class="kt">int64_t</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">FP</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">almostEqualUlps</span><span class="p">(</span><span class="n">FP</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">FP</span> <span class="n">rhs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">maxUlpDiff</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Comparison with NaN should always be false.</span>
        <span class="c1">// This way we can rule it out before getting into the ugly details</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Catch</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">||</span> <span class="n">Catch</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">lc</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">lc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// Potentially we can have +0 and -0</span>
            <span class="k">return</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// static cast as a workaround for IBM XLC</span>
        <span class="k">auto</span> <span class="n">ulpDiff</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">FP</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lc</span> <span class="o">-</span> <span class="n">rc</span><span class="p">));</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ulpDiff</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">maxUlpDiff</span><span class="p">;</span>
    <span class="p">}</span>

<span class="cp">#if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)</span>

    <span class="kt">float</span> <span class="n">nextafter</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">nextafterf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">double</span> <span class="n">nextafter</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">nextafter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cp">#endif </span><span class="c1">// ^^^ CATCH_CONFIG_GLOBAL_NEXTAFTER ^^^</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">FP</span><span class="o">&gt;</span>
<span class="n">FP</span> <span class="n">step</span><span class="p">(</span><span class="n">FP</span> <span class="n">start</span><span class="p">,</span> <span class="n">FP</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">steps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">nextafter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
<span class="cp">#else</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nextafter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Performs equivalent check of std::fabs(lhs - rhs) &lt;= margin</span>
<span class="c1">// But without the subtraction to allow for INFINITY in comparison</span>
<span class="kt">bool</span> <span class="n">marginComparison</span><span class="p">(</span><span class="kt">double</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">double</span> <span class="n">rhs</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">lhs</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&gt;=</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rhs</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&gt;=</span> <span class="n">lhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">FloatingPoint</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">FloatingPoint</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">scientific</span>
        <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">FloatingPoint</span><span class="o">&gt;::</span><span class="n">max_digits10</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">&lt;&lt;</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// end anonymous namespace</span>

<span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Floating</span> <span class="p">{</span>

    <span class="k">enum</span> <span class="k">class</span> <span class="nc">FloatingPointKind</span> <span class="o">:</span> <span class="kt">uint8_t</span> <span class="p">{</span>
        <span class="n">Float</span><span class="p">,</span>
        <span class="n">Double</span>
    <span class="p">};</span>

    <span class="n">WithinAbsMatcher</span><span class="o">::</span><span class="n">WithinAbsMatcher</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="p">)</span>
        <span class="o">:</span><span class="n">m_target</span><span class="p">{</span> <span class="n">target</span> <span class="p">},</span> <span class="n">m_margin</span><span class="p">{</span> <span class="n">margin</span> <span class="p">}</span> <span class="p">{</span>
        <span class="n">CATCH_ENFORCE</span><span class="p">(</span><span class="n">margin</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Invalid margin: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">margin</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;.&#39;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; Margin has to be non-negative.&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Performs equivalent check of std::fabs(lhs - rhs) &lt;= margin</span>
    <span class="c1">// But without the subtraction to allow for INFINITY in comparison</span>
    <span class="kt">bool</span> <span class="n">WithinAbsMatcher</span><span class="o">::</span><span class="n">match</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matchee</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">matchee</span> <span class="o">+</span> <span class="n">m_margin</span> <span class="o">&gt;=</span> <span class="n">m_target</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">m_target</span> <span class="o">+</span> <span class="n">m_margin</span> <span class="o">&gt;=</span> <span class="n">matchee</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">WithinAbsMatcher</span><span class="o">::</span><span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;is within &quot;</span> <span class="o">+</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">m_margin</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; of &quot;</span> <span class="o">+</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">m_target</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">WithinUlpsMatcher</span><span class="o">::</span><span class="n">WithinUlpsMatcher</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">ulps</span><span class="p">,</span> <span class="n">FloatingPointKind</span> <span class="n">baseType</span><span class="p">)</span>
        <span class="o">:</span><span class="n">m_target</span><span class="p">{</span> <span class="n">target</span> <span class="p">},</span> <span class="n">m_ulps</span><span class="p">{</span> <span class="n">ulps</span> <span class="p">},</span> <span class="n">m_type</span><span class="p">{</span> <span class="n">baseType</span> <span class="p">}</span> <span class="p">{</span>
        <span class="n">CATCH_ENFORCE</span><span class="p">(</span><span class="n">m_type</span> <span class="o">==</span> <span class="n">FloatingPointKind</span><span class="o">::</span><span class="n">Double</span>
                   <span class="o">||</span> <span class="n">m_ulps</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">)(),</span>
            <span class="s">&quot;Provided ULP is impossibly large for a float comparison.&quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cp">#if defined(__clang__)</span>
<span class="cp">#pragma clang diagnostic push</span>
<span class="c1">// Clang &lt;3.5 reports on the default branch in the switch below</span>
<span class="cp">#pragma clang diagnostic ignored &quot;-Wunreachable-code&quot;</span>
<span class="cp">#endif</span>

    <span class="kt">bool</span> <span class="n">WithinUlpsMatcher</span><span class="o">::</span><span class="n">match</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matchee</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">m_type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">FloatingPointKind</span><span class="o">::</span><span class="nl">Float</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">almostEqualUlps</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">matchee</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_target</span><span class="p">),</span> <span class="n">m_ulps</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">FloatingPointKind</span><span class="o">::</span><span class="nl">Double</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">almostEqualUlps</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">matchee</span><span class="p">,</span> <span class="n">m_target</span><span class="p">,</span> <span class="n">m_ulps</span><span class="p">);</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span> <span class="s">&quot;Unknown FloatingPointKind value&quot;</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="cp">#if defined(__clang__)</span>
<span class="cp">#pragma clang diagnostic pop</span>
<span class="cp">#endif</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">WithinUlpsMatcher</span><span class="o">::</span><span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;is within &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_ulps</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; ULPs of &quot;</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">m_type</span> <span class="o">==</span> <span class="n">FloatingPointKind</span><span class="o">::</span><span class="n">Float</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">write</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_target</span><span class="p">));</span>
            <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;f&#39;</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">write</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">m_target</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; ([&quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_type</span> <span class="o">==</span> <span class="n">FloatingPointKind</span><span class="o">::</span><span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">write</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">step</span><span class="p">(</span><span class="n">m_target</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="n">INFINITY</span><span class="p">),</span> <span class="n">m_ulps</span><span class="p">));</span>
            <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
            <span class="n">write</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">step</span><span class="p">(</span><span class="n">m_target</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">INFINITY</span><span class="p">),</span> <span class="n">m_ulps</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// We have to cast INFINITY to float because of MinGW, see #1782</span>
            <span class="n">write</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">step</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_target</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="n">INFINITY</span><span class="p">),</span> <span class="n">m_ulps</span><span class="p">));</span>
            <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
            <span class="n">write</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">step</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_target</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">INFINITY</span><span class="p">),</span> <span class="n">m_ulps</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;])&quot;</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">WithinRelMatcher</span><span class="o">::</span><span class="n">WithinRelMatcher</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">)</span><span class="o">:</span>
        <span class="n">m_target</span><span class="p">(</span><span class="n">target</span><span class="p">),</span>
        <span class="n">m_epsilon</span><span class="p">(</span><span class="n">epsilon</span><span class="p">){</span>
        <span class="n">CATCH_ENFORCE</span><span class="p">(</span><span class="n">m_epsilon</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">,</span> <span class="s">&quot;Relative comparison with epsilon &lt;  0 does not make sense.&quot;</span><span class="p">);</span>
        <span class="n">CATCH_ENFORCE</span><span class="p">(</span><span class="n">m_epsilon</span>  <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">,</span> <span class="s">&quot;Relative comparison with epsilon &gt;= 1 does not make sense.&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">WithinRelMatcher</span><span class="o">::</span><span class="n">match</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matchee</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">relMargin</span> <span class="o">=</span> <span class="n">m_epsilon</span> <span class="o">*</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">matchee</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">m_target</span><span class="p">));</span>
        <span class="k">return</span> <span class="nf">marginComparison</span><span class="p">(</span><span class="n">matchee</span><span class="p">,</span> <span class="n">m_target</span><span class="p">,</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">isinf</span><span class="p">(</span><span class="n">relMargin</span><span class="p">)</span><span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">relMargin</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">WithinRelMatcher</span><span class="o">::</span><span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">ReusableStringStream</span> <span class="n">sstr</span><span class="p">;</span>
        <span class="n">sstr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;and &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_target</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; are within &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_epsilon</span> <span class="o">*</span> <span class="mf">100.</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;% of each other&quot;</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span><span class="c1">// namespace Floating</span>

<span class="n">Floating</span><span class="o">::</span><span class="n">WithinUlpsMatcher</span> <span class="n">WithinULP</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">maxUlpDiff</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Floating</span><span class="o">::</span><span class="n">WithinUlpsMatcher</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">maxUlpDiff</span><span class="p">,</span> <span class="n">Floating</span><span class="o">::</span><span class="n">FloatingPointKind</span><span class="o">::</span><span class="n">Double</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Floating</span><span class="o">::</span><span class="n">WithinUlpsMatcher</span> <span class="n">WithinULP</span><span class="p">(</span><span class="kt">float</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">maxUlpDiff</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Floating</span><span class="o">::</span><span class="n">WithinUlpsMatcher</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">maxUlpDiff</span><span class="p">,</span> <span class="n">Floating</span><span class="o">::</span><span class="n">FloatingPointKind</span><span class="o">::</span><span class="n">Float</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Floating</span><span class="o">::</span><span class="n">WithinAbsMatcher</span> <span class="n">WithinAbs</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">margin</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Floating</span><span class="o">::</span><span class="n">WithinAbsMatcher</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">margin</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span> <span class="n">WithinRel</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">eps</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span> <span class="n">WithinRel</span><span class="p">(</span><span class="kt">double</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">epsilon</span><span class="p">()</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span> <span class="n">WithinRel</span><span class="p">(</span><span class="kt">float</span> <span class="n">target</span><span class="p">,</span> <span class="kt">float</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">eps</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span> <span class="n">WithinRel</span><span class="p">(</span><span class="kt">float</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Floating</span><span class="o">::</span><span class="n">WithinRelMatcher</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">epsilon</span><span class="p">()</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Matchers</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_matchers_floating.cpp</span>
<span class="c1">// start catch_matchers_generic.cpp</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Matchers</span><span class="o">::</span><span class="n">Generic</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">finalizeDescription</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;matches undescribed predicate&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;matches predicate: </span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">desc</span> <span class="o">+</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// end catch_matchers_generic.cpp</span>
<span class="c1">// start catch_matchers_string.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;regex&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Matchers</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="n">StdString</span> <span class="p">{</span>

        <span class="n">CasedString</span><span class="o">::</span><span class="n">CasedString</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">m_caseSensitivity</span><span class="p">(</span> <span class="n">caseSensitivity</span> <span class="p">),</span>
            <span class="n">m_str</span><span class="p">(</span> <span class="n">adjustString</span><span class="p">(</span> <span class="n">str</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">CasedString</span><span class="o">::</span><span class="n">adjustString</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_caseSensitivity</span> <span class="o">==</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">No</span>
                   <span class="o">?</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">str</span> <span class="p">)</span>
                   <span class="o">:</span> <span class="n">str</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">CasedString</span><span class="o">::</span><span class="n">caseSensitivitySuffix</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_caseSensitivity</span> <span class="o">==</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">No</span>
                   <span class="o">?</span> <span class="s">&quot; (case insensitive)&quot;</span>
                   <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">StringMatcherBase</span><span class="o">::</span><span class="n">StringMatcherBase</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">operation</span><span class="p">,</span> <span class="n">CasedString</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">m_comparator</span><span class="p">(</span> <span class="n">comparator</span> <span class="p">),</span>
          <span class="n">m_operation</span><span class="p">(</span> <span class="n">operation</span> <span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMatcherBase</span><span class="o">::</span><span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">description</span><span class="p">;</span>
            <span class="n">description</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">m_operation</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">m_str</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span>
                                        <span class="n">m_comparator</span><span class="p">.</span><span class="n">caseSensitivitySuffix</span><span class="p">().</span><span class="n">size</span><span class="p">());</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="n">m_operation</span><span class="p">;</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="s">&quot;: </span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">;</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">m_str</span><span class="p">;</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">;</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">caseSensitivitySuffix</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">description</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">EqualsMatcher</span><span class="o">::</span><span class="n">EqualsMatcher</span><span class="p">(</span> <span class="n">CasedString</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">)</span> <span class="o">:</span> <span class="n">StringMatcherBase</span><span class="p">(</span> <span class="s">&quot;equals&quot;</span><span class="p">,</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="kt">bool</span> <span class="n">EqualsMatcher</span><span class="o">::</span><span class="n">match</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">source</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">adjustString</span><span class="p">(</span> <span class="n">source</span> <span class="p">)</span> <span class="o">==</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">m_str</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">ContainsMatcher</span><span class="o">::</span><span class="n">ContainsMatcher</span><span class="p">(</span> <span class="n">CasedString</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">)</span> <span class="o">:</span> <span class="n">StringMatcherBase</span><span class="p">(</span> <span class="s">&quot;contains&quot;</span><span class="p">,</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="kt">bool</span> <span class="n">ContainsMatcher</span><span class="o">::</span><span class="n">match</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">source</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">contains</span><span class="p">(</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">adjustString</span><span class="p">(</span> <span class="n">source</span> <span class="p">),</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">m_str</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">StartsWithMatcher</span><span class="o">::</span><span class="n">StartsWithMatcher</span><span class="p">(</span> <span class="n">CasedString</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">)</span> <span class="o">:</span> <span class="n">StringMatcherBase</span><span class="p">(</span> <span class="s">&quot;starts with&quot;</span><span class="p">,</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="kt">bool</span> <span class="n">StartsWithMatcher</span><span class="o">::</span><span class="n">match</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">source</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">startsWith</span><span class="p">(</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">adjustString</span><span class="p">(</span> <span class="n">source</span> <span class="p">),</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">m_str</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">EndsWithMatcher</span><span class="o">::</span><span class="n">EndsWithMatcher</span><span class="p">(</span> <span class="n">CasedString</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">comparator</span> <span class="p">)</span> <span class="o">:</span> <span class="n">StringMatcherBase</span><span class="p">(</span> <span class="s">&quot;ends with&quot;</span><span class="p">,</span> <span class="n">comparator</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="kt">bool</span> <span class="n">EndsWithMatcher</span><span class="o">::</span><span class="n">match</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">source</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">endsWith</span><span class="p">(</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">adjustString</span><span class="p">(</span> <span class="n">source</span> <span class="p">),</span> <span class="n">m_comparator</span><span class="p">.</span><span class="n">m_str</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">RegexMatcher</span><span class="o">::</span><span class="n">RegexMatcher</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">regex</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span><span class="p">)</span><span class="o">:</span> <span class="n">m_regex</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">regex</span><span class="p">)),</span> <span class="n">m_caseSensitivity</span><span class="p">(</span><span class="n">caseSensitivity</span><span class="p">)</span> <span class="p">{}</span>

        <span class="kt">bool</span> <span class="n">RegexMatcher</span><span class="o">::</span><span class="n">match</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">matchee</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">regex</span><span class="o">::</span><span class="n">ECMAScript</span><span class="p">;</span> <span class="c1">// ECMAScript is the default syntax option anyway</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_caseSensitivity</span> <span class="o">==</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span><span class="o">::</span><span class="n">No</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">flags</span> <span class="o">|=</span> <span class="n">std</span><span class="o">::</span><span class="n">regex</span><span class="o">::</span><span class="n">icase</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">auto</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">regex</span><span class="p">(</span><span class="n">m_regex</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">regex_match</span><span class="p">(</span><span class="n">matchee</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">RegexMatcher</span><span class="o">::</span><span class="n">describe</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;matches &quot;</span> <span class="o">+</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">m_regex</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">m_caseSensitivity</span> <span class="o">==</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span><span class="o">::</span><span class="n">Yes</span><span class="p">)</span><span class="o">?</span> <span class="s">&quot; case sensitively&quot;</span> <span class="o">:</span> <span class="s">&quot; case insensitively&quot;</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="c1">// namespace StdString</span>

    <span class="n">StdString</span><span class="o">::</span><span class="n">EqualsMatcher</span> <span class="n">Equals</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">StdString</span><span class="o">::</span><span class="n">EqualsMatcher</span><span class="p">(</span> <span class="n">StdString</span><span class="o">::</span><span class="n">CasedString</span><span class="p">(</span> <span class="n">str</span><span class="p">,</span> <span class="n">caseSensitivity</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">StdString</span><span class="o">::</span><span class="n">ContainsMatcher</span> <span class="n">Contains</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">StdString</span><span class="o">::</span><span class="n">ContainsMatcher</span><span class="p">(</span> <span class="n">StdString</span><span class="o">::</span><span class="n">CasedString</span><span class="p">(</span> <span class="n">str</span><span class="p">,</span> <span class="n">caseSensitivity</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">StdString</span><span class="o">::</span><span class="n">EndsWithMatcher</span> <span class="n">EndsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">StdString</span><span class="o">::</span><span class="n">EndsWithMatcher</span><span class="p">(</span> <span class="n">StdString</span><span class="o">::</span><span class="n">CasedString</span><span class="p">(</span> <span class="n">str</span><span class="p">,</span> <span class="n">caseSensitivity</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">StdString</span><span class="o">::</span><span class="n">StartsWithMatcher</span> <span class="n">StartsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">StdString</span><span class="o">::</span><span class="n">StartsWithMatcher</span><span class="p">(</span> <span class="n">StdString</span><span class="o">::</span><span class="n">CasedString</span><span class="p">(</span> <span class="n">str</span><span class="p">,</span> <span class="n">caseSensitivity</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">StdString</span><span class="o">::</span><span class="n">RegexMatcher</span> <span class="n">Matches</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">regex</span><span class="p">,</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">StdString</span><span class="o">::</span><span class="n">RegexMatcher</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">caseSensitivity</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Matchers</span>
<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_matchers_string.cpp</span>
<span class="c1">// start catch_message.cpp</span>

<span class="c1">// start catch_uncaught_exceptions.h</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">uncaught_exceptions</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_uncaught_exceptions.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">MessageInfo</span><span class="o">::</span><span class="n">MessageInfo</span><span class="p">(</span>   <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_macroName</span><span class="p">,</span>
                                <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_lineInfo</span><span class="p">,</span>
                                <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">_type</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">macroName</span><span class="p">(</span> <span class="n">_macroName</span> <span class="p">),</span>
        <span class="n">lineInfo</span><span class="p">(</span> <span class="n">_lineInfo</span> <span class="p">),</span>
        <span class="n">type</span><span class="p">(</span> <span class="n">_type</span> <span class="p">),</span>
        <span class="n">sequence</span><span class="p">(</span> <span class="o">++</span><span class="n">globalCount</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">MessageInfo</span><span class="o">::</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">MessageInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">sequence</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">sequence</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">MessageInfo</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span> <span class="n">MessageInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">sequence</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">sequence</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// This may need protecting if threading support is added</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">MessageInfo</span><span class="o">::</span><span class="n">globalCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>

    <span class="n">Catch</span><span class="o">::</span><span class="n">MessageBuilder</span><span class="o">::</span><span class="n">MessageBuilder</span><span class="p">(</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">macroName</span><span class="p">,</span>
                                           <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span><span class="p">,</span>
                                           <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">type</span> <span class="p">)</span>
        <span class="o">:</span><span class="n">m_info</span><span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">lineInfo</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span> <span class="p">{}</span>

    <span class="c1">////////////////////////////////////////////////////////////////////////////</span>

    <span class="n">ScopedMessage</span><span class="o">::</span><span class="n">ScopedMessage</span><span class="p">(</span> <span class="n">MessageBuilder</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">builder</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">m_info</span><span class="p">(</span> <span class="n">builder</span><span class="p">.</span><span class="n">m_info</span> <span class="p">),</span> <span class="n">m_moved</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_info</span><span class="p">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">m_stream</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="n">getResultCapture</span><span class="p">().</span><span class="n">pushScopedMessage</span><span class="p">(</span> <span class="n">m_info</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ScopedMessage</span><span class="o">::</span><span class="n">ScopedMessage</span><span class="p">(</span> <span class="n">ScopedMessage</span><span class="o">&amp;&amp;</span> <span class="n">old</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">m_info</span><span class="p">(</span> <span class="n">old</span><span class="p">.</span><span class="n">m_info</span> <span class="p">),</span> <span class="n">m_moved</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">old</span><span class="p">.</span><span class="n">m_moved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ScopedMessage</span><span class="o">::~</span><span class="n">ScopedMessage</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">uncaught_exceptions</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">m_moved</span> <span class="p">){</span>
            <span class="n">getResultCapture</span><span class="p">().</span><span class="n">popScopedMessage</span><span class="p">(</span><span class="n">m_info</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Capturer</span><span class="o">::</span><span class="n">Capturer</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">macroName</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span><span class="p">,</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">names</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">trimmed</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="o">||</span> <span class="n">isspace</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">start</span><span class="p">])))</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">start</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="o">||</span> <span class="n">isspace</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">end</span><span class="p">])))</span> <span class="p">{</span>
                <span class="o">--</span><span class="n">end</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">names</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="k">auto</span> <span class="n">skipq</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">char</span> <span class="n">quote</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">names</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">quote</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\\&#39;</span><span class="p">)</span>
                    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span><span class="s">&quot;CAPTURE parsing encountered unmatched quote&quot;</span><span class="p">);</span>
        <span class="p">};</span>

        <span class="kt">size_t</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">openings</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">names</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="sc">&#39;[&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;{&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;(&#39;</span><span class="o">:</span>
            <span class="c1">// It is basically impossible to disambiguate between</span>
            <span class="c1">// comparison and start of template args in this context</span>
<span class="c1">//            case &#39;&lt;&#39;:</span>
                <span class="n">openings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;]&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;}&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;)&#39;</span><span class="o">:</span>
<span class="c1">//           case &#39;&gt;&#39;:</span>
                <span class="n">openings</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;&quot;&#39;</span><span class="o">:</span>
            <span class="k">case</span> <span class="sc">&#39;\&#39;&#39;</span><span class="o">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">skipq</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;,&#39;</span><span class="o">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="n">openings</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">m_messages</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">lineInfo</span><span class="p">,</span> <span class="n">resultType</span><span class="p">);</span>
                    <span class="n">m_messages</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">message</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">trimmed</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">pos</span><span class="p">));</span>
                    <span class="n">m_messages</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">message</span> <span class="o">+=</span> <span class="s">&quot; := &quot;</span><span class="p">;</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">openings</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Mismatched openings&quot;</span><span class="p">);</span>
        <span class="n">m_messages</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">macroName</span><span class="p">,</span> <span class="n">lineInfo</span><span class="p">,</span> <span class="n">resultType</span><span class="p">);</span>
        <span class="n">m_messages</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">message</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">trimmed</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">names</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">m_messages</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">message</span> <span class="o">+=</span> <span class="s">&quot; := &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Capturer</span><span class="o">::~</span><span class="n">Capturer</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">uncaught_exceptions</span><span class="p">()</span> <span class="p">){</span>
            <span class="n">assert</span><span class="p">(</span> <span class="n">m_captured</span> <span class="o">==</span> <span class="n">m_messages</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
            <span class="k">for</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_captured</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span>  <span class="p">)</span>
                <span class="n">m_resultCapture</span><span class="p">.</span><span class="n">popScopedMessage</span><span class="p">(</span> <span class="n">m_messages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Capturer</span><span class="o">::</span><span class="n">captureValue</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">m_messages</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">m_messages</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">message</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">m_resultCapture</span><span class="p">.</span><span class="n">pushScopedMessage</span><span class="p">(</span> <span class="n">m_messages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">);</span>
        <span class="n">m_captured</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_message.cpp</span>
<span class="c1">// start catch_output_redirect.cpp</span>

<span class="c1">// start catch_output_redirect.h</span>
<span class="cp">#ifndef TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H</span>
<span class="cp">#define TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">RedirectedStream</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">m_originalStream</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">m_redirectionStream</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">streambuf</span><span class="o">*</span> <span class="n">m_prevBuf</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">RedirectedStream</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">originalStream</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">redirectionStream</span> <span class="p">);</span>
        <span class="o">~</span><span class="n">RedirectedStream</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">RedirectedStdOut</span> <span class="p">{</span>
        <span class="n">ReusableStringStream</span> <span class="n">m_rss</span><span class="p">;</span>
        <span class="n">RedirectedStream</span> <span class="n">m_cout</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">RedirectedStdOut</span><span class="p">();</span>
        <span class="k">auto</span> <span class="nf">str</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="c1">// StdErr has two constituent streams in C++, std::cerr and std::clog</span>
    <span class="c1">// This means that we need to redirect 2 streams into 1 to keep proper</span>
    <span class="c1">// order of writes</span>
    <span class="k">class</span> <span class="nc">RedirectedStdErr</span> <span class="p">{</span>
        <span class="n">ReusableStringStream</span> <span class="n">m_rss</span><span class="p">;</span>
        <span class="n">RedirectedStream</span> <span class="n">m_cerr</span><span class="p">;</span>
        <span class="n">RedirectedStream</span> <span class="n">m_clog</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">RedirectedStdErr</span><span class="p">();</span>
        <span class="k">auto</span> <span class="nf">str</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">RedirectedStreams</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">RedirectedStreams</span><span class="p">(</span><span class="n">RedirectedStreams</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">RedirectedStreams</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">RedirectedStreams</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">RedirectedStreams</span><span class="p">(</span><span class="n">RedirectedStreams</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">RedirectedStreams</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">RedirectedStreams</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="n">RedirectedStreams</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">redirectedCout</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">redirectedCerr</span><span class="p">);</span>
        <span class="o">~</span><span class="n">RedirectedStreams</span><span class="p">();</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">m_redirectedCout</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">m_redirectedCerr</span><span class="p">;</span>
        <span class="n">RedirectedStdOut</span> <span class="n">m_redirectedStdOut</span><span class="p">;</span>
        <span class="n">RedirectedStdErr</span> <span class="n">m_redirectedStdErr</span><span class="p">;</span>
    <span class="p">};</span>

<span class="cp">#if defined(CATCH_CONFIG_NEW_CAPTURE)</span>

    <span class="c1">// Windows&#39;s implementation of std::tmpfile is terrible (it tries</span>
    <span class="c1">// to create a file inside system folder, thus requiring elevated</span>
    <span class="c1">// privileges for the binary), so we have to use tmpnam(_s) and</span>
    <span class="c1">// create the file ourselves there.</span>
    <span class="k">class</span> <span class="nc">TempFile</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">TempFile</span><span class="p">(</span><span class="n">TempFile</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">TempFile</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TempFile</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">TempFile</span><span class="p">(</span><span class="n">TempFile</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">TempFile</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TempFile</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="n">TempFile</span><span class="p">();</span>
        <span class="o">~</span><span class="n">TempFile</span><span class="p">();</span>

        <span class="n">std</span><span class="o">::</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">getFile</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getContents</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">m_file</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="cp">#if defined(_MSC_VER)</span>
        <span class="kt">char</span> <span class="n">m_buffer</span><span class="p">[</span><span class="n">L_tmpnam</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="cp">#endif</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">OutputRedirect</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">OutputRedirect</span><span class="p">(</span><span class="n">OutputRedirect</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">OutputRedirect</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">OutputRedirect</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">OutputRedirect</span><span class="p">(</span><span class="n">OutputRedirect</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">OutputRedirect</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">OutputRedirect</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

        <span class="n">OutputRedirect</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">stdout_dest</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">stderr_dest</span><span class="p">);</span>
        <span class="o">~</span><span class="n">OutputRedirect</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">m_originalStdout</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m_originalStderr</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
        <span class="n">TempFile</span> <span class="n">m_stdoutFile</span><span class="p">;</span>
        <span class="n">TempFile</span> <span class="n">m_stderrFile</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">m_stdoutDest</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">m_stderrDest</span><span class="p">;</span>
    <span class="p">};</span>

<span class="cp">#endif</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#endif </span><span class="c1">// TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H</span>
<span class="c1">// end catch_output_redirect.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp"></span>

<span class="cp">#if defined(CATCH_CONFIG_NEW_CAPTURE)</span>
    <span class="cp">#if defined(_MSC_VER)</span>
    <span class="cp">#include</span> <span class="cpf">&lt;io.h&gt;</span><span class="c1">      //_dup and _dup2</span><span class="cp"></span>
    <span class="cp">#define dup _dup</span>
    <span class="cp">#define dup2 _dup2</span>
    <span class="cp">#define fileno _fileno</span>
    <span class="cp">#else</span>
    <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="c1">  // dup and dup2</span><span class="cp"></span>
    <span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">RedirectedStream</span><span class="o">::</span><span class="n">RedirectedStream</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">originalStream</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">redirectionStream</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_originalStream</span><span class="p">(</span> <span class="n">originalStream</span> <span class="p">),</span>
        <span class="n">m_redirectionStream</span><span class="p">(</span> <span class="n">redirectionStream</span> <span class="p">),</span>
        <span class="n">m_prevBuf</span><span class="p">(</span> <span class="n">m_originalStream</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_originalStream</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">(</span> <span class="n">m_redirectionStream</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">()</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">RedirectedStream</span><span class="o">::~</span><span class="n">RedirectedStream</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_originalStream</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">(</span> <span class="n">m_prevBuf</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">RedirectedStdOut</span><span class="o">::</span><span class="n">RedirectedStdOut</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_cout</span><span class="p">(</span> <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">(),</span> <span class="n">m_rss</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="k">auto</span> <span class="n">RedirectedStdOut</span><span class="o">::</span><span class="n">str</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">RedirectedStdErr</span><span class="o">::</span><span class="n">RedirectedStdErr</span><span class="p">()</span>
    <span class="o">:</span>   <span class="n">m_cerr</span><span class="p">(</span> <span class="n">Catch</span><span class="o">::</span><span class="n">cerr</span><span class="p">(),</span> <span class="n">m_rss</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">),</span>
        <span class="n">m_clog</span><span class="p">(</span> <span class="n">Catch</span><span class="o">::</span><span class="n">clog</span><span class="p">(),</span> <span class="n">m_rss</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{}</span>
    <span class="k">auto</span> <span class="n">RedirectedStdErr</span><span class="o">::</span><span class="n">str</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">RedirectedStreams</span><span class="o">::</span><span class="n">RedirectedStreams</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">redirectedCout</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">redirectedCerr</span><span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_redirectedCout</span><span class="p">(</span><span class="n">redirectedCout</span><span class="p">),</span>
        <span class="n">m_redirectedCerr</span><span class="p">(</span><span class="n">redirectedCerr</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">RedirectedStreams</span><span class="o">::~</span><span class="n">RedirectedStreams</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_redirectedCout</span> <span class="o">+=</span> <span class="n">m_redirectedStdOut</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="n">m_redirectedCerr</span> <span class="o">+=</span> <span class="n">m_redirectedStdErr</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="p">}</span>

<span class="cp">#if defined(CATCH_CONFIG_NEW_CAPTURE)</span>

<span class="cp">#if defined(_MSC_VER)</span>
    <span class="n">TempFile</span><span class="o">::</span><span class="n">TempFile</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmpnam_s</span><span class="p">(</span><span class="n">m_buffer</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">CATCH_RUNTIME_ERROR</span><span class="p">(</span><span class="s">&quot;Could not get a temp filename&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fopen_s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_file</span><span class="p">,</span> <span class="n">m_buffer</span><span class="p">,</span> <span class="s">&quot;w+&quot;</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">strerror_s</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">errno</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">CATCH_RUNTIME_ERROR</span><span class="p">(</span><span class="s">&quot;Could not translate errno to a string&quot;</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">CATCH_RUNTIME_ERROR</span><span class="p">(</span><span class="s">&quot;Could not open the temp file: &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_buffer</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39; because: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="cp">#else</span>
    <span class="n">TempFile</span><span class="o">::</span><span class="n">TempFile</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_file</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tmpfile</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_file</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">CATCH_RUNTIME_ERROR</span><span class="p">(</span><span class="s">&quot;Could not create a temp file.&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="cp">#endif</span>

    <span class="n">TempFile</span><span class="o">::~</span><span class="n">TempFile</span><span class="p">()</span> <span class="p">{</span>
         <span class="c1">// TBD: What to do about errors here?</span>
         <span class="n">std</span><span class="o">::</span><span class="n">fclose</span><span class="p">(</span><span class="n">m_file</span><span class="p">);</span>
         <span class="c1">// We manually create the file on Windows only, on Linux</span>
         <span class="c1">// it will be autodeleted</span>
<span class="cp">#if defined(_MSC_VER)</span>
         <span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">m_buffer</span><span class="p">);</span>
<span class="cp">#endif</span>
    <span class="p">}</span>

    <span class="kt">FILE</span><span class="o">*</span> <span class="n">TempFile</span><span class="o">::</span><span class="n">getFile</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_file</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">TempFile</span><span class="o">::</span><span class="n">getContents</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">sstr</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="n">std</span><span class="o">::</span><span class="n">rewind</span><span class="p">(</span><span class="n">m_file</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">m_file</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">sstr</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">OutputRedirect</span><span class="o">::</span><span class="n">OutputRedirect</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">stdout_dest</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">stderr_dest</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">m_originalStdout</span><span class="p">(</span><span class="n">dup</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
        <span class="n">m_originalStderr</span><span class="p">(</span><span class="n">dup</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
        <span class="n">m_stdoutDest</span><span class="p">(</span><span class="n">stdout_dest</span><span class="p">),</span>
        <span class="n">m_stderrDest</span><span class="p">(</span><span class="n">stderr_dest</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">fileno</span><span class="p">(</span><span class="n">m_stdoutFile</span><span class="p">.</span><span class="n">getFile</span><span class="p">()),</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">fileno</span><span class="p">(</span><span class="n">m_stderrFile</span><span class="p">.</span><span class="n">getFile</span><span class="p">()),</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">OutputRedirect</span><span class="o">::~</span><span class="n">OutputRedirect</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
        <span class="c1">// Since we support overriding these streams, we flush cerr</span>
        <span class="c1">// even though std::cerr is unbuffered</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">cerr</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">clog</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">stderr</span><span class="p">);</span>

        <span class="n">dup2</span><span class="p">(</span><span class="n">m_originalStdout</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">m_originalStderr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

        <span class="n">m_stdoutDest</span> <span class="o">+=</span> <span class="n">m_stdoutFile</span><span class="p">.</span><span class="n">getContents</span><span class="p">();</span>
        <span class="n">m_stderrDest</span> <span class="o">+=</span> <span class="n">m_stderrFile</span><span class="p">.</span><span class="n">getContents</span><span class="p">();</span>
    <span class="p">}</span>

<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_NEW_CAPTURE</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="cp">#if defined(CATCH_CONFIG_NEW_CAPTURE)</span>
    <span class="cp">#if defined(_MSC_VER)</span>
    <span class="cp">#undef dup</span>
    <span class="cp">#undef dup2</span>
    <span class="cp">#undef fileno</span>
    <span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="c1">// end catch_output_redirect.cpp</span>
<span class="c1">// start catch_polyfills.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

<span class="cp">#if !defined(CATCH_CONFIG_POLYFILL_ISNAN)</span>
    <span class="kt">bool</span> <span class="nf">isnan</span><span class="p">(</span><span class="kt">float</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">isnan</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#else</span>
    <span class="c1">// For now we only use this for embarcadero</span>
    <span class="kt">bool</span> <span class="nf">isnan</span><span class="p">(</span><span class="kt">float</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">_isnan</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">isnan</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">_isnan</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_polyfills.cpp</span>
<span class="c1">// start catch_random_number_generator.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

<span class="k">namespace</span> <span class="p">{</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#pragma warning(push)</span>
<span class="cp">#pragma warning(disable:4146) </span><span class="c1">// we negate uint32 during the rotate</span>
<span class="cp">#endif</span>
        <span class="c1">// Safe rotr implementation thanks to John Regehr</span>
        <span class="kt">uint32_t</span> <span class="nf">rotate_right</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">val</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
            <span class="n">count</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="n">count</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">-</span><span class="n">count</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">));</span>
        <span class="p">}</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#pragma warning(pop)</span>
<span class="cp">#endif</span>

<span class="p">}</span>

    <span class="n">SimplePcg32</span><span class="o">::</span><span class="n">SimplePcg32</span><span class="p">(</span><span class="n">result_type</span> <span class="n">seed_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">seed</span><span class="p">(</span><span class="n">seed_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">SimplePcg32</span><span class="o">::</span><span class="n">seed</span><span class="p">(</span><span class="n">result_type</span> <span class="n">seed_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)();</span>
        <span class="n">m_state</span> <span class="o">+=</span> <span class="n">seed_</span><span class="p">;</span>
        <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">SimplePcg32</span><span class="o">::</span><span class="n">discard</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We could implement this to run in O(log n) steps, but this</span>
        <span class="c1">// should suffice for our use case.</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">skip</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">((</span><span class="o">*</span><span class="k">this</span><span class="p">)());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">SimplePcg32</span><span class="o">::</span><span class="n">result_type</span> <span class="n">SimplePcg32</span><span class="o">::</span><span class="k">operator</span><span class="p">()()</span> <span class="p">{</span>
        <span class="c1">// prepare the output value</span>
        <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">xorshifted</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(((</span><span class="n">m_state</span> <span class="o">&gt;&gt;</span> <span class="mi">18u</span><span class="p">)</span> <span class="o">^</span> <span class="n">m_state</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">27u</span><span class="p">);</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">output</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">xorshifted</span><span class="p">,</span> <span class="n">m_state</span> <span class="o">&gt;&gt;</span> <span class="mi">59u</span><span class="p">);</span>

        <span class="c1">// advance state</span>
        <span class="n">m_state</span> <span class="o">=</span> <span class="n">m_state</span> <span class="o">*</span> <span class="mi">6364136223846793005ULL</span> <span class="o">+</span> <span class="n">s_inc</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">SimplePcg32</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">SimplePcg32</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">m_state</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m_state</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">SimplePcg32</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">SimplePcg32</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">m_state</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m_state</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// end catch_random_number_generator.cpp</span>
<span class="c1">// start catch_registry_hub.cpp</span>

<span class="c1">// start catch_test_case_registry_impl.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ios&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">TestCase</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">IConfig</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">sortTests</span><span class="p">(</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">unsortedTestCases</span> <span class="p">);</span>

    <span class="kt">bool</span> <span class="nf">isThrowSafe</span><span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">matchTest</span><span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span><span class="p">,</span> <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="nf">enforceNoDuplicateTestCases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">functions</span> <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">filterTests</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCases</span><span class="p">,</span> <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getAllTestCasesSorted</span><span class="p">(</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">);</span>

    <span class="k">class</span> <span class="nc">TestRegistry</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ITestCaseRegistry</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">TestRegistry</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">registerTest</span><span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getAllTests</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getAllTestsSorted</span><span class="p">(</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">m_functions</span><span class="p">;</span>
        <span class="k">mutable</span> <span class="n">RunTests</span><span class="o">::</span><span class="n">InWhatOrder</span> <span class="n">m_currentSortOrder</span> <span class="o">=</span> <span class="n">RunTests</span><span class="o">::</span><span class="n">InDeclarationOrder</span><span class="p">;</span>
        <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">m_sortedFunctions</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">m_unnamedCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ios_base</span><span class="o">::</span><span class="n">Init</span> <span class="n">m_ostreamInit</span><span class="p">;</span> <span class="c1">// Forces cout/ cerr to be initialised</span>
    <span class="p">};</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////</span>

    <span class="k">class</span> <span class="nc">TestInvokerAsFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ITestInvoker</span> <span class="p">{</span>
        <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">m_testAsFunction</span><span class="p">)();</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">TestInvokerAsFunction</span><span class="p">(</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">testAsFunction</span><span class="p">)()</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">invoke</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">extractClassName</span><span class="p">(</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">classOrQualifiedMethodName</span> <span class="p">);</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_test_case_registry_impl.h</span>
<span class="c1">// start catch_reporter_registry.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">ReporterRegistry</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IReporterRegistry</span> <span class="p">{</span>

    <span class="k">public</span><span class="o">:</span>

        <span class="o">~</span><span class="n">ReporterRegistry</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="n">IStreamingReporterPtr</span> <span class="nf">create</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">registerReporter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">IReporterFactoryPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">factory</span> <span class="p">);</span>
        <span class="kt">void</span> <span class="nf">registerListener</span><span class="p">(</span> <span class="n">IReporterFactoryPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">factory</span> <span class="p">);</span>

        <span class="n">FactoryMap</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getFactories</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">Listeners</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getListeners</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">FactoryMap</span> <span class="n">m_factories</span><span class="p">;</span>
        <span class="n">Listeners</span> <span class="n">m_listeners</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// end catch_reporter_registry.h</span>
<span class="c1">// start catch_tag_alias_registry.h</span>

<span class="c1">// start catch_tag_alias.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">TagAlias</span> <span class="p">{</span>
        <span class="n">TagAlias</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_tag</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="n">_lineInfo</span><span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tag</span><span class="p">;</span>
        <span class="n">SourceLineInfo</span> <span class="n">lineInfo</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_tag_alias.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">TagAliasRegistry</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ITagAliasRegistry</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="o">~</span><span class="n">TagAliasRegistry</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">TagAlias</span> <span class="k">const</span><span class="o">*</span> <span class="n">find</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">alias</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expandAliases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">unexpandedTestSpec</span> <span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">alias</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tag</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">);</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">TagAlias</span><span class="o">&gt;</span> <span class="n">m_registry</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_tag_alias_registry.h</span>
<span class="c1">// start catch_startup_exception_registry.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">StartupExceptionRegistry</span> <span class="p">{</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">exception</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getExceptions</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&gt;</span> <span class="n">m_exceptions</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_startup_exception_registry.h</span>
<span class="c1">// start catch_singletons.hpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="nc">ISingleton</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">ISingleton</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">addSingleton</span><span class="p">(</span> <span class="n">ISingleton</span><span class="o">*</span> <span class="n">singleton</span> <span class="p">);</span>
    <span class="kt">void</span> <span class="nf">cleanupSingletons</span><span class="p">();</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">SingletonImplT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">InterfaceT</span> <span class="o">=</span> <span class="n">SingletonImplT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">MutableInterfaceT</span> <span class="o">=</span> <span class="n">InterfaceT</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Singleton</span> <span class="o">:</span> <span class="n">SingletonImplT</span><span class="p">,</span> <span class="k">public</span> <span class="n">ISingleton</span> <span class="p">{</span>

        <span class="k">static</span> <span class="k">auto</span> <span class="n">getInternal</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Singleton</span><span class="o">*</span> <span class="p">{</span>
            <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">s_instance</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">s_instance</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">s_instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="p">;</span>
                <span class="n">addSingleton</span><span class="p">(</span> <span class="n">s_instance</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">s_instance</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">get</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">InterfaceT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">*</span><span class="nf">getInternal</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">getMutable</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">MutableInterfaceT</span><span class="o">&amp;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">*</span><span class="nf">getInternal</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="c1">// end catch_singletons.hpp</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="p">{</span>

        <span class="k">class</span> <span class="nc">RegistryHub</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IRegistryHub</span><span class="p">,</span> <span class="k">public</span> <span class="n">IMutableRegistryHub</span><span class="p">,</span>
                            <span class="k">private</span> <span class="n">NonCopyable</span> <span class="p">{</span>

        <span class="k">public</span><span class="o">:</span> <span class="c1">// IRegistryHub</span>
            <span class="n">RegistryHub</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
            <span class="n">IReporterRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getReporterRegistry</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">m_reporterRegistry</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ITestCaseRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getTestCaseRegistry</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">m_testCaseRegistry</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">IExceptionTranslatorRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getExceptionTranslatorRegistry</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">m_exceptionTranslatorRegistry</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ITagAliasRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getTagAliasRegistry</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">m_tagAliasRegistry</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">StartupExceptionRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getStartupExceptionRegistry</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">m_exceptionRegistry</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="k">public</span><span class="o">:</span> <span class="c1">// IMutableRegistryHub</span>
            <span class="kt">void</span> <span class="n">registerReporter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">IReporterFactoryPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">factory</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">m_reporterRegistry</span><span class="p">.</span><span class="n">registerReporter</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span> <span class="n">factory</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="kt">void</span> <span class="n">registerListener</span><span class="p">(</span> <span class="n">IReporterFactoryPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">factory</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">m_reporterRegistry</span><span class="p">.</span><span class="n">registerListener</span><span class="p">(</span> <span class="n">factory</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="kt">void</span> <span class="n">registerTest</span><span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">m_testCaseRegistry</span><span class="p">.</span><span class="n">registerTest</span><span class="p">(</span> <span class="n">testInfo</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="kt">void</span> <span class="n">registerTranslator</span><span class="p">(</span> <span class="k">const</span> <span class="n">IExceptionTranslator</span><span class="o">*</span> <span class="n">translator</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">m_exceptionTranslatorRegistry</span><span class="p">.</span><span class="n">registerTranslator</span><span class="p">(</span> <span class="n">translator</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="kt">void</span> <span class="n">registerTagAlias</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">alias</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tag</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">m_tagAliasRegistry</span><span class="p">.</span><span class="n">add</span><span class="p">(</span> <span class="n">alias</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">lineInfo</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="kt">void</span> <span class="n">registerStartupException</span><span class="p">()</span> <span class="k">noexcept</span> <span class="k">override</span> <span class="p">{</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
                <span class="n">m_exceptionRegistry</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
<span class="cp">#else</span>
                <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span><span class="s">&quot;Attempted to register active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
            <span class="p">}</span>
            <span class="n">IMutableEnumValuesRegistry</span><span class="o">&amp;</span> <span class="n">getMutableEnumValuesRegistry</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">m_enumValuesRegistry</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="k">private</span><span class="o">:</span>
            <span class="n">TestRegistry</span> <span class="n">m_testCaseRegistry</span><span class="p">;</span>
            <span class="n">ReporterRegistry</span> <span class="n">m_reporterRegistry</span><span class="p">;</span>
            <span class="n">ExceptionTranslatorRegistry</span> <span class="n">m_exceptionTranslatorRegistry</span><span class="p">;</span>
            <span class="n">TagAliasRegistry</span> <span class="n">m_tagAliasRegistry</span><span class="p">;</span>
            <span class="n">StartupExceptionRegistry</span> <span class="n">m_exceptionRegistry</span><span class="p">;</span>
            <span class="n">Detail</span><span class="o">::</span><span class="n">EnumValuesRegistry</span> <span class="n">m_enumValuesRegistry</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">using</span> <span class="n">RegistryHubSingleton</span> <span class="o">=</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">RegistryHub</span><span class="p">,</span> <span class="n">IRegistryHub</span><span class="p">,</span> <span class="n">IMutableRegistryHub</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">IRegistryHub</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getRegistryHub</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">RegistryHubSingleton</span><span class="o">::</span><span class="n">get</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">IMutableRegistryHub</span><span class="o">&amp;</span> <span class="n">getMutableRegistryHub</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">RegistryHubSingleton</span><span class="o">::</span><span class="n">getMutable</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">cleanUp</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">cleanupSingletons</span><span class="p">();</span>
        <span class="n">cleanUpContext</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">translateActiveException</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getRegistryHub</span><span class="p">().</span><span class="n">getExceptionTranslatorRegistry</span><span class="p">().</span><span class="n">translateActiveException</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_registry_hub.cpp</span>
<span class="c1">// start catch_reporter_registry.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">ReporterRegistry</span><span class="o">::~</span><span class="n">ReporterRegistry</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">IStreamingReporterPtr</span> <span class="n">ReporterRegistry</span><span class="o">::</span><span class="n">create</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span>  <span class="n">m_factories</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">name</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">it</span> <span class="o">==</span> <span class="n">m_factories</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span>
            <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span> <span class="n">ReporterConfig</span><span class="p">(</span> <span class="n">config</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ReporterRegistry</span><span class="o">::</span><span class="n">registerReporter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">IReporterFactoryPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">factory</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_factories</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">factory</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">ReporterRegistry</span><span class="o">::</span><span class="n">registerListener</span><span class="p">(</span> <span class="n">IReporterFactoryPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">factory</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_listeners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">factory</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">IReporterRegistry</span><span class="o">::</span><span class="n">FactoryMap</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ReporterRegistry</span><span class="o">::</span><span class="n">getFactories</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_factories</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">IReporterRegistry</span><span class="o">::</span><span class="n">Listeners</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ReporterRegistry</span><span class="o">::</span><span class="n">getListeners</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_listeners</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="c1">// end catch_reporter_registry.cpp</span>
<span class="c1">// start catch_result_type.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="kt">bool</span> <span class="nf">isOk</span><span class="p">(</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">resultType</span> <span class="o">&amp;</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">FailureBit</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">isJustInfo</span><span class="p">(</span> <span class="kt">int</span> <span class="n">flags</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">flags</span> <span class="o">==</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Info</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Flags</span> <span class="k">operator</span> <span class="o">|</span> <span class="p">(</span> <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Flags</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Flags</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Flags</span><span class="o">&gt;</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">lhs</span> <span class="p">)</span> <span class="o">|</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">rhs</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">shouldContinueOnFailure</span><span class="p">(</span> <span class="kt">int</span> <span class="n">flags</span> <span class="p">)</span>    <span class="p">{</span> <span class="k">return</span> <span class="p">(</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">ContinueOnFailure</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">shouldSuppressFailure</span><span class="p">(</span> <span class="kt">int</span> <span class="n">flags</span> <span class="p">)</span>      <span class="p">{</span> <span class="k">return</span> <span class="p">(</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">SuppressFail</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_result_type.cpp</span>
<span class="c1">// start catch_run_context.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="n">Generators</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">GeneratorTracker</span> <span class="o">:</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">TrackerBase</span><span class="p">,</span> <span class="n">IGeneratorTracker</span> <span class="p">{</span>
            <span class="n">GeneratorBasePtr</span> <span class="n">m_generator</span><span class="p">;</span>

            <span class="n">GeneratorTracker</span><span class="p">(</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span><span class="p">,</span> <span class="n">TrackerContext</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ITracker</span><span class="o">*</span> <span class="n">parent</span> <span class="p">)</span>
            <span class="o">:</span>   <span class="n">TrackerBase</span><span class="p">(</span> <span class="n">nameAndLocation</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">parent</span> <span class="p">)</span>
            <span class="p">{}</span>
            <span class="o">~</span><span class="n">GeneratorTracker</span><span class="p">();</span>

            <span class="k">static</span> <span class="n">GeneratorTracker</span><span class="o">&amp;</span> <span class="n">acquire</span><span class="p">(</span> <span class="n">TrackerContext</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">GeneratorTracker</span><span class="o">&gt;</span> <span class="n">tracker</span><span class="p">;</span>

                <span class="n">ITracker</span><span class="o">&amp;</span> <span class="n">currentTracker</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">currentTracker</span><span class="p">();</span>
                <span class="c1">// Under specific circumstances, the generator we want</span>
                <span class="c1">// to acquire is also the current tracker. If this is</span>
                <span class="c1">// the case, we have to avoid looking through current</span>
                <span class="c1">// tracker&#39;s children, and instead return the current</span>
                <span class="c1">// tracker.</span>
                <span class="c1">// A case where this check is important is e.g.</span>
                <span class="c1">//     for (int i = 0; i &lt; 5; ++i) {</span>
                <span class="c1">//         int n = GENERATE(1, 2);</span>
                <span class="c1">//     }</span>
                <span class="c1">//</span>
                <span class="c1">// without it, the code above creates 5 nested generators.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">currentTracker</span><span class="p">.</span><span class="n">nameAndLocation</span><span class="p">()</span> <span class="o">==</span> <span class="n">nameAndLocation</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">auto</span> <span class="n">thisTracker</span> <span class="o">=</span> <span class="n">currentTracker</span><span class="p">.</span><span class="n">parent</span><span class="p">().</span><span class="n">findChild</span><span class="p">(</span><span class="n">nameAndLocation</span><span class="p">);</span>
                    <span class="n">assert</span><span class="p">(</span><span class="n">thisTracker</span><span class="p">);</span>
                    <span class="n">assert</span><span class="p">(</span><span class="n">thisTracker</span><span class="o">-&gt;</span><span class="n">isGeneratorTracker</span><span class="p">());</span>
                    <span class="n">tracker</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">GeneratorTracker</span><span class="o">&gt;</span><span class="p">(</span><span class="n">thisTracker</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">ITrackerPtr</span> <span class="n">childTracker</span> <span class="o">=</span> <span class="n">currentTracker</span><span class="p">.</span><span class="n">findChild</span><span class="p">(</span> <span class="n">nameAndLocation</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">assert</span><span class="p">(</span> <span class="n">childTracker</span> <span class="p">);</span>
                    <span class="n">assert</span><span class="p">(</span> <span class="n">childTracker</span><span class="o">-&gt;</span><span class="n">isGeneratorTracker</span><span class="p">()</span> <span class="p">);</span>
                    <span class="n">tracker</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">GeneratorTracker</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">childTracker</span> <span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">tracker</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">GeneratorTracker</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">nameAndLocation</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">currentTracker</span> <span class="p">);</span>
                    <span class="n">currentTracker</span><span class="p">.</span><span class="n">addChild</span><span class="p">(</span> <span class="n">tracker</span> <span class="p">);</span>
                <span class="p">}</span>

                <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">tracker</span><span class="o">-&gt;</span><span class="n">isComplete</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">tracker</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">();</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="o">*</span><span class="n">tracker</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// TrackerBase interface</span>
            <span class="kt">bool</span> <span class="n">isGeneratorTracker</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
            <span class="k">auto</span> <span class="n">hasGenerator</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">!!</span><span class="n">m_generator</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">void</span> <span class="n">close</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">TrackerBase</span><span class="o">::</span><span class="n">close</span><span class="p">();</span>
                <span class="c1">// If a generator has a child (it is followed by a section)</span>
                <span class="c1">// and none of its children have started, then we must wait</span>
                <span class="c1">// until later to start consuming its values.</span>
                <span class="c1">// This catches cases where `GENERATE` is placed between two</span>
                <span class="c1">// `SECTION`s.</span>
                <span class="c1">// **The check for m_children.empty cannot be removed**.</span>
                <span class="c1">// doing so would break `GENERATE` _not_ followed by `SECTION`s.</span>
                <span class="k">const</span> <span class="kt">bool</span> <span class="n">should_wait_for_child</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span>
                    <span class="c1">// No children -&gt; nobody to wait for</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">m_children</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="c1">// If at least one child started executing, don&#39;t wait</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>
                             <span class="n">m_children</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                             <span class="n">m_children</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                             <span class="p">[](</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">ITrackerPtr</span> <span class="n">tracker</span> <span class="p">)</span> <span class="p">{</span>
                                 <span class="k">return</span> <span class="n">tracker</span><span class="o">-&gt;</span><span class="n">hasStarted</span><span class="p">();</span>
                             <span class="p">}</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">m_children</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="c1">// No children have started. We need to check if they _can_</span>
                    <span class="c1">// start, and thus we should wait for them, or they cannot</span>
                    <span class="c1">// start (due to filters), and we shouldn&#39;t wait for them</span>
                    <span class="k">auto</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">m_parent</span><span class="p">;</span>
                    <span class="c1">// This is safe: there is always at least one section</span>
                    <span class="c1">// tracker in a test case tracking tree</span>
                    <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">isSectionTracker</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">()</span> <span class="p">);</span>
                    <span class="p">}</span>
                    <span class="n">assert</span><span class="p">(</span> <span class="n">parent</span> <span class="o">&amp;&amp;</span>
                            <span class="s">&quot;Missing root (test case) level section&quot;</span> <span class="p">);</span>

                    <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">parentSection</span> <span class="o">=</span>
                        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">SectionTracker</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="n">parent</span> <span class="p">);</span>
                    <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filters</span> <span class="o">=</span> <span class="n">parentSection</span><span class="p">.</span><span class="n">getFilters</span><span class="p">();</span>
                    <span class="c1">// No filters -&gt; no restrictions on running sections</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">filters</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">child</span> <span class="p">:</span> <span class="n">m_children</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">isSectionTracker</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
                             <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span> <span class="n">filters</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                                        <span class="n">filters</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                                        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">SectionTracker</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="n">child</span> <span class="p">)</span>
                                            <span class="p">.</span><span class="n">trimmedName</span><span class="p">()</span> <span class="p">)</span> <span class="o">!=</span>
                                 <span class="n">filters</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}();</span>

                <span class="c1">// This check is a bit tricky, because m_generator-&gt;next()</span>
                <span class="c1">// has a side-effect, where it consumes generator&#39;s current</span>
                <span class="c1">// value, but we do not want to invoke the side-effect if</span>
                <span class="c1">// this generator is still waiting for any child to start.</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">should_wait_for_child</span> <span class="o">||</span>
                     <span class="p">(</span> <span class="n">m_runState</span> <span class="o">==</span> <span class="n">CompletedSuccessfully</span> <span class="o">&amp;&amp;</span>
                       <span class="n">m_generator</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">m_children</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
                    <span class="n">m_runState</span> <span class="o">=</span> <span class="n">Executing</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// IGeneratorTracker interface</span>
            <span class="k">auto</span> <span class="n">getGenerator</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">GeneratorBasePtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">m_generator</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">void</span> <span class="n">setGenerator</span><span class="p">(</span> <span class="n">GeneratorBasePtr</span><span class="o">&amp;&amp;</span> <span class="n">generator</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">m_generator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">generator</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>
        <span class="n">GeneratorTracker</span><span class="o">::~</span><span class="n">GeneratorTracker</span><span class="p">()</span> <span class="p">{}</span>
    <span class="p">}</span>

    <span class="n">RunContext</span><span class="o">::</span><span class="n">RunContext</span><span class="p">(</span><span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_config</span><span class="p">,</span> <span class="n">IStreamingReporterPtr</span><span class="o">&amp;&amp;</span> <span class="n">reporter</span><span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_runInfo</span><span class="p">(</span><span class="n">_config</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()),</span>
        <span class="n">m_context</span><span class="p">(</span><span class="n">getCurrentMutableContext</span><span class="p">()),</span>
        <span class="n">m_config</span><span class="p">(</span><span class="n">_config</span><span class="p">),</span>
        <span class="n">m_reporter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">reporter</span><span class="p">)),</span>
        <span class="n">m_lastAssertionInfo</span><span class="p">{</span> <span class="n">StringRef</span><span class="p">(),</span> <span class="n">SourceLineInfo</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">StringRef</span><span class="p">(),</span> <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Normal</span> <span class="p">},</span>
        <span class="n">m_includeSuccessfulResults</span><span class="p">(</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">includeSuccessfulResults</span><span class="p">()</span> <span class="o">||</span> <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">getPreferences</span><span class="p">().</span><span class="n">shouldReportAllAssertions</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_context</span><span class="p">.</span><span class="n">setRunner</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="n">m_context</span><span class="p">.</span><span class="n">setConfig</span><span class="p">(</span><span class="n">m_config</span><span class="p">);</span>
        <span class="n">m_context</span><span class="p">.</span><span class="n">setResultCapture</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testRunStarting</span><span class="p">(</span><span class="n">m_runInfo</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">RunContext</span><span class="o">::~</span><span class="n">RunContext</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testRunEnded</span><span class="p">(</span><span class="n">TestRunStats</span><span class="p">(</span><span class="n">m_runInfo</span><span class="p">,</span> <span class="n">m_totals</span><span class="p">,</span> <span class="n">aborting</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">testGroupStarting</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">groupIndex</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">groupsCount</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testGroupStarting</span><span class="p">(</span><span class="n">GroupInfo</span><span class="p">(</span><span class="n">testSpec</span><span class="p">,</span> <span class="n">groupIndex</span><span class="p">,</span> <span class="n">groupsCount</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">testGroupEnded</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">totals</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">groupIndex</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">groupsCount</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testGroupEnded</span><span class="p">(</span><span class="n">TestGroupStats</span><span class="p">(</span><span class="n">GroupInfo</span><span class="p">(</span><span class="n">testSpec</span><span class="p">,</span> <span class="n">groupIndex</span><span class="p">,</span> <span class="n">groupsCount</span><span class="p">),</span> <span class="n">totals</span><span class="p">,</span> <span class="n">aborting</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="n">Totals</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">runTest</span><span class="p">(</span><span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Totals</span> <span class="n">prevTotals</span> <span class="o">=</span> <span class="n">m_totals</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">redirectedCout</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">redirectedCerr</span><span class="p">;</span>

        <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="o">=</span> <span class="n">testCase</span><span class="p">.</span><span class="n">getTestCaseInfo</span><span class="p">();</span>

        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testCaseStarting</span><span class="p">(</span><span class="n">testInfo</span><span class="p">);</span>

        <span class="n">m_activeTestCase</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">testCase</span><span class="p">;</span>

        <span class="n">ITracker</span><span class="o">&amp;</span> <span class="n">rootTracker</span> <span class="o">=</span> <span class="n">m_trackerContext</span><span class="p">.</span><span class="n">startRun</span><span class="p">();</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">rootTracker</span><span class="p">.</span><span class="n">isSectionTracker</span><span class="p">());</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">SectionTracker</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">rootTracker</span><span class="p">).</span><span class="n">addInitialFilters</span><span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">getSectionsToRun</span><span class="p">());</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">m_trackerContext</span><span class="p">.</span><span class="n">startCycle</span><span class="p">();</span>
            <span class="n">m_testCaseTracker</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">SectionTracker</span><span class="o">::</span><span class="n">acquire</span><span class="p">(</span><span class="n">m_trackerContext</span><span class="p">,</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">NameAndLocation</span><span class="p">(</span><span class="n">testInfo</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">testInfo</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">));</span>
            <span class="n">runCurrentTest</span><span class="p">(</span><span class="n">redirectedCout</span><span class="p">,</span> <span class="n">redirectedCerr</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">m_testCaseTracker</span><span class="o">-&gt;</span><span class="n">isSuccessfullyCompleted</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">aborting</span><span class="p">());</span>

        <span class="n">Totals</span> <span class="n">deltaTotals</span> <span class="o">=</span> <span class="n">m_totals</span><span class="p">.</span><span class="n">delta</span><span class="p">(</span><span class="n">prevTotals</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">testInfo</span><span class="p">.</span><span class="n">expectedToFail</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">deltaTotals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">passed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">deltaTotals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="o">++</span><span class="p">;</span>
            <span class="n">deltaTotals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">passed</span><span class="o">--</span><span class="p">;</span>
            <span class="n">deltaTotals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m_totals</span><span class="p">.</span><span class="n">testCases</span> <span class="o">+=</span> <span class="n">deltaTotals</span><span class="p">.</span><span class="n">testCases</span><span class="p">;</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testCaseEnded</span><span class="p">(</span><span class="n">TestCaseStats</span><span class="p">(</span><span class="n">testInfo</span><span class="p">,</span>
                                  <span class="n">deltaTotals</span><span class="p">,</span>
                                  <span class="n">redirectedCout</span><span class="p">,</span>
                                  <span class="n">redirectedCerr</span><span class="p">,</span>
                                  <span class="n">aborting</span><span class="p">()));</span>

        <span class="n">m_activeTestCase</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">m_testCaseTracker</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">deltaTotals</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">IConfigPtr</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">config</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_config</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">IStreamingReporter</span><span class="o">&amp;</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">reporter</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_reporter</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">assertionEnded</span><span class="p">(</span><span class="n">AssertionResult</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">getResultType</span><span class="p">()</span> <span class="o">==</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Ok</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">passed</span><span class="o">++</span><span class="p">;</span>
            <span class="n">m_lastAssertionPassed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">isOk</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">m_lastAssertionPassed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_activeTestCase</span><span class="o">-&gt;</span><span class="n">getTestCaseInfo</span><span class="p">().</span><span class="n">okToFail</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">m_totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failedButOk</span><span class="o">++</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">m_totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">m_lastAssertionPassed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// We have no use for the return value (whether messages should be cleared), because messages were made scoped</span>
        <span class="c1">// and should be let to clear themselves out.</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">assertionEnded</span><span class="p">(</span><span class="n">AssertionStats</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">m_messages</span><span class="p">,</span> <span class="n">m_totals</span><span class="p">)));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">getResultType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Warning</span><span class="p">)</span>
            <span class="n">m_messageScopes</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

        <span class="c1">// Reset working state</span>
        <span class="n">resetAssertionInfo</span><span class="p">();</span>
        <span class="n">m_lastResult</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">resetAssertionInfo</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_lastAssertionInfo</span><span class="p">.</span><span class="n">macroName</span> <span class="o">=</span> <span class="n">StringRef</span><span class="p">();</span>
        <span class="n">m_lastAssertionInfo</span><span class="p">.</span><span class="n">capturedExpression</span> <span class="o">=</span> <span class="s">&quot;{Unknown expression after the reported line}&quot;</span><span class="n">_sr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">sectionStarted</span><span class="p">(</span><span class="n">SectionInfo</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">sectionInfo</span><span class="p">,</span> <span class="n">Counts</span> <span class="o">&amp;</span> <span class="n">assertions</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ITracker</span><span class="o">&amp;</span> <span class="n">sectionTracker</span> <span class="o">=</span> <span class="n">SectionTracker</span><span class="o">::</span><span class="n">acquire</span><span class="p">(</span><span class="n">m_trackerContext</span><span class="p">,</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">NameAndLocation</span><span class="p">(</span><span class="n">sectionInfo</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">sectionInfo</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sectionTracker</span><span class="p">.</span><span class="n">isOpen</span><span class="p">())</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">m_activeSections</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sectionTracker</span><span class="p">);</span>

        <span class="n">m_lastAssertionInfo</span><span class="p">.</span><span class="n">lineInfo</span> <span class="o">=</span> <span class="n">sectionInfo</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">;</span>

        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">sectionStarting</span><span class="p">(</span><span class="n">sectionInfo</span><span class="p">);</span>

        <span class="n">assertions</span> <span class="o">=</span> <span class="n">m_totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">acquireGeneratorTracker</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">generatorName</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IGeneratorTracker</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">using</span> <span class="k">namespace</span> <span class="n">Generators</span><span class="p">;</span>
        <span class="n">GeneratorTracker</span><span class="o">&amp;</span> <span class="n">tracker</span> <span class="o">=</span> <span class="n">GeneratorTracker</span><span class="o">::</span><span class="n">acquire</span><span class="p">(</span><span class="n">m_trackerContext</span><span class="p">,</span>
                                                              <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">NameAndLocation</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">generatorName</span><span class="p">),</span> <span class="n">lineInfo</span> <span class="p">)</span> <span class="p">);</span>
        <span class="n">m_lastAssertionInfo</span><span class="p">.</span><span class="n">lineInfo</span> <span class="o">=</span> <span class="n">lineInfo</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">tracker</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">testForMissingAssertions</span><span class="p">(</span><span class="n">Counts</span><span class="o">&amp;</span> <span class="n">assertions</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">assertions</span><span class="p">.</span><span class="n">total</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">warnAboutMissingAssertions</span><span class="p">())</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_trackerContext</span><span class="p">.</span><span class="n">currentTracker</span><span class="p">().</span><span class="n">hasChildren</span><span class="p">())</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">m_totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="o">++</span><span class="p">;</span>
        <span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">sectionEnded</span><span class="p">(</span><span class="n">SectionEndInfo</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">endInfo</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Counts</span> <span class="n">assertions</span> <span class="o">=</span> <span class="n">m_totals</span><span class="p">.</span><span class="n">assertions</span> <span class="o">-</span> <span class="n">endInfo</span><span class="p">.</span><span class="n">prevAssertions</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">missingAssertions</span> <span class="o">=</span> <span class="n">testForMissingAssertions</span><span class="p">(</span><span class="n">assertions</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_activeSections</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">m_activeSections</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>
            <span class="n">m_activeSections</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">sectionEnded</span><span class="p">(</span><span class="n">SectionStats</span><span class="p">(</span><span class="n">endInfo</span><span class="p">.</span><span class="n">sectionInfo</span><span class="p">,</span> <span class="n">assertions</span><span class="p">,</span> <span class="n">endInfo</span><span class="p">.</span><span class="n">durationInSeconds</span><span class="p">,</span> <span class="n">missingAssertions</span><span class="p">));</span>
        <span class="n">m_messages</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">m_messageScopes</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">sectionEndedEarly</span><span class="p">(</span><span class="n">SectionEndInfo</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">endInfo</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_unfinishedSections</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
            <span class="n">m_activeSections</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">fail</span><span class="p">();</span>
        <span class="k">else</span>
            <span class="n">m_activeSections</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>
        <span class="n">m_activeSections</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

        <span class="n">m_unfinishedSections</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">endInfo</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">benchmarkPreparing</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">benchmarkPreparing</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">benchmarkStarting</span><span class="p">(</span> <span class="n">BenchmarkInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">benchmarkStarting</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">benchmarkEnded</span><span class="p">(</span> <span class="n">BenchmarkStats</span><span class="o">&lt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">benchmarkEnded</span><span class="p">(</span> <span class="n">stats</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">benchmarkFailed</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">benchmarkFailed</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">pushScopedMessage</span><span class="p">(</span><span class="n">MessageInfo</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_messages</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">popScopedMessage</span><span class="p">(</span><span class="n">MessageInfo</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_messages</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">m_messages</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_messages</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">message</span><span class="p">),</span> <span class="n">m_messages</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">emplaceUnscopedMessage</span><span class="p">(</span> <span class="n">MessageBuilder</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">builder</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_messageScopes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">builder</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">getCurrentTestName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_activeTestCase</span>
            <span class="o">?</span> <span class="n">m_activeTestCase</span><span class="o">-&gt;</span><span class="n">getTestCaseInfo</span><span class="p">().</span><span class="nl">name</span>
            <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">AssertionResult</span> <span class="o">*</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">getLastResult</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">m_lastResult</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">exceptionEarlyReported</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_shouldReportUnexpected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">handleFatalErrorCondition</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">message</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// First notify reporter that bad things happened</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">fatalErrorEncountered</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>

        <span class="c1">// Don&#39;t rebuild the result -- the stringification itself can cause more fatal errors</span>
        <span class="c1">// Instead, fake a result data.</span>
        <span class="n">AssertionResultData</span> <span class="nf">tempResult</span><span class="p">(</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">FatalErrorCondition</span><span class="p">,</span> <span class="p">{</span> <span class="nb">false</span> <span class="p">}</span> <span class="p">);</span>
        <span class="n">tempResult</span><span class="p">.</span><span class="n">message</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
        <span class="n">AssertionResult</span> <span class="nf">result</span><span class="p">(</span><span class="n">m_lastAssertionInfo</span><span class="p">,</span> <span class="n">tempResult</span><span class="p">);</span>

        <span class="n">assertionEnded</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

        <span class="n">handleUnfinishedSections</span><span class="p">();</span>

        <span class="c1">// Recreate section for test case (as we will lose the one that was in scope)</span>
        <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseInfo</span> <span class="o">=</span> <span class="n">m_activeTestCase</span><span class="o">-&gt;</span><span class="n">getTestCaseInfo</span><span class="p">();</span>
        <span class="n">SectionInfo</span> <span class="nf">testCaseSection</span><span class="p">(</span><span class="n">testCaseInfo</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">,</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

        <span class="n">Counts</span> <span class="n">assertions</span><span class="p">;</span>
        <span class="n">assertions</span><span class="p">.</span><span class="n">failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">SectionStats</span> <span class="nf">testCaseSectionStats</span><span class="p">(</span><span class="n">testCaseSection</span><span class="p">,</span> <span class="n">assertions</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">sectionEnded</span><span class="p">(</span><span class="n">testCaseSectionStats</span><span class="p">);</span>

        <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="o">=</span> <span class="n">m_activeTestCase</span><span class="o">-&gt;</span><span class="n">getTestCaseInfo</span><span class="p">();</span>

        <span class="n">Totals</span> <span class="n">deltaTotals</span><span class="p">;</span>
        <span class="n">deltaTotals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">deltaTotals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testCaseEnded</span><span class="p">(</span><span class="n">TestCaseStats</span><span class="p">(</span><span class="n">testInfo</span><span class="p">,</span>
                                  <span class="n">deltaTotals</span><span class="p">,</span>
                                  <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(),</span>
                                  <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(),</span>
                                  <span class="nb">false</span><span class="p">));</span>
        <span class="n">m_totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span><span class="o">++</span><span class="p">;</span>
        <span class="n">testGroupEnded</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(),</span> <span class="n">m_totals</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testRunEnded</span><span class="p">(</span><span class="n">TestRunStats</span><span class="p">(</span><span class="n">m_runInfo</span><span class="p">,</span> <span class="n">m_totals</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">lastAssertionPassed</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">return</span> <span class="n">m_lastAssertionPassed</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">assertionPassed</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_lastAssertionPassed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="o">++</span><span class="n">m_totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">passed</span><span class="p">;</span>
        <span class="n">resetAssertionInfo</span><span class="p">();</span>
        <span class="n">m_messageScopes</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">aborting</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span> <span class="o">&gt;=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">abortAfter</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">runCurrentTest</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">redirectedCout</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">redirectedCerr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseInfo</span> <span class="o">=</span> <span class="n">m_activeTestCase</span><span class="o">-&gt;</span><span class="n">getTestCaseInfo</span><span class="p">();</span>
        <span class="n">SectionInfo</span> <span class="nf">testCaseSection</span><span class="p">(</span><span class="n">testCaseInfo</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">,</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">sectionStarting</span><span class="p">(</span><span class="n">testCaseSection</span><span class="p">);</span>
        <span class="n">Counts</span> <span class="n">prevAssertions</span> <span class="o">=</span> <span class="n">m_totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m_shouldReportUnexpected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">m_lastAssertionInfo</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;TEST_CASE&quot;</span><span class="n">_sr</span><span class="p">,</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">,</span> <span class="n">StringRef</span><span class="p">(),</span> <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Normal</span> <span class="p">};</span>

        <span class="n">seedRng</span><span class="p">(</span><span class="o">*</span><span class="n">m_config</span><span class="p">);</span>

        <span class="n">Timer</span> <span class="n">timer</span><span class="p">;</span>
        <span class="n">CATCH_TRY</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">getPreferences</span><span class="p">().</span><span class="n">shouldRedirectStdOut</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)</span>
                <span class="n">RedirectedStreams</span> <span class="nf">redirectedStreams</span><span class="p">(</span><span class="n">redirectedCout</span><span class="p">,</span> <span class="n">redirectedCerr</span><span class="p">);</span>

                <span class="n">timer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
                <span class="n">invokeActiveTestCase</span><span class="p">();</span>
<span class="cp">#else</span>
                <span class="n">OutputRedirect</span> <span class="nf">r</span><span class="p">(</span><span class="n">redirectedCout</span><span class="p">,</span> <span class="n">redirectedCerr</span><span class="p">);</span>
                <span class="n">timer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
                <span class="n">invokeActiveTestCase</span><span class="p">();</span>
<span class="cp">#endif</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">timer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
                <span class="n">invokeActiveTestCase</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">timer</span><span class="p">.</span><span class="n">getElapsedSeconds</span><span class="p">();</span>
        <span class="p">}</span> <span class="n">CATCH_CATCH_ANON</span> <span class="p">(</span><span class="n">TestFailureException</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// This just means the test was aborted due to failure</span>
        <span class="p">}</span> <span class="n">CATCH_CATCH_ALL</span> <span class="p">{</span>
            <span class="c1">// Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions</span>
            <span class="c1">// are reported without translation at the point of origin.</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_shouldReportUnexpected</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">AssertionReaction</span> <span class="n">dummyReaction</span><span class="p">;</span>
                <span class="n">handleUnexpectedInflightException</span><span class="p">(</span> <span class="n">m_lastAssertionInfo</span><span class="p">,</span> <span class="n">translateActiveException</span><span class="p">(),</span> <span class="n">dummyReaction</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">Counts</span> <span class="n">assertions</span> <span class="o">=</span> <span class="n">m_totals</span><span class="p">.</span><span class="n">assertions</span> <span class="o">-</span> <span class="n">prevAssertions</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">missingAssertions</span> <span class="o">=</span> <span class="n">testForMissingAssertions</span><span class="p">(</span><span class="n">assertions</span><span class="p">);</span>

        <span class="n">m_testCaseTracker</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>
        <span class="n">handleUnfinishedSections</span><span class="p">();</span>
        <span class="n">m_messages</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">m_messageScopes</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

        <span class="n">SectionStats</span> <span class="nf">testCaseSectionStats</span><span class="p">(</span><span class="n">testCaseSection</span><span class="p">,</span> <span class="n">assertions</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">missingAssertions</span><span class="p">);</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">sectionEnded</span><span class="p">(</span><span class="n">testCaseSectionStats</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">invokeActiveTestCase</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">FatalConditionHandlerGuard</span> <span class="nf">_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_fatalConditionhandler</span><span class="p">);</span>
        <span class="n">m_activeTestCase</span><span class="o">-&gt;</span><span class="n">invoke</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">handleUnfinishedSections</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// If sections ended prematurely due to an exception we stored their</span>
        <span class="c1">// infos here so we can tear them down outside the unwind process.</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">m_unfinishedSections</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span>
             <span class="n">itEnd</span> <span class="o">=</span> <span class="n">m_unfinishedSections</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span>
             <span class="n">it</span> <span class="o">!=</span> <span class="n">itEnd</span><span class="p">;</span>
             <span class="o">++</span><span class="n">it</span><span class="p">)</span>
            <span class="n">sectionEnded</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
        <span class="n">m_unfinishedSections</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">handleExpr</span><span class="p">(</span>
        <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
        <span class="n">ITransientExpression</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">expr</span><span class="p">,</span>
        <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">assertionStarting</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

        <span class="kt">bool</span> <span class="n">negated</span> <span class="o">=</span> <span class="n">isFalseTest</span><span class="p">(</span> <span class="n">info</span><span class="p">.</span><span class="n">resultDisposition</span> <span class="p">);</span>
        <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">expr</span><span class="p">.</span><span class="n">getResult</span><span class="p">()</span> <span class="o">!=</span> <span class="n">negated</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">result</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_includeSuccessfulResults</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">assertionPassed</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">reportExpr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Ok</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span> <span class="n">negated</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">reportExpr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">ExpressionFailed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span> <span class="n">negated</span> <span class="p">);</span>
            <span class="n">populateReaction</span><span class="p">(</span> <span class="n">reaction</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">reportExpr</span><span class="p">(</span>
            <span class="n">AssertionInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span>
            <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span>
            <span class="n">ITransientExpression</span> <span class="k">const</span> <span class="o">*</span><span class="n">expr</span><span class="p">,</span>
            <span class="kt">bool</span> <span class="n">negated</span> <span class="p">)</span> <span class="p">{</span>

        <span class="n">m_lastAssertionInfo</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
        <span class="n">AssertionResultData</span> <span class="nf">data</span><span class="p">(</span> <span class="n">resultType</span><span class="p">,</span> <span class="n">LazyExpression</span><span class="p">(</span> <span class="n">negated</span> <span class="p">)</span> <span class="p">);</span>

        <span class="n">AssertionResult</span> <span class="n">assertionResult</span><span class="p">{</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span> <span class="p">};</span>
        <span class="n">assertionResult</span><span class="p">.</span><span class="n">m_resultData</span><span class="p">.</span><span class="n">lazyExpression</span><span class="p">.</span><span class="n">m_transientExpression</span> <span class="o">=</span> <span class="n">expr</span><span class="p">;</span>

        <span class="n">assertionEnded</span><span class="p">(</span> <span class="n">assertionResult</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">handleMessage</span><span class="p">(</span>
            <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
            <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span>
            <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">,</span>
            <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">assertionStarting</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

        <span class="n">m_lastAssertionInfo</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>

        <span class="n">AssertionResultData</span> <span class="nf">data</span><span class="p">(</span> <span class="n">resultType</span><span class="p">,</span> <span class="n">LazyExpression</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span> <span class="p">);</span>
        <span class="n">data</span><span class="p">.</span><span class="n">message</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
        <span class="n">AssertionResult</span> <span class="n">assertionResult</span><span class="p">{</span> <span class="n">m_lastAssertionInfo</span><span class="p">,</span> <span class="n">data</span> <span class="p">};</span>
        <span class="n">assertionEnded</span><span class="p">(</span> <span class="n">assertionResult</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">assertionResult</span><span class="p">.</span><span class="n">isOk</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">populateReaction</span><span class="p">(</span> <span class="n">reaction</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">handleUnexpectedExceptionNotThrown</span><span class="p">(</span>
            <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
            <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">handleNonExpr</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">Catch</span><span class="o">::</span><span class="n">ResultWas</span><span class="o">::</span><span class="n">DidntThrowException</span><span class="p">,</span> <span class="n">reaction</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">handleUnexpectedInflightException</span><span class="p">(</span>
            <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">,</span>
            <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_lastAssertionInfo</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>

        <span class="n">AssertionResultData</span> <span class="nf">data</span><span class="p">(</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">ThrewException</span><span class="p">,</span> <span class="n">LazyExpression</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span> <span class="p">);</span>
        <span class="n">data</span><span class="p">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="p">;</span>
        <span class="n">AssertionResult</span> <span class="n">assertionResult</span><span class="p">{</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span> <span class="p">};</span>
        <span class="n">assertionEnded</span><span class="p">(</span> <span class="n">assertionResult</span> <span class="p">);</span>
        <span class="n">populateReaction</span><span class="p">(</span> <span class="n">reaction</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">populateReaction</span><span class="p">(</span> <span class="n">AssertionReaction</span><span class="o">&amp;</span> <span class="n">reaction</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">reaction</span><span class="p">.</span><span class="n">shouldDebugBreak</span> <span class="o">=</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">shouldDebugBreak</span><span class="p">();</span>
        <span class="n">reaction</span><span class="p">.</span><span class="n">shouldThrow</span> <span class="o">=</span> <span class="n">aborting</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">m_lastAssertionInfo</span><span class="p">.</span><span class="n">resultDisposition</span> <span class="o">&amp;</span> <span class="n">ResultDisposition</span><span class="o">::</span><span class="n">Normal</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">handleIncomplete</span><span class="p">(</span>
            <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_lastAssertionInfo</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>

        <span class="n">AssertionResultData</span> <span class="nf">data</span><span class="p">(</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">ThrewException</span><span class="p">,</span> <span class="n">LazyExpression</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span> <span class="p">);</span>
        <span class="n">data</span><span class="p">.</span><span class="n">message</span> <span class="o">=</span> <span class="s">&quot;Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE&quot;</span><span class="p">;</span>
        <span class="n">AssertionResult</span> <span class="n">assertionResult</span><span class="p">{</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span> <span class="p">};</span>
        <span class="n">assertionEnded</span><span class="p">(</span> <span class="n">assertionResult</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">RunContext</span><span class="o">::</span><span class="n">handleNonExpr</span><span class="p">(</span>
            <span class="n">AssertionInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span>
            <span class="n">ResultWas</span><span class="o">::</span><span class="n">OfType</span> <span class="n">resultType</span><span class="p">,</span>
            <span class="n">AssertionReaction</span> <span class="o">&amp;</span><span class="n">reaction</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_lastAssertionInfo</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>

        <span class="n">AssertionResultData</span> <span class="nf">data</span><span class="p">(</span> <span class="n">resultType</span><span class="p">,</span> <span class="n">LazyExpression</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span> <span class="p">);</span>
        <span class="n">AssertionResult</span> <span class="n">assertionResult</span><span class="p">{</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span> <span class="p">};</span>
        <span class="n">assertionEnded</span><span class="p">(</span> <span class="n">assertionResult</span> <span class="p">);</span>

        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">assertionResult</span><span class="p">.</span><span class="n">isOk</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">populateReaction</span><span class="p">(</span> <span class="n">reaction</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">IResultCapture</span><span class="o">&amp;</span> <span class="n">getResultCapture</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">capture</span> <span class="o">=</span> <span class="n">getCurrentContext</span><span class="p">().</span><span class="n">getResultCapture</span><span class="p">())</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">capture</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="nf">CATCH_INTERNAL_ERROR</span><span class="p">(</span><span class="s">&quot;No result capture instance&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">seedRng</span><span class="p">(</span><span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">rngSeed</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">srand</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">rngSeed</span><span class="p">());</span>
            <span class="n">rng</span><span class="p">().</span><span class="n">seed</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">rngSeed</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rngSeed</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getCurrentContext</span><span class="p">().</span><span class="n">getConfig</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">rngSeed</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="c1">// end catch_run_context.cpp</span>
<span class="c1">// start catch_section.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">Section</span><span class="o">::</span><span class="n">Section</span><span class="p">(</span> <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_info</span><span class="p">(</span> <span class="n">info</span> <span class="p">),</span>
        <span class="n">m_sectionIncluded</span><span class="p">(</span> <span class="n">getResultCapture</span><span class="p">().</span><span class="n">sectionStarted</span><span class="p">(</span> <span class="n">m_info</span><span class="p">,</span> <span class="n">m_assertions</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_timer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">Section</span><span class="o">::~</span><span class="n">Section</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_sectionIncluded</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">SectionEndInfo</span> <span class="n">endInfo</span><span class="p">{</span> <span class="n">m_info</span><span class="p">,</span> <span class="n">m_assertions</span><span class="p">,</span> <span class="n">m_timer</span><span class="p">.</span><span class="n">getElapsedSeconds</span><span class="p">()</span> <span class="p">};</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">uncaught_exceptions</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">getResultCapture</span><span class="p">().</span><span class="n">sectionEndedEarly</span><span class="p">(</span> <span class="n">endInfo</span> <span class="p">);</span>
            <span class="k">else</span>
                <span class="nf">getResultCapture</span><span class="p">().</span><span class="n">sectionEnded</span><span class="p">(</span> <span class="n">endInfo</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// This indicates whether the section should be executed or not</span>
    <span class="n">Section</span><span class="o">::</span><span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_sectionIncluded</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_section.cpp</span>
<span class="c1">// start catch_section_info.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">SectionInfo</span><span class="o">::</span><span class="n">SectionInfo</span>
        <span class="p">(</span>   <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_lineInfo</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">name</span><span class="p">(</span> <span class="n">_name</span> <span class="p">),</span>
        <span class="n">lineInfo</span><span class="p">(</span> <span class="n">_lineInfo</span> <span class="p">)</span>
    <span class="p">{}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_section_info.cpp</span>
<span class="c1">// start catch_session.cpp</span>

<span class="c1">// start catch_session.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">class</span> <span class="nc">Session</span> <span class="o">:</span> <span class="n">NonCopyable</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>

        <span class="n">Session</span><span class="p">();</span>
        <span class="o">~</span><span class="n">Session</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">showHelp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">libIdentify</span><span class="p">();</span>

        <span class="kt">int</span> <span class="nf">applyCommandLine</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">argv</span> <span class="p">);</span>
    <span class="cp">#if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(_WIN32) &amp;&amp; defined(UNICODE)</span>
        <span class="kt">int</span> <span class="nf">applyCommandLine</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">argv</span> <span class="p">);</span>
    <span class="cp">#endif</span>

        <span class="kt">void</span> <span class="nf">useConfigData</span><span class="p">(</span> <span class="n">ConfigData</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">configData</span> <span class="p">);</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CharT</span><span class="o">&gt;</span>
        <span class="kt">int</span> <span class="n">run</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">CharT</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_startupExceptions</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">returnCode</span> <span class="o">=</span> <span class="n">applyCommandLine</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">returnCode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">returnCode</span> <span class="o">=</span> <span class="n">run</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">returnCode</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">run</span><span class="p">();</span>

        <span class="n">clara</span><span class="o">::</span><span class="n">Parser</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">cli</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">cli</span><span class="p">(</span> <span class="n">clara</span><span class="o">::</span><span class="n">Parser</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">newParser</span> <span class="p">);</span>
        <span class="n">ConfigData</span><span class="o">&amp;</span> <span class="nf">configData</span><span class="p">();</span>
        <span class="n">Config</span><span class="o">&amp;</span> <span class="nf">config</span><span class="p">();</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">runInternal</span><span class="p">();</span>

        <span class="n">clara</span><span class="o">::</span><span class="n">Parser</span> <span class="n">m_cli</span><span class="p">;</span>
        <span class="n">ConfigData</span> <span class="n">m_configData</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span> <span class="n">m_config</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">m_startupExceptions</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="c1">// end catch_session.h</span>
<span class="c1">// start catch_version.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;iosfwd&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="c1">// Versioning information</span>
    <span class="k">struct</span> <span class="nc">Version</span> <span class="p">{</span>
        <span class="n">Version</span><span class="p">(</span> <span class="n">Version</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">Version</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">Version</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">Version</span><span class="p">(</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_majorVersion</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_minorVersion</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_patchNumber</span><span class="p">,</span>
                    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">_branchName</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_buildNumber</span> <span class="p">);</span>

        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">majorVersion</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">minorVersion</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">patchNumber</span><span class="p">;</span>

        <span class="c1">// buildNumber is only used if branchName is not null</span>
        <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">branchName</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">buildNumber</span><span class="p">;</span>

        <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">Version</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">version</span> <span class="p">);</span>
    <span class="p">};</span>

    <span class="n">Version</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">libraryVersion</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// end catch_version.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">MaxExitCode</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>

        <span class="n">IStreamingReporterPtr</span> <span class="nf">createReporter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">reporterName</span><span class="p">,</span> <span class="n">IConfigPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">reporter</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">getRegistryHub</span><span class="p">().</span><span class="n">getReporterRegistry</span><span class="p">().</span><span class="n">create</span><span class="p">(</span><span class="n">reporterName</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>
            <span class="n">CATCH_ENFORCE</span><span class="p">(</span><span class="n">reporter</span><span class="p">,</span> <span class="s">&quot;No reporter registered with name: &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">reporterName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">reporter</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">IStreamingReporterPtr</span> <span class="nf">makeReporter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Catch</span><span class="o">::</span><span class="n">getRegistryHub</span><span class="p">().</span><span class="n">getReporterRegistry</span><span class="p">().</span><span class="n">getListeners</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">createReporter</span><span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">getReporterName</span><span class="p">(),</span> <span class="n">config</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// On older platforms, returning std::unique_ptr&lt;ListeningReporter&gt;</span>
            <span class="c1">// when the return type is std::unique_ptr&lt;IStreamingReporter&gt;</span>
            <span class="c1">// doesn&#39;t compile without a std::move call. However, this causes</span>
            <span class="c1">// a warning on newer platforms. Thus, we have to work around</span>
            <span class="c1">// it a bit and downcast the pointer manually.</span>
            <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IStreamingReporter</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">ListeningReporter</span><span class="p">);</span>
            <span class="k">auto</span><span class="o">&amp;</span> <span class="n">multi</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ListeningReporter</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">);</span>
            <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">listeners</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">getRegistryHub</span><span class="p">().</span><span class="n">getReporterRegistry</span><span class="p">().</span><span class="n">getListeners</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">listeners</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">multi</span><span class="p">.</span><span class="n">addListener</span><span class="p">(</span><span class="n">listener</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">Catch</span><span class="o">::</span><span class="n">ReporterConfig</span><span class="p">(</span><span class="n">config</span><span class="p">)));</span>
            <span class="p">}</span>
            <span class="n">multi</span><span class="p">.</span><span class="n">addReporter</span><span class="p">(</span><span class="n">createReporter</span><span class="p">(</span><span class="n">config</span><span class="o">-&gt;</span><span class="n">getReporterName</span><span class="p">(),</span> <span class="n">config</span><span class="p">));</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">class</span> <span class="nc">TestGroup</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="k">explicit</span> <span class="n">TestGroup</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">m_config</span><span class="p">{</span><span class="n">config</span><span class="p">}</span>
            <span class="p">,</span> <span class="n">m_context</span><span class="p">{</span><span class="n">config</span><span class="p">,</span> <span class="n">makeReporter</span><span class="p">(</span><span class="n">config</span><span class="p">)}</span>
            <span class="p">{</span>
                <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">allTestCases</span> <span class="o">=</span> <span class="n">getAllTestCasesSorted</span><span class="p">(</span><span class="o">*</span><span class="n">m_config</span><span class="p">);</span>
                <span class="n">m_matches</span> <span class="o">=</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">testSpec</span><span class="p">().</span><span class="n">matchesByFilter</span><span class="p">(</span><span class="n">allTestCases</span><span class="p">,</span> <span class="o">*</span><span class="n">m_config</span><span class="p">);</span>
                <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">invalidArgs</span> <span class="o">=</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">testSpec</span><span class="p">().</span><span class="n">getInvalidArgs</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">m_matches</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">invalidArgs</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">test</span> <span class="p">:</span> <span class="n">allTestCases</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test</span><span class="p">.</span><span class="n">isHidden</span><span class="p">())</span>
                            <span class="n">m_tests</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">match</span> <span class="p">:</span> <span class="n">m_matches</span><span class="p">)</span>
                        <span class="n">m_tests</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">match</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">match</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">Totals</span> <span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">invalidArgs</span> <span class="o">=</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">testSpec</span><span class="p">().</span><span class="n">getInvalidArgs</span><span class="p">();</span>
                <span class="n">Totals</span> <span class="n">totals</span><span class="p">;</span>
                <span class="n">m_context</span><span class="p">.</span><span class="n">testGroupStarting</span><span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">testCase</span> <span class="p">:</span> <span class="n">m_tests</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_context</span><span class="p">.</span><span class="n">aborting</span><span class="p">())</span>
                        <span class="n">totals</span> <span class="o">+=</span> <span class="n">m_context</span><span class="p">.</span><span class="n">runTest</span><span class="p">(</span><span class="o">*</span><span class="n">testCase</span><span class="p">);</span>
                    <span class="k">else</span>
                        <span class="n">m_context</span><span class="p">.</span><span class="n">reporter</span><span class="p">().</span><span class="n">skipTest</span><span class="p">(</span><span class="o">*</span><span class="n">testCase</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">match</span> <span class="p">:</span> <span class="n">m_matches</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">.</span><span class="n">tests</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                        <span class="n">m_context</span><span class="p">.</span><span class="n">reporter</span><span class="p">().</span><span class="n">noMatchingTestCases</span><span class="p">(</span><span class="n">match</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
                        <span class="n">totals</span><span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">invalidArgs</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">invalidArg</span><span class="p">:</span> <span class="n">invalidArgs</span><span class="p">)</span>
                         <span class="n">m_context</span><span class="p">.</span><span class="n">reporter</span><span class="p">().</span><span class="n">reportInvalidArguments</span><span class="p">(</span><span class="n">invalidArg</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="n">m_context</span><span class="p">.</span><span class="n">testGroupEnded</span><span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">(),</span> <span class="n">totals</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">totals</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="k">private</span><span class="o">:</span>
            <span class="k">using</span> <span class="n">Tests</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TestCase</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">;</span>

            <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span> <span class="n">m_config</span><span class="p">;</span>
            <span class="n">RunContext</span> <span class="n">m_context</span><span class="p">;</span>
            <span class="n">Tests</span> <span class="n">m_tests</span><span class="p">;</span>
            <span class="n">TestSpec</span><span class="o">::</span><span class="n">Matches</span> <span class="n">m_matches</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="kt">void</span> <span class="nf">applyFilenamesAsTags</span><span class="p">(</span><span class="n">Catch</span><span class="o">::</span><span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span><span class="o">&amp;</span> <span class="n">tests</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;&amp;&gt;</span><span class="p">(</span><span class="n">getAllTestCasesSorted</span><span class="p">(</span><span class="n">config</span><span class="p">));</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">testCase</span> <span class="p">:</span> <span class="n">tests</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">tags</span> <span class="o">=</span> <span class="n">testCase</span><span class="p">.</span><span class="n">tags</span><span class="p">;</span>

                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">testCase</span><span class="p">.</span><span class="n">lineInfo</span><span class="p">.</span><span class="n">file</span><span class="p">;</span>
                <span class="k">auto</span> <span class="n">lastSlash</span> <span class="o">=</span> <span class="n">filename</span><span class="p">.</span><span class="n">find_last_of</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">/&quot;</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">lastSlash</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">filename</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lastSlash</span><span class="p">);</span>
                    <span class="n">filename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;#&#39;</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">auto</span> <span class="n">lastDot</span> <span class="o">=</span> <span class="n">filename</span><span class="p">.</span><span class="n">find_last_of</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">lastDot</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">filename</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">lastDot</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="n">tags</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">filename</span><span class="p">));</span>
                <span class="n">setTags</span><span class="p">(</span><span class="n">testCase</span><span class="p">,</span> <span class="n">tags</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="c1">// anon namespace</span>

    <span class="n">Session</span><span class="o">::</span><span class="n">Session</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">bool</span> <span class="n">alreadyInstantiated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">alreadyInstantiated</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">CATCH_TRY</span> <span class="p">{</span> <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span> <span class="s">&quot;Only one instance of Catch::Session can ever be used&quot;</span> <span class="p">);</span> <span class="p">}</span>
            <span class="n">CATCH_CATCH_ALL</span> <span class="p">{</span> <span class="n">getMutableRegistryHub</span><span class="p">().</span><span class="n">registerStartupException</span><span class="p">();</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// There cannot be exceptions at startup in no-exception mode.</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
        <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">exceptions</span> <span class="o">=</span> <span class="n">getRegistryHub</span><span class="p">().</span><span class="n">getStartupExceptionRegistry</span><span class="p">().</span><span class="n">getExceptions</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">exceptions</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">config</span><span class="p">();</span>
            <span class="n">getCurrentMutableContext</span><span class="p">().</span><span class="n">setConfig</span><span class="p">(</span><span class="n">m_config</span><span class="p">);</span>

            <span class="n">m_startupExceptions</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Red</span> <span class="p">);</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cerr</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Errors occurred during startup!&quot;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
            <span class="c1">// iterate over all exceptions and notify user</span>
            <span class="k">for</span> <span class="p">(</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">ex_ptr</span> <span class="p">:</span> <span class="n">exceptions</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">try</span> <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">ex_ptr</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ex</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">Catch</span><span class="o">::</span><span class="n">cerr</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="p">).</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
<span class="cp">#endif</span>

        <span class="n">alreadyInstantiated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">m_cli</span> <span class="o">=</span> <span class="n">makeCommandLineParser</span><span class="p">(</span> <span class="n">m_configData</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Session</span><span class="o">::~</span><span class="n">Session</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">cleanUp</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Session</span><span class="o">::</span><span class="n">showHelp</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Catch v&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">libraryVersion</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">m_cli</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;For more detailed usage please see the project docs</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Session</span><span class="o">::</span><span class="n">libIdentify</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">left</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;description: &quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;A Catch2 test executable</span><span class="se">\n</span><span class="s">&quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">left</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;category: &quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;testframework</span><span class="se">\n</span><span class="s">&quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">left</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;framework: &quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Catch Test</span><span class="se">\n</span><span class="s">&quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">left</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;version: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">libraryVersion</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">Session</span><span class="o">::</span><span class="n">applyCommandLine</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">argv</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_startupExceptions</span> <span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">m_cli</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span> <span class="n">clara</span><span class="o">::</span><span class="n">Args</span><span class="p">(</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span> <span class="p">)</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">result</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">config</span><span class="p">();</span>
            <span class="n">getCurrentMutableContext</span><span class="p">().</span><span class="n">setConfig</span><span class="p">(</span><span class="n">m_config</span><span class="p">);</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cerr</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Red</span> <span class="p">)</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Error(s) in input:</span><span class="se">\n</span><span class="s">&quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">errorMessage</span><span class="p">()</span> <span class="p">).</span><span class="n">indent</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cerr</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Run with -? for usage</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">MaxExitCode</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">m_configData</span><span class="p">.</span><span class="n">showHelp</span> <span class="p">)</span>
            <span class="n">showHelp</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_configData</span><span class="p">.</span><span class="n">libIdentify</span> <span class="p">)</span>
            <span class="n">libIdentify</span><span class="p">();</span>
        <span class="n">m_config</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

<span class="cp">#if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(_WIN32) &amp;&amp; defined(UNICODE)</span>
    <span class="kt">int</span> <span class="n">Session</span><span class="o">::</span><span class="n">applyCommandLine</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">argv</span> <span class="p">)</span> <span class="p">{</span>

        <span class="kt">char</span> <span class="o">**</span><span class="n">utf8Argv</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span> <span class="o">*</span><span class="p">[</span> <span class="n">argc</span> <span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="n">WideCharToMultiByte</span><span class="p">(</span> <span class="n">CP_UTF8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">-1</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span> <span class="p">);</span>

            <span class="n">utf8Argv</span><span class="p">[</span> <span class="n">i</span> <span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span> <span class="n">bufSize</span> <span class="p">];</span>

            <span class="n">WideCharToMultiByte</span><span class="p">(</span> <span class="n">CP_UTF8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">-1</span><span class="p">,</span> <span class="n">utf8Argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bufSize</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">returnCode</span> <span class="o">=</span> <span class="n">applyCommandLine</span><span class="p">(</span> <span class="n">argc</span><span class="p">,</span> <span class="n">utf8Argv</span> <span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
            <span class="k">delete</span> <span class="p">[]</span> <span class="n">utf8Argv</span><span class="p">[</span> <span class="n">i</span> <span class="p">];</span>

        <span class="k">delete</span> <span class="p">[]</span> <span class="n">utf8Argv</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">returnCode</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif</span>

    <span class="kt">void</span> <span class="n">Session</span><span class="o">::</span><span class="n">useConfigData</span><span class="p">(</span> <span class="n">ConfigData</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">configData</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_configData</span> <span class="o">=</span> <span class="n">configData</span><span class="p">;</span>
        <span class="n">m_config</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">Session</span><span class="o">::</span><span class="n">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">m_configData</span><span class="p">.</span><span class="n">waitForKeypress</span> <span class="o">&amp;</span> <span class="n">WaitForKeypress</span><span class="o">::</span><span class="n">BeforeStart</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;...waiting for enter/ return before starting&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getchar</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">exitCode</span> <span class="o">=</span> <span class="n">runInternal</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">m_configData</span><span class="p">.</span><span class="n">waitForKeypress</span> <span class="o">&amp;</span> <span class="n">WaitForKeypress</span><span class="o">::</span><span class="n">BeforeExit</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;...waiting for enter/ return before exiting, with code: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">exitCode</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getchar</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">exitCode</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">clara</span><span class="o">::</span><span class="n">Parser</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Session</span><span class="o">::</span><span class="n">cli</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_cli</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Session</span><span class="o">::</span><span class="n">cli</span><span class="p">(</span> <span class="n">clara</span><span class="o">::</span><span class="n">Parser</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">newParser</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_cli</span> <span class="o">=</span> <span class="n">newParser</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ConfigData</span><span class="o">&amp;</span> <span class="n">Session</span><span class="o">::</span><span class="n">configData</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_configData</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Config</span><span class="o">&amp;</span> <span class="n">Session</span><span class="o">::</span><span class="n">config</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">m_config</span> <span class="p">)</span>
            <span class="n">m_config</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">m_configData</span> <span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_config</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">Session</span><span class="o">::</span><span class="n">runInternal</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_startupExceptions</span> <span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">m_configData</span><span class="p">.</span><span class="n">showHelp</span> <span class="o">||</span> <span class="n">m_configData</span><span class="p">.</span><span class="n">libIdentify</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">CATCH_TRY</span> <span class="p">{</span>
            <span class="n">config</span><span class="p">();</span> <span class="c1">// Force config to be constructed</span>

            <span class="n">seedRng</span><span class="p">(</span> <span class="o">*</span><span class="n">m_config</span> <span class="p">);</span>

            <span class="k">if</span><span class="p">(</span> <span class="n">m_configData</span><span class="p">.</span><span class="n">filenamesAsTags</span> <span class="p">)</span>
                <span class="n">applyFilenamesAsTags</span><span class="p">(</span> <span class="o">*</span><span class="n">m_config</span> <span class="p">);</span>

            <span class="c1">// Handle list request</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">Option</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">listed</span> <span class="o">=</span> <span class="n">list</span><span class="p">(</span> <span class="n">m_config</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="o">*</span><span class="n">listed</span> <span class="p">);</span>

            <span class="n">TestGroup</span> <span class="n">tests</span> <span class="p">{</span> <span class="n">m_config</span> <span class="p">};</span>
            <span class="k">auto</span> <span class="k">const</span> <span class="n">totals</span> <span class="o">=</span> <span class="n">tests</span><span class="p">.</span><span class="n">execute</span><span class="p">();</span>

            <span class="k">if</span><span class="p">(</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">warnAboutNoTests</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">totals</span><span class="p">.</span><span class="n">error</span> <span class="o">==</span> <span class="mi">-1</span> <span class="p">)</span>
                <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

            <span class="c1">// Note that on unices only the lower 8 bits are usually used, clamping</span>
            <span class="c1">// the return value to 255 prevents false negative when some multiple</span>
            <span class="c1">// of 256 tests has failed</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">)</span> <span class="p">(</span><span class="n">MaxExitCode</span><span class="p">,</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">)</span> <span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">error</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="p">)));</span>
        <span class="p">}</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
        <span class="k">catch</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">Catch</span><span class="o">::</span><span class="n">cerr</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">MaxExitCode</span><span class="p">;</span>
        <span class="p">}</span>
<span class="cp">#endif</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_session.cpp</span>
<span class="c1">// start catch_singletons.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">getSingletons</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ISingleton</span><span class="o">*&gt;*&amp;</span> <span class="p">{</span>
            <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ISingleton</span><span class="o">*&gt;*</span> <span class="n">g_singletons</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">g_singletons</span> <span class="p">)</span>
                <span class="n">g_singletons</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ISingleton</span><span class="o">*&gt;</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">g_singletons</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ISingleton</span><span class="o">::~</span><span class="n">ISingleton</span><span class="p">()</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">addSingleton</span><span class="p">(</span><span class="n">ISingleton</span><span class="o">*</span> <span class="n">singleton</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">getSingletons</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span> <span class="n">singleton</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">cleanupSingletons</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">singletons</span> <span class="o">=</span> <span class="n">getSingletons</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="nl">singleton</span> <span class="p">:</span> <span class="o">*</span><span class="n">singletons</span> <span class="p">)</span>
            <span class="k">delete</span> <span class="n">singleton</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">singletons</span><span class="p">;</span>
        <span class="n">singletons</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_singletons.cpp</span>
<span class="c1">// start catch_startup_exception_registry.cpp</span>

<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">StartupExceptionRegistry</span><span class="o">::</span><span class="n">add</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">exception</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">CATCH_TRY</span> <span class="p">{</span>
            <span class="n">m_exceptions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">exception</span><span class="p">);</span>
        <span class="p">}</span> <span class="n">CATCH_CATCH_ALL</span> <span class="p">{</span>
            <span class="c1">// If we run out of memory during start-up there&#39;s really not a lot more we can do about it</span>
            <span class="n">std</span><span class="o">::</span><span class="n">terminate</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">StartupExceptionRegistry</span><span class="o">::</span><span class="n">getExceptions</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_exceptions</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="cp">#endif</span>
<span class="c1">// end catch_startup_exception_registry.cpp</span>
<span class="c1">// start catch_stream.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">Catch</span><span class="o">::</span><span class="n">IStream</span><span class="o">::~</span><span class="n">IStream</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span> <span class="k">namespace</span> <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">WriterF</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bufferSize</span><span class="o">=</span><span class="mi">256</span><span class="o">&gt;</span>
        <span class="k">class</span> <span class="nc">StreamBufImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">streambuf</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">bufferSize</span><span class="p">];</span>
            <span class="n">WriterF</span> <span class="n">m_writer</span><span class="p">;</span>

        <span class="k">public</span><span class="o">:</span>
            <span class="n">StreamBufImpl</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">setp</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">);</span>
            <span class="p">}</span>

            <span class="o">~</span><span class="n">StreamBufImpl</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
                <span class="n">StreamBufImpl</span><span class="o">::</span><span class="n">sync</span><span class="p">();</span>
            <span class="p">}</span>

        <span class="k">private</span><span class="o">:</span>
            <span class="kt">int</span> <span class="n">overflow</span><span class="p">(</span> <span class="kt">int</span> <span class="n">c</span> <span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">sync</span><span class="p">();</span>

                <span class="k">if</span><span class="p">(</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">EOF</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">pbase</span><span class="p">()</span> <span class="o">==</span> <span class="n">epptr</span><span class="p">()</span> <span class="p">)</span>
                        <span class="n">m_writer</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">c</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
                    <span class="k">else</span>
                        <span class="nf">sputc</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">c</span> <span class="p">)</span> <span class="p">);</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">int</span> <span class="n">sync</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">pbase</span><span class="p">()</span> <span class="o">!=</span> <span class="n">pptr</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">m_writer</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span> <span class="n">pbase</span><span class="p">(),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">pptr</span><span class="p">()</span> <span class="o">-</span> <span class="n">pbase</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
                    <span class="n">setp</span><span class="p">(</span> <span class="n">pbase</span><span class="p">(),</span> <span class="n">epptr</span><span class="p">()</span> <span class="p">);</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="c1">///////////////////////////////////////////////////////////////////////////</span>

        <span class="k">struct</span> <span class="nc">OutputDebugWriter</span> <span class="p">{</span>

            <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="n">str</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">writeToDebugConsole</span><span class="p">(</span> <span class="n">str</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="c1">///////////////////////////////////////////////////////////////////////////</span>

        <span class="k">class</span> <span class="nc">FileStream</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IStream</span> <span class="p">{</span>
            <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">m_ofs</span><span class="p">;</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">FileStream</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">filename</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">m_ofs</span><span class="p">.</span><span class="n">open</span><span class="p">(</span> <span class="n">filename</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="p">);</span>
                <span class="n">CATCH_ENFORCE</span><span class="p">(</span> <span class="o">!</span><span class="n">m_ofs</span><span class="p">.</span><span class="n">fail</span><span class="p">(),</span> <span class="s">&quot;Unable to open file: &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="o">~</span><span class="n">FileStream</span><span class="p">()</span> <span class="k">override</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="k">public</span><span class="o">:</span> <span class="c1">// IStream</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">m_ofs</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="c1">///////////////////////////////////////////////////////////////////////////</span>

        <span class="k">class</span> <span class="nc">CoutStream</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IStream</span> <span class="p">{</span>
            <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="n">m_os</span><span class="p">;</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="c1">// Store the streambuf from cout up-front because</span>
            <span class="c1">// cout may get redirected when running tests</span>
            <span class="n">CoutStream</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_os</span><span class="p">(</span> <span class="n">Catch</span><span class="o">::</span><span class="n">cout</span><span class="p">().</span><span class="n">rdbuf</span><span class="p">()</span> <span class="p">)</span> <span class="p">{}</span>
            <span class="o">~</span><span class="n">CoutStream</span><span class="p">()</span> <span class="k">override</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="k">public</span><span class="o">:</span> <span class="c1">// IStream</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_os</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">};</span>

        <span class="c1">///////////////////////////////////////////////////////////////////////////</span>

        <span class="k">class</span> <span class="nc">DebugOutStream</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IStream</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">StreamBufImpl</span><span class="o">&lt;</span><span class="n">OutputDebugWriter</span><span class="o">&gt;&gt;</span> <span class="n">m_streamBuf</span><span class="p">;</span>
            <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="n">m_os</span><span class="p">;</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="n">DebugOutStream</span><span class="p">()</span>
            <span class="o">:</span>   <span class="n">m_streamBuf</span><span class="p">(</span> <span class="k">new</span> <span class="n">StreamBufImpl</span><span class="o">&lt;</span><span class="n">OutputDebugWriter</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">),</span>
                <span class="n">m_os</span><span class="p">(</span> <span class="n">m_streamBuf</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">)</span>
            <span class="p">{}</span>

            <span class="o">~</span><span class="n">DebugOutStream</span><span class="p">()</span> <span class="k">override</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="k">public</span><span class="o">:</span> <span class="c1">// IStream</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_os</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">};</span>

    <span class="p">}}</span> <span class="c1">// namespace anon::detail</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////</span>

    <span class="k">auto</span> <span class="n">makeStream</span><span class="p">(</span> <span class="n">StringRef</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">filename</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IStream</span> <span class="k">const</span><span class="o">*</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">filename</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">Detail</span><span class="o">::</span><span class="n">CoutStream</span><span class="p">();</span>
        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">filename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;%&#39;</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">filename</span> <span class="o">==</span> <span class="s">&quot;%debug&quot;</span> <span class="p">)</span>
                <span class="k">return</span> <span class="k">new</span> <span class="n">Detail</span><span class="o">::</span><span class="n">DebugOutStream</span><span class="p">();</span>
            <span class="k">else</span>
                <span class="n">CATCH_ERROR</span><span class="p">(</span> <span class="s">&quot;Unrecognised stream: &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">Detail</span><span class="o">::</span><span class="n">FileStream</span><span class="p">(</span> <span class="n">filename</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// This class encapsulates the idea of a pool of ostringstreams that can be reused.</span>
    <span class="k">struct</span> <span class="nc">StringStreams</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="o">&gt;&gt;</span> <span class="n">m_streams</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">m_unused</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">m_referenceStream</span><span class="p">;</span> <span class="c1">// Used for copy state/ flags from</span>

        <span class="k">auto</span> <span class="nf">add</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_unused</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">m_streams</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="o">&gt;</span><span class="p">(</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="p">)</span> <span class="p">);</span>
                <span class="k">return</span> <span class="n">m_streams</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="mi">-1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">index</span> <span class="o">=</span> <span class="n">m_unused</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
                <span class="n">m_unused</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
                <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">release</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_streams</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">copyfmt</span><span class="p">(</span> <span class="n">m_referenceStream</span> <span class="p">);</span> <span class="c1">// Restore initial flags and other state</span>
            <span class="n">m_unused</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">ReusableStringStream</span><span class="o">::</span><span class="n">ReusableStringStream</span><span class="p">()</span>
    <span class="o">:</span>   <span class="n">m_index</span><span class="p">(</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">StringStreams</span><span class="o">&gt;::</span><span class="n">getMutable</span><span class="p">().</span><span class="n">add</span><span class="p">()</span> <span class="p">),</span>
        <span class="n">m_oss</span><span class="p">(</span> <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">StringStreams</span><span class="o">&gt;::</span><span class="n">getMutable</span><span class="p">().</span><span class="n">m_streams</span><span class="p">[</span><span class="n">m_index</span><span class="p">].</span><span class="n">get</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">ReusableStringStream</span><span class="o">::~</span><span class="n">ReusableStringStream</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">m_oss</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="n">m_oss</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">Singleton</span><span class="o">&lt;</span><span class="n">StringStreams</span><span class="o">&gt;::</span><span class="n">getMutable</span><span class="p">().</span><span class="n">release</span><span class="p">(</span> <span class="n">m_index</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">ReusableStringStream</span><span class="o">::</span><span class="n">str</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="o">*&gt;</span><span class="p">(</span> <span class="n">m_oss</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////</span>

<span class="cp">#ifndef CATCH_CONFIG_NOSTDOUT </span><span class="c1">// If you #define this you must implement these functions</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">cout</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">cerr</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">clog</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">clog</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="c1">// end catch_stream.cpp</span>
<span class="c1">// start catch_string_manip.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="nf">toLowerCh</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">tolower</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">startsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">prefix</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">prefix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">equal</span><span class="p">(</span><span class="n">prefix</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">prefix</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">startsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">prefix</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">prefix</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">endsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">suffix</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">suffix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">equal</span><span class="p">(</span><span class="n">suffix</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">suffix</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">rbegin</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">endsWith</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">suffix</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="mi">-1</span><span class="p">]</span> <span class="o">==</span> <span class="n">suffix</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">infix</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">infix</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">toLowerInPlace</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">toLowerCh</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">lc</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">toLowerInPlace</span><span class="p">(</span> <span class="n">lc</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">lc</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">trim</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">whitespaceChars</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n\r\t</span><span class="s"> &quot;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">start</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">find_first_not_of</span><span class="p">(</span> <span class="n">whitespaceChars</span> <span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">end</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">find_last_not_of</span><span class="p">(</span> <span class="n">whitespaceChars</span> <span class="p">);</span>

        <span class="k">return</span> <span class="n">start</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="o">?</span> <span class="n">str</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">start</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">end</span><span class="o">-</span><span class="n">start</span> <span class="p">)</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">StringRef</span> <span class="n">trim</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">is_ws</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="kt">size_t</span> <span class="n">real_begin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">real_begin</span> <span class="o">&lt;</span> <span class="n">ref</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">is_ws</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="n">real_begin</span><span class="p">]))</span> <span class="p">{</span> <span class="o">++</span><span class="n">real_begin</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">size_t</span> <span class="n">real_end</span> <span class="o">=</span> <span class="n">ref</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">real_end</span> <span class="o">&gt;</span> <span class="n">real_begin</span> <span class="o">&amp;&amp;</span> <span class="n">is_ws</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="n">real_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="p">{</span> <span class="o">--</span><span class="n">real_end</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">return</span> <span class="n">ref</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">real_begin</span><span class="p">,</span> <span class="n">real_end</span> <span class="o">-</span> <span class="n">real_begin</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">replaceInPlace</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">replaceThis</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">withThis</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">replaced</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">replaceThis</span> <span class="p">);</span>
        <span class="k">while</span><span class="p">(</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">replaced</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="p">)</span> <span class="o">+</span> <span class="n">withThis</span> <span class="o">+</span> <span class="n">str</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">i</span><span class="o">+</span><span class="n">replaceThis</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="n">withThis</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">replaceThis</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">withThis</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
            <span class="k">else</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">replaced</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">StringRef</span><span class="o">&gt;</span> <span class="n">splitStringRef</span><span class="p">(</span> <span class="n">StringRef</span> <span class="n">str</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delimiter</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">StringRef</span><span class="o">&gt;</span> <span class="n">subStrings</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">pos</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">str</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">delimiter</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">)</span>
                    <span class="n">subStrings</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">str</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">start</span><span class="p">,</span> <span class="n">pos</span><span class="o">-</span><span class="n">start</span> <span class="p">)</span> <span class="p">);</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">subStrings</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">str</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">start</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="n">start</span> <span class="p">)</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">subStrings</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pluralise</span><span class="o">::</span><span class="n">pluralise</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">label</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_count</span><span class="p">(</span> <span class="n">count</span> <span class="p">),</span>
        <span class="n">m_label</span><span class="p">(</span> <span class="n">label</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">pluralise</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pluraliser</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">pluraliser</span><span class="p">.</span><span class="n">m_count</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">pluraliser</span><span class="p">.</span><span class="n">m_label</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">pluraliser</span><span class="p">.</span><span class="n">m_count</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">)</span>
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;s&#39;</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="c1">// end catch_string_manip.cpp</span>
<span class="c1">// start catch_stringref.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">StringRef</span><span class="o">::</span><span class="n">StringRef</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">rawChars</span> <span class="p">)</span> <span class="k">noexcept</span>
    <span class="o">:</span> <span class="n">StringRef</span><span class="p">(</span> <span class="n">rawChars</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">StringRef</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">rawChars</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="k">auto</span> <span class="n">StringRef</span><span class="o">::</span><span class="n">c_str</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="p">{</span>
        <span class="n">CATCH_ENFORCE</span><span class="p">(</span><span class="n">isNullTerminated</span><span class="p">(),</span> <span class="s">&quot;Called StringRef::c_str() on a non-null-terminated instance&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">m_start</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">StringRef</span><span class="o">::</span><span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_start</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">StringRef</span><span class="o">::</span><span class="n">substr</span><span class="p">(</span> <span class="n">size_type</span> <span class="n">start</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">size</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">StringRef</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">m_size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">StringRef</span><span class="p">(</span><span class="n">m_start</span> <span class="o">+</span> <span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">)(</span><span class="n">m_size</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">StringRef</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">StringRef</span><span class="o">::</span><span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_size</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">m_size</span>
            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memcmp</span><span class="p">(</span> <span class="n">m_start</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">m_start</span><span class="p">,</span> <span class="n">m_size</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="n">lhs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_stringref.cpp</span>
<span class="c1">// start catch_tag_alias.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">TagAlias</span><span class="o">::</span><span class="n">TagAlias</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">_tag</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="n">_lineInfo</span><span class="p">)</span><span class="o">:</span> <span class="n">tag</span><span class="p">(</span><span class="n">_tag</span><span class="p">),</span> <span class="n">lineInfo</span><span class="p">(</span><span class="n">_lineInfo</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="c1">// end catch_tag_alias.cpp</span>
<span class="c1">// start catch_tag_alias_autoregistrar.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">RegistrarForTagAliases</span><span class="o">::</span><span class="n">RegistrarForTagAliases</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">alias</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">tag</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">CATCH_TRY</span> <span class="p">{</span>
            <span class="n">getMutableRegistryHub</span><span class="p">().</span><span class="n">registerTagAlias</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">lineInfo</span><span class="p">);</span>
        <span class="p">}</span> <span class="n">CATCH_CATCH_ALL</span> <span class="p">{</span>
            <span class="c1">// Do not throw when constructing global objects, instead register the exception to be processed later</span>
            <span class="n">getMutableRegistryHub</span><span class="p">().</span><span class="n">registerStartupException</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="c1">// end catch_tag_alias_autoregistrar.cpp</span>
<span class="c1">// start catch_tag_alias_registry.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">TagAliasRegistry</span><span class="o">::~</span><span class="n">TagAliasRegistry</span><span class="p">()</span> <span class="p">{}</span>

    <span class="n">TagAlias</span> <span class="k">const</span><span class="o">*</span> <span class="n">TagAliasRegistry</span><span class="o">::</span><span class="n">find</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">alias</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">m_registry</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">alias</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">m_registry</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">TagAliasRegistry</span><span class="o">::</span><span class="n">expandAliases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">unexpandedTestSpec</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expandedTestSpec</span> <span class="o">=</span> <span class="n">unexpandedTestSpec</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">registryKvp</span> <span class="p">:</span> <span class="n">m_registry</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">expandedTestSpec</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">registryKvp</span><span class="p">.</span><span class="n">first</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">expandedTestSpec</span> <span class="o">=</span>  <span class="n">expandedTestSpec</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos</span> <span class="p">)</span> <span class="o">+</span>
                                    <span class="n">registryKvp</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">tag</span> <span class="o">+</span>
                                    <span class="n">expandedTestSpec</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">registryKvp</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">expandedTestSpec</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TagAliasRegistry</span><span class="o">::</span><span class="n">add</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">alias</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tag</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">CATCH_ENFORCE</span><span class="p">(</span> <span class="n">startsWith</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="s">&quot;[@&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">endsWith</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="sc">&#39;]&#39;</span><span class="p">),</span>
                      <span class="s">&quot;error: tag alias, &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">alias</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39; is not of the form [@alias name].</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">lineInfo</span> <span class="p">);</span>

        <span class="n">CATCH_ENFORCE</span><span class="p">(</span> <span class="n">m_registry</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">TagAlias</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">lineInfo</span><span class="p">))).</span><span class="n">second</span><span class="p">,</span>
                      <span class="s">&quot;error: tag alias, &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">alias</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39; already registered.</span><span class="se">\n</span><span class="s">&quot;</span>
                      <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">First seen at: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">find</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lineInfo</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
                      <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Redefined at: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">lineInfo</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ITagAliasRegistry</span><span class="o">::~</span><span class="n">ITagAliasRegistry</span><span class="p">()</span> <span class="p">{}</span>

    <span class="n">ITagAliasRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ITagAliasRegistry</span><span class="o">::</span><span class="n">get</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getRegistryHub</span><span class="p">().</span><span class="n">getTagAliasRegistry</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_tag_alias_registry.cpp</span>
<span class="c1">// start catch_test_case_info.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="p">{</span>
        <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">SpecialProperties</span> <span class="n">parseSpecialTag</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tag</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">startsWith</span><span class="p">(</span> <span class="n">tag</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span> <span class="p">)</span> <span class="o">||</span>
                <span class="n">tag</span> <span class="o">==</span> <span class="s">&quot;!hide&quot;</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">IsHidden</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">tag</span> <span class="o">==</span> <span class="s">&quot;!throws&quot;</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">Throws</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">tag</span> <span class="o">==</span> <span class="s">&quot;!shouldfail&quot;</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">ShouldFail</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">tag</span> <span class="o">==</span> <span class="s">&quot;!mayfail&quot;</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">MayFail</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">tag</span> <span class="o">==</span> <span class="s">&quot;!nonportable&quot;</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">NonPortable</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">tag</span> <span class="o">==</span> <span class="s">&quot;!benchmark&quot;</span> <span class="p">)</span>
                <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">SpecialProperties</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">Benchmark</span> <span class="o">|</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">IsHidden</span> <span class="p">);</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">None</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">isReservedTag</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tag</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">parseSpecialTag</span><span class="p">(</span> <span class="n">tag</span> <span class="p">)</span> <span class="o">==</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">None</span> <span class="o">&amp;&amp;</span> <span class="n">tag</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">isalnum</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="n">enforceNotReservedTag</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tag</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_lineInfo</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">CATCH_ENFORCE</span><span class="p">(</span> <span class="o">!</span><span class="n">isReservedTag</span><span class="p">(</span><span class="n">tag</span><span class="p">),</span>
                          <span class="s">&quot;Tag name: [&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tag</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;] is not allowed.</span><span class="se">\n</span><span class="s">&quot;</span>
                          <span class="o">&lt;&lt;</span> <span class="s">&quot;Tag names starting with non alphanumeric characters are reserved</span><span class="se">\n</span><span class="s">&quot;</span>
                          <span class="o">&lt;&lt;</span> <span class="n">_lineInfo</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">TestCase</span> <span class="n">makeTestCase</span><span class="p">(</span>  <span class="n">ITestInvoker</span><span class="o">*</span> <span class="n">_testCase</span><span class="p">,</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_className</span><span class="p">,</span>
                            <span class="n">NameAndTags</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndTags</span><span class="p">,</span>
                            <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_lineInfo</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">isHidden</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="c1">// Parse out tags</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">tags</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">desc</span><span class="p">,</span> <span class="n">tag</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">inTag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">nameAndTags</span><span class="p">.</span><span class="n">tags</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">inTag</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;[&#39;</span> <span class="p">)</span>
                    <span class="n">inTag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">desc</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;]&#39;</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">SpecialProperties</span> <span class="n">prop</span> <span class="o">=</span> <span class="n">parseSpecialTag</span><span class="p">(</span> <span class="n">tag</span> <span class="p">);</span>
                    <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">prop</span> <span class="o">&amp;</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">IsHidden</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
                        <span class="n">isHidden</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">prop</span> <span class="o">==</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">None</span> <span class="p">)</span>
                        <span class="n">enforceNotReservedTag</span><span class="p">(</span> <span class="n">tag</span><span class="p">,</span> <span class="n">_lineInfo</span> <span class="p">);</span>

                    <span class="c1">// Merged hide tags like `[.approvals]` should be added as</span>
                    <span class="c1">// `[.][approvals]`. The `[.]` is added at later point, so</span>
                    <span class="c1">// we only strip the prefix</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">startsWith</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tag</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">tag</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="n">tags</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">tag</span> <span class="p">);</span>
                    <span class="n">tag</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
                    <span class="n">inTag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span>
                    <span class="n">tag</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">isHidden</span> <span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Add all &quot;hidden&quot; tags to make them behave identically</span>
            <span class="n">tags</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">tags</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">{</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="s">&quot;!hide&quot;</span> <span class="p">}</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">TestCaseInfo</span> <span class="n">info</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nameAndTags</span><span class="p">.</span><span class="n">name</span><span class="p">),</span> <span class="n">_className</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">_lineInfo</span> <span class="p">);</span>
        <span class="k">return</span> <span class="nf">TestCase</span><span class="p">(</span> <span class="n">_testCase</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">setTags</span><span class="p">(</span> <span class="n">TestCaseInfo</span><span class="o">&amp;</span> <span class="n">testCaseInfo</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">tags</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">tags</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">tags</span><span class="p">));</span>
        <span class="n">tags</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">tags</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">tags</span><span class="p">)),</span> <span class="n">end</span><span class="p">(</span><span class="n">tags</span><span class="p">));</span>
        <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">lcaseTags</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">tag</span> <span class="p">:</span> <span class="n">tags</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">lcaseTag</span> <span class="o">=</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">tag</span> <span class="p">);</span>
            <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">properties</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">SpecialProperties</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">properties</span> <span class="o">|</span> <span class="n">parseSpecialTag</span><span class="p">(</span> <span class="n">lcaseTag</span> <span class="p">)</span> <span class="p">);</span>
            <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">lcaseTags</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">lcaseTag</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">tags</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tags</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">TestCaseInfo</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">,</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_className</span><span class="p">,</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_description</span><span class="p">,</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_tags</span><span class="p">,</span>
                                <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_lineInfo</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">name</span><span class="p">(</span> <span class="n">_name</span> <span class="p">),</span>
        <span class="n">className</span><span class="p">(</span> <span class="n">_className</span> <span class="p">),</span>
        <span class="n">description</span><span class="p">(</span> <span class="n">_description</span> <span class="p">),</span>
        <span class="n">lineInfo</span><span class="p">(</span> <span class="n">_lineInfo</span> <span class="p">),</span>
        <span class="n">properties</span><span class="p">(</span> <span class="n">None</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">setTags</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">_tags</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">isHidden</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">properties</span> <span class="o">&amp;</span> <span class="n">IsHidden</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="k">throws</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">properties</span> <span class="o">&amp;</span> <span class="n">Throws</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">okToFail</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">properties</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ShouldFail</span> <span class="o">|</span> <span class="n">MayFail</span> <span class="p">)</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">expectedToFail</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">properties</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ShouldFail</span> <span class="p">)</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">TestCaseInfo</span><span class="o">::</span><span class="n">tagsAsString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ret</span><span class="p">;</span>
        <span class="c1">// &#39;[&#39; and &#39;]&#39; per tag</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">full_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tags</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">tag</span> <span class="p">:</span> <span class="n">tags</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">full_size</span> <span class="o">+=</span> <span class="n">tag</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">ret</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">full_size</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">tag</span> <span class="p">:</span> <span class="n">tags</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39;[&#39;</span><span class="p">);</span>
            <span class="n">ret</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>
            <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39;]&#39;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">TestCase</span><span class="o">::</span><span class="n">TestCase</span><span class="p">(</span> <span class="n">ITestInvoker</span><span class="o">*</span> <span class="n">testCase</span><span class="p">,</span> <span class="n">TestCaseInfo</span><span class="o">&amp;&amp;</span> <span class="n">info</span> <span class="p">)</span> <span class="o">:</span> <span class="n">TestCaseInfo</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">),</span> <span class="n">test</span><span class="p">(</span> <span class="n">testCase</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="n">TestCase</span> <span class="n">TestCase</span><span class="o">::</span><span class="n">withName</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_newName</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">TestCase</span> <span class="nf">other</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
        <span class="n">other</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_newName</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">other</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TestCase</span><span class="o">::</span><span class="n">invoke</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">test</span><span class="o">-&gt;</span><span class="n">invoke</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">TestCase</span><span class="o">::</span><span class="k">operator</span> <span class="o">==</span> <span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span>  <span class="n">test</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">test</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
                <span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">name</span> <span class="o">&amp;&amp;</span>
                <span class="n">className</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">className</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">TestCase</span><span class="o">::</span><span class="k">operator</span> <span class="o">&lt;</span> <span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">name</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">TestCase</span><span class="o">::</span><span class="n">getTestCaseInfo</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_test_case_info.cpp</span>
<span class="c1">// start catch_test_case_registry_impl.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">TestHasher</span> <span class="p">{</span>
            <span class="k">using</span> <span class="n">hash_t</span> <span class="o">=</span> <span class="kt">uint64_t</span><span class="p">;</span>

            <span class="k">explicit</span> <span class="nf">TestHasher</span><span class="p">(</span> <span class="n">hash_t</span> <span class="n">hashSuffix</span> <span class="p">)</span><span class="o">:</span>
                <span class="n">m_hashSuffix</span><span class="p">{</span> <span class="n">hashSuffix</span> <span class="p">}</span> <span class="p">{}</span>

            <span class="kt">uint32_t</span> <span class="k">operator</span><span class="p">()(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                <span class="c1">// FNV-1a hash with multiplication fold.</span>
                <span class="k">const</span> <span class="n">hash_t</span> <span class="n">prime</span> <span class="o">=</span> <span class="mi">1099511628211u</span><span class="p">;</span>
                <span class="n">hash_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">14695981039346656037u</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">hash</span> <span class="o">^=</span> <span class="n">c</span><span class="p">;</span>
                    <span class="n">hash</span> <span class="o">*=</span> <span class="n">prime</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">hash</span> <span class="o">^=</span> <span class="n">m_hashSuffix</span><span class="p">;</span>
                <span class="n">hash</span> <span class="o">*=</span> <span class="n">prime</span><span class="p">;</span>
                <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">low</span><span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">hash</span> <span class="p">)</span> <span class="p">};</span>
                <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">high</span><span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span> <span class="p">)</span> <span class="p">};</span>
                <span class="k">return</span> <span class="n">low</span> <span class="o">*</span> <span class="n">high</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="k">private</span><span class="o">:</span>
            <span class="n">hash_t</span> <span class="n">m_hashSuffix</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span> <span class="c1">// end unnamed namespace</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">sortTests</span><span class="p">(</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">unsortedTestCases</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">runOrder</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">RunTests</span><span class="o">::</span><span class="nl">InDeclarationOrder</span><span class="p">:</span>
                <span class="c1">// already in declaration order</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="n">RunTests</span><span class="o">::</span><span class="nl">InLexicographicalOrder</span><span class="p">:</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">sorted</span> <span class="o">=</span> <span class="n">unsortedTestCases</span><span class="p">;</span>
                <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span> <span class="n">sorted</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sorted</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
                <span class="k">return</span> <span class="n">sorted</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">case</span> <span class="n">RunTests</span><span class="o">::</span><span class="nl">InRandomOrder</span><span class="p">:</span> <span class="p">{</span>
                <span class="n">seedRng</span><span class="p">(</span> <span class="n">config</span> <span class="p">);</span>
                <span class="n">TestHasher</span> <span class="n">h</span><span class="p">{</span> <span class="n">config</span><span class="p">.</span><span class="n">rngSeed</span><span class="p">()</span> <span class="p">};</span>

                <span class="k">using</span> <span class="n">hashedTest</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TestHasher</span><span class="o">::</span><span class="n">hash_t</span><span class="p">,</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">;</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">hashedTest</span><span class="o">&gt;</span> <span class="n">indexed_tests</span><span class="p">;</span>
                <span class="n">indexed_tests</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="n">unsortedTestCases</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">testCase</span> <span class="p">:</span> <span class="n">unsortedTestCases</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">indexed_tests</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">testCase</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">testCase</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">indexed_tests</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indexed_tests</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                          <span class="p">[](</span><span class="n">hashedTest</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">hashedTest</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
                          <span class="k">if</span> <span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
                              <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
                          <span class="p">}</span>
                          <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
                <span class="p">});</span>

                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">sorted</span><span class="p">;</span>
                <span class="n">sorted</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="n">indexed_tests</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">hashed</span> <span class="p">:</span> <span class="n">indexed_tests</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">sorted</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="o">*</span><span class="n">hashed</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="n">sorted</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">unsortedTestCases</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">isThrowSafe</span><span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">testCase</span><span class="p">.</span><span class="k">throws</span><span class="p">()</span> <span class="o">||</span> <span class="n">config</span><span class="p">.</span><span class="n">allowThrows</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">matchTest</span><span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span><span class="p">,</span> <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">testSpec</span><span class="p">.</span><span class="n">matches</span><span class="p">(</span> <span class="n">testCase</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isThrowSafe</span><span class="p">(</span> <span class="n">testCase</span><span class="p">,</span> <span class="n">config</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">enforceNoDuplicateTestCases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">functions</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">seenFunctions</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">function</span> <span class="p">:</span> <span class="n">functions</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">seenFunctions</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">function</span> <span class="p">);</span>
            <span class="n">CATCH_ENFORCE</span><span class="p">(</span> <span class="n">prev</span><span class="p">.</span><span class="n">second</span><span class="p">,</span>
                    <span class="s">&quot;error: TEST_CASE( </span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">function</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s"> ) already defined.</span><span class="se">\n</span><span class="s">&quot;</span>
                    <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">First seen at &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">prev</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">getTestCaseInfo</span><span class="p">().</span><span class="n">lineInfo</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
                    <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Redefined at &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">function</span><span class="p">.</span><span class="n">getTestCaseInfo</span><span class="p">().</span><span class="n">lineInfo</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">filterTests</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCases</span><span class="p">,</span> <span class="n">TestSpec</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="n">filtered</span><span class="p">;</span>
        <span class="n">filtered</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="n">testCases</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">testCase</span> <span class="p">:</span> <span class="n">testCases</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">testSpec</span><span class="p">.</span><span class="n">hasFilters</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">testCase</span><span class="p">.</span><span class="n">isHidden</span><span class="p">())</span> <span class="o">||</span>
                <span class="p">(</span><span class="n">testSpec</span><span class="p">.</span><span class="n">hasFilters</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">matchTest</span><span class="p">(</span><span class="n">testCase</span><span class="p">,</span> <span class="n">testSpec</span><span class="p">,</span> <span class="n">config</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">filtered</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">testCase</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">filtered</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">getAllTestCasesSorted</span><span class="p">(</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getRegistryHub</span><span class="p">().</span><span class="n">getTestCaseRegistry</span><span class="p">().</span><span class="n">getAllTestsSorted</span><span class="p">(</span> <span class="n">config</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TestRegistry</span><span class="o">::</span><span class="n">registerTest</span><span class="p">(</span> <span class="n">TestCase</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="n">testCase</span><span class="p">.</span><span class="n">getTestCaseInfo</span><span class="p">().</span><span class="n">name</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">name</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Anonymous test case &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">m_unnamedCount</span><span class="p">;</span>
            <span class="k">return</span> <span class="nf">registerTest</span><span class="p">(</span> <span class="n">testCase</span><span class="p">.</span><span class="n">withName</span><span class="p">(</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_functions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">testCase</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">TestRegistry</span><span class="o">::</span><span class="n">getAllTests</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_functions</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">TestRegistry</span><span class="o">::</span><span class="n">getAllTestsSorted</span><span class="p">(</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_sortedFunctions</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">enforceNoDuplicateTestCases</span><span class="p">(</span> <span class="n">m_functions</span> <span class="p">);</span>

        <span class="k">if</span><span class="p">(</span>  <span class="n">m_currentSortOrder</span> <span class="o">!=</span> <span class="n">config</span><span class="p">.</span><span class="n">runOrder</span><span class="p">()</span> <span class="o">||</span> <span class="n">m_sortedFunctions</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_sortedFunctions</span> <span class="o">=</span> <span class="n">sortTests</span><span class="p">(</span> <span class="n">config</span><span class="p">,</span> <span class="n">m_functions</span> <span class="p">);</span>
            <span class="n">m_currentSortOrder</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">runOrder</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m_sortedFunctions</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">///////////////////////////////////////////////////////////////////////////</span>
    <span class="n">TestInvokerAsFunction</span><span class="o">::</span><span class="n">TestInvokerAsFunction</span><span class="p">(</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">testAsFunction</span><span class="p">)()</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">m_testAsFunction</span><span class="p">(</span> <span class="n">testAsFunction</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">TestInvokerAsFunction</span><span class="o">::</span><span class="n">invoke</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">m_testAsFunction</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">extractClassName</span><span class="p">(</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">classOrQualifiedMethodName</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">className</span><span class="p">(</span><span class="n">classOrQualifiedMethodName</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">startsWith</span><span class="p">(</span> <span class="n">className</span><span class="p">,</span> <span class="sc">&#39;&amp;&#39;</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">lastColons</span> <span class="o">=</span> <span class="n">className</span><span class="p">.</span><span class="n">rfind</span><span class="p">(</span> <span class="s">&quot;::&quot;</span> <span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">penultimateColons</span> <span class="o">=</span> <span class="n">className</span><span class="p">.</span><span class="n">rfind</span><span class="p">(</span> <span class="s">&quot;::&quot;</span><span class="p">,</span> <span class="n">lastColons</span><span class="mi">-1</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">penultimateColons</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="p">)</span>
                <span class="n">penultimateColons</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">className</span> <span class="o">=</span> <span class="n">className</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">penultimateColons</span><span class="p">,</span> <span class="n">lastColons</span><span class="o">-</span><span class="n">penultimateColons</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">className</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_test_case_registry_impl.cpp</span>
<span class="c1">// start catch_test_case_tracker.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>

<span class="cp">#if defined(__clang__)</span>
<span class="cp">#    pragma clang diagnostic push</span>
<span class="cp">#    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">TestCaseTracking</span> <span class="p">{</span>

    <span class="n">NameAndLocation</span><span class="o">::</span><span class="n">NameAndLocation</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_location</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">name</span><span class="p">(</span> <span class="n">_name</span> <span class="p">),</span>
        <span class="n">location</span><span class="p">(</span> <span class="n">_location</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">ITracker</span><span class="o">::~</span><span class="n">ITracker</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">ITracker</span><span class="o">&amp;</span> <span class="n">TrackerContext</span><span class="o">::</span><span class="n">startRun</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_rootTracker</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SectionTracker</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">NameAndLocation</span><span class="p">(</span> <span class="s">&quot;{root}&quot;</span><span class="p">,</span> <span class="n">CATCH_INTERNAL_LINEINFO</span> <span class="p">),</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="k">nullptr</span> <span class="p">);</span>
        <span class="n">m_currentTracker</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">m_runState</span> <span class="o">=</span> <span class="n">Executing</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_rootTracker</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TrackerContext</span><span class="o">::</span><span class="n">endRun</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_rootTracker</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
        <span class="n">m_currentTracker</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">m_runState</span> <span class="o">=</span> <span class="n">NotStarted</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TrackerContext</span><span class="o">::</span><span class="n">startCycle</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_currentTracker</span> <span class="o">=</span> <span class="n">m_rootTracker</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
        <span class="n">m_runState</span> <span class="o">=</span> <span class="n">Executing</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">TrackerContext</span><span class="o">::</span><span class="n">completeCycle</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_runState</span> <span class="o">=</span> <span class="n">CompletedCycle</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">TrackerContext</span><span class="o">::</span><span class="n">completedCycle</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_runState</span> <span class="o">==</span> <span class="n">CompletedCycle</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ITracker</span><span class="o">&amp;</span> <span class="n">TrackerContext</span><span class="o">::</span><span class="n">currentTracker</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_currentTracker</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">TrackerContext</span><span class="o">::</span><span class="n">setCurrentTracker</span><span class="p">(</span> <span class="n">ITracker</span><span class="o">*</span> <span class="n">tracker</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_currentTracker</span> <span class="o">=</span> <span class="n">tracker</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">TrackerBase</span><span class="o">::</span><span class="n">TrackerBase</span><span class="p">(</span> <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span><span class="p">,</span> <span class="n">TrackerContext</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ITracker</span><span class="o">*</span> <span class="n">parent</span> <span class="p">)</span><span class="o">:</span>
        <span class="n">ITracker</span><span class="p">(</span><span class="n">nameAndLocation</span><span class="p">),</span>
        <span class="n">m_ctx</span><span class="p">(</span> <span class="n">ctx</span> <span class="p">),</span>
        <span class="n">m_parent</span><span class="p">(</span> <span class="n">parent</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">isComplete</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_runState</span> <span class="o">==</span> <span class="n">CompletedSuccessfully</span> <span class="o">||</span> <span class="n">m_runState</span> <span class="o">==</span> <span class="n">Failed</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">isSuccessfullyCompleted</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_runState</span> <span class="o">==</span> <span class="n">CompletedSuccessfully</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">isOpen</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_runState</span> <span class="o">!=</span> <span class="n">NotStarted</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isComplete</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">hasChildren</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">m_children</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">addChild</span><span class="p">(</span> <span class="n">ITrackerPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_children</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">child</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ITrackerPtr</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">findChild</span><span class="p">(</span> <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span> <span class="n">m_children</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_children</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
            <span class="p">[</span><span class="o">&amp;</span><span class="n">nameAndLocation</span><span class="p">](</span> <span class="n">ITrackerPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tracker</span> <span class="p">){</span>
                <span class="k">return</span>
                    <span class="n">tracker</span><span class="o">-&gt;</span><span class="n">nameAndLocation</span><span class="p">().</span><span class="n">location</span> <span class="o">==</span> <span class="n">nameAndLocation</span><span class="p">.</span><span class="n">location</span> <span class="o">&amp;&amp;</span>
                    <span class="n">tracker</span><span class="o">-&gt;</span><span class="n">nameAndLocation</span><span class="p">().</span><span class="n">name</span> <span class="o">==</span> <span class="n">nameAndLocation</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
            <span class="p">}</span> <span class="p">);</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">m_children</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span>
            <span class="o">?</span> <span class="o">*</span><span class="nl">it</span>
            <span class="p">:</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ITracker</span><span class="o">&amp;</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">parent</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span> <span class="n">m_parent</span> <span class="p">);</span> <span class="c1">// Should always be non-null except for root</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">m_parent</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">openChild</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_runState</span> <span class="o">!=</span> <span class="n">ExecutingChildren</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_runState</span> <span class="o">=</span> <span class="n">ExecutingChildren</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_parent</span> <span class="p">)</span>
                <span class="n">m_parent</span><span class="o">-&gt;</span><span class="n">openChild</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">isSectionTracker</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">isGeneratorTracker</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">open</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_runState</span> <span class="o">=</span> <span class="n">Executing</span><span class="p">;</span>
        <span class="n">moveToThis</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_parent</span> <span class="p">)</span>
            <span class="n">m_parent</span><span class="o">-&gt;</span><span class="n">openChild</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">close</span><span class="p">()</span> <span class="p">{</span>

        <span class="c1">// Close any still open children (e.g. generators)</span>
        <span class="k">while</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">m_ctx</span><span class="p">.</span><span class="n">currentTracker</span><span class="p">()</span> <span class="o">!=</span> <span class="k">this</span> <span class="p">)</span>
            <span class="n">m_ctx</span><span class="p">.</span><span class="n">currentTracker</span><span class="p">().</span><span class="n">close</span><span class="p">();</span>

        <span class="k">switch</span><span class="p">(</span> <span class="n">m_runState</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nl">NeedsAnotherRun</span><span class="p">:</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="nl">Executing</span><span class="p">:</span>
                <span class="n">m_runState</span> <span class="o">=</span> <span class="n">CompletedSuccessfully</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">ExecutingChildren</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span><span class="n">m_children</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_children</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">ITrackerPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">){</span> <span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">isComplete</span><span class="p">();</span> <span class="p">})</span> <span class="p">)</span>
                    <span class="n">m_runState</span> <span class="o">=</span> <span class="n">CompletedSuccessfully</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="nl">NotStarted</span><span class="p">:</span>
            <span class="k">case</span> <span class="nl">CompletedSuccessfully</span><span class="p">:</span>
            <span class="k">case</span> <span class="nl">Failed</span><span class="p">:</span>
                <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span> <span class="s">&quot;Illogical state: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_runState</span> <span class="p">);</span>

            <span class="k">default</span><span class="o">:</span>
                <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span> <span class="s">&quot;Unknown state: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_runState</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">moveToParent</span><span class="p">();</span>
        <span class="n">m_ctx</span><span class="p">.</span><span class="n">completeCycle</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">fail</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_runState</span> <span class="o">=</span> <span class="n">Failed</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_parent</span> <span class="p">)</span>
            <span class="n">m_parent</span><span class="o">-&gt;</span><span class="n">markAsNeedingAnotherRun</span><span class="p">();</span>
        <span class="n">moveToParent</span><span class="p">();</span>
        <span class="n">m_ctx</span><span class="p">.</span><span class="n">completeCycle</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">markAsNeedingAnotherRun</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_runState</span> <span class="o">=</span> <span class="n">NeedsAnotherRun</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">moveToParent</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span> <span class="n">m_parent</span> <span class="p">);</span>
        <span class="n">m_ctx</span><span class="p">.</span><span class="n">setCurrentTracker</span><span class="p">(</span> <span class="n">m_parent</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">moveToThis</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_ctx</span><span class="p">.</span><span class="n">setCurrentTracker</span><span class="p">(</span> <span class="k">this</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">SectionTracker</span><span class="o">::</span><span class="n">SectionTracker</span><span class="p">(</span> <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span><span class="p">,</span> <span class="n">TrackerContext</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">ITracker</span><span class="o">*</span> <span class="n">parent</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">TrackerBase</span><span class="p">(</span> <span class="n">nameAndLocation</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">parent</span> <span class="p">),</span>
        <span class="n">m_trimmed_name</span><span class="p">(</span><span class="n">trim</span><span class="p">(</span><span class="n">nameAndLocation</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">parent</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">isSectionTracker</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">();</span>

            <span class="n">SectionTracker</span><span class="o">&amp;</span> <span class="n">parentSection</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">SectionTracker</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="o">*</span><span class="n">parent</span> <span class="p">);</span>
            <span class="n">addNextFilters</span><span class="p">(</span> <span class="n">parentSection</span><span class="p">.</span><span class="n">m_filters</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">SectionTracker</span><span class="o">::</span><span class="n">isComplete</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">complete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">m_filters</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span>
            <span class="o">||</span> <span class="n">m_filters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;&quot;</span>
            <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">m_filters</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_filters</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">m_trimmed_name</span><span class="p">)</span> <span class="o">!=</span> <span class="n">m_filters</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">complete</span> <span class="o">=</span> <span class="n">TrackerBase</span><span class="o">::</span><span class="n">isComplete</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">complete</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">SectionTracker</span><span class="o">::</span><span class="n">isSectionTracker</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">SectionTracker</span><span class="o">&amp;</span> <span class="n">SectionTracker</span><span class="o">::</span><span class="n">acquire</span><span class="p">(</span> <span class="n">TrackerContext</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">NameAndLocation</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndLocation</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SectionTracker</span><span class="o">&gt;</span> <span class="n">section</span><span class="p">;</span>

        <span class="n">ITracker</span><span class="o">&amp;</span> <span class="n">currentTracker</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">currentTracker</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">ITrackerPtr</span> <span class="n">childTracker</span> <span class="o">=</span> <span class="n">currentTracker</span><span class="p">.</span><span class="n">findChild</span><span class="p">(</span> <span class="n">nameAndLocation</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span> <span class="n">childTracker</span> <span class="p">);</span>
            <span class="n">assert</span><span class="p">(</span> <span class="n">childTracker</span><span class="o">-&gt;</span><span class="n">isSectionTracker</span><span class="p">()</span> <span class="p">);</span>
            <span class="n">section</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">SectionTracker</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">childTracker</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">section</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">SectionTracker</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">nameAndLocation</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">currentTracker</span> <span class="p">);</span>
            <span class="n">currentTracker</span><span class="p">.</span><span class="n">addChild</span><span class="p">(</span> <span class="n">section</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">ctx</span><span class="p">.</span><span class="n">completedCycle</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">section</span><span class="o">-&gt;</span><span class="n">tryOpen</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">section</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">SectionTracker</span><span class="o">::</span><span class="n">tryOpen</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">isComplete</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">open</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">SectionTracker</span><span class="o">::</span><span class="n">addInitialFilters</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filters</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">filters</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_filters</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span> <span class="n">m_filters</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">filters</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">);</span>
            <span class="n">m_filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span> <span class="c1">// Root - should never be consulted</span>
            <span class="n">m_filters</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span> <span class="c1">// Test Case - not a section filter</span>
            <span class="n">m_filters</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">m_filters</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">filters</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">filters</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">SectionTracker</span><span class="o">::</span><span class="n">addNextFilters</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filters</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">filters</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">)</span>
            <span class="n">m_filters</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">m_filters</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">filters</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">filters</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">SectionTracker</span><span class="o">::</span><span class="n">getFilters</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_filters</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">SectionTracker</span><span class="o">::</span><span class="n">trimmedName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_trimmed_name</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace TestCaseTracking</span>

<span class="k">using</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">ITracker</span><span class="p">;</span>
<span class="k">using</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">TrackerContext</span><span class="p">;</span>
<span class="k">using</span> <span class="n">TestCaseTracking</span><span class="o">::</span><span class="n">SectionTracker</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>

<span class="cp">#if defined(__clang__)</span>
<span class="cp">#    pragma clang diagnostic pop</span>
<span class="cp">#endif</span>
<span class="c1">// end catch_test_case_tracker.cpp</span>
<span class="c1">// start catch_test_registry.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">auto</span> <span class="nf">makeTestInvoker</span><span class="p">(</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">testAsFunction</span><span class="p">)()</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">ITestInvoker</span><span class="o">*</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="n">TestInvokerAsFunction</span><span class="p">(</span> <span class="n">testAsFunction</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">NameAndTags</span><span class="o">::</span><span class="n">NameAndTags</span><span class="p">(</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name_</span> <span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tags_</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span> <span class="n">name_</span> <span class="p">),</span> <span class="n">tags</span><span class="p">(</span> <span class="n">tags_</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="n">AutoReg</span><span class="o">::</span><span class="n">AutoReg</span><span class="p">(</span> <span class="n">ITestInvoker</span><span class="o">*</span> <span class="n">invoker</span><span class="p">,</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">lineInfo</span><span class="p">,</span> <span class="n">StringRef</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">classOrMethod</span><span class="p">,</span> <span class="n">NameAndTags</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">nameAndTags</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="n">CATCH_TRY</span> <span class="p">{</span>
            <span class="n">getMutableRegistryHub</span><span class="p">()</span>
                    <span class="p">.</span><span class="n">registerTest</span><span class="p">(</span>
                        <span class="n">makeTestCase</span><span class="p">(</span>
                            <span class="n">invoker</span><span class="p">,</span>
                            <span class="n">extractClassName</span><span class="p">(</span> <span class="n">classOrMethod</span> <span class="p">),</span>
                            <span class="n">nameAndTags</span><span class="p">,</span>
                            <span class="n">lineInfo</span><span class="p">));</span>
        <span class="p">}</span> <span class="n">CATCH_CATCH_ALL</span> <span class="p">{</span>
            <span class="c1">// Do not throw when constructing global objects, instead register the exception to be processed later</span>
            <span class="n">getMutableRegistryHub</span><span class="p">().</span><span class="n">registerStartupException</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">AutoReg</span><span class="o">::~</span><span class="n">AutoReg</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// end catch_test_registry.cpp</span>
<span class="c1">// start catch_test_spec.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">TestSpec</span><span class="o">::</span><span class="n">Pattern</span><span class="o">::</span><span class="n">Pattern</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">m_name</span><span class="p">(</span> <span class="n">name</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">TestSpec</span><span class="o">::</span><span class="n">Pattern</span><span class="o">::~</span><span class="n">Pattern</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">Pattern</span><span class="o">::</span><span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">TestSpec</span><span class="o">::</span><span class="n">NamePattern</span><span class="o">::</span><span class="n">NamePattern</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filterString</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">Pattern</span><span class="p">(</span> <span class="n">filterString</span> <span class="p">)</span>
    <span class="p">,</span> <span class="n">m_wildcardPattern</span><span class="p">(</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">name</span> <span class="p">),</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">No</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">NamePattern</span><span class="o">::</span><span class="n">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_wildcardPattern</span><span class="p">.</span><span class="n">matches</span><span class="p">(</span> <span class="n">testCase</span><span class="p">.</span><span class="n">name</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">TestSpec</span><span class="o">::</span><span class="n">TagPattern</span><span class="o">::</span><span class="n">TagPattern</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tag</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filterString</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">Pattern</span><span class="p">(</span> <span class="n">filterString</span> <span class="p">)</span>
    <span class="p">,</span> <span class="n">m_tag</span><span class="p">(</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">tag</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">TagPattern</span><span class="o">::</span><span class="n">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">testCase</span><span class="p">.</span><span class="n">lcaseTags</span><span class="p">),</span>
                         <span class="n">end</span><span class="p">(</span><span class="n">testCase</span><span class="p">.</span><span class="n">lcaseTags</span><span class="p">),</span>
                         <span class="n">m_tag</span><span class="p">)</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">testCase</span><span class="p">.</span><span class="n">lcaseTags</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">TestSpec</span><span class="o">::</span><span class="n">ExcludedPattern</span><span class="o">::</span><span class="n">ExcludedPattern</span><span class="p">(</span> <span class="n">PatternPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">underlyingPattern</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">Pattern</span><span class="p">(</span> <span class="n">underlyingPattern</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">,</span> <span class="n">m_underlyingPattern</span><span class="p">(</span> <span class="n">underlyingPattern</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">ExcludedPattern</span><span class="o">::</span><span class="n">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">m_underlyingPattern</span><span class="o">-&gt;</span><span class="n">matches</span><span class="p">(</span> <span class="n">testCase</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">Filter</span><span class="o">::</span><span class="n">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span> <span class="n">m_patterns</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_patterns</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">PatternPtr</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p</span> <span class="p">){</span> <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">matches</span><span class="p">(</span> <span class="n">testCase</span> <span class="p">);</span> <span class="p">}</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">Filter</span><span class="o">::</span><span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">m_patterns</span> <span class="p">)</span>
            <span class="n">name</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">hasFilters</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">m_filters</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">matches</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCase</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">any_of</span><span class="p">(</span> <span class="n">m_filters</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_filters</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">Filter</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span> <span class="p">){</span> <span class="k">return</span> <span class="n">f</span><span class="p">.</span><span class="n">matches</span><span class="p">(</span> <span class="n">testCase</span> <span class="p">);</span> <span class="p">}</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">TestSpec</span><span class="o">::</span><span class="n">Matches</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">matchesByFilter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCases</span><span class="p">,</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span> <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">Matches</span> <span class="nf">matches</span><span class="p">(</span> <span class="n">m_filters</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span> <span class="n">m_filters</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">m_filters</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">matches</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">Filter</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">filter</span> <span class="p">){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TestCase</span> <span class="k">const</span><span class="o">*&gt;</span> <span class="n">currentMatches</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">test</span> <span class="p">:</span> <span class="n">testCases</span> <span class="p">)</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">isThrowSafe</span><span class="p">(</span> <span class="n">test</span><span class="p">,</span> <span class="n">config</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">filter</span><span class="p">.</span><span class="n">matches</span><span class="p">(</span> <span class="n">test</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">currentMatches</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">test</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">FilterMatch</span><span class="p">{</span> <span class="n">filter</span><span class="p">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">currentMatches</span> <span class="p">};</span>
        <span class="p">}</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">matches</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">vectorStrings</span><span class="o">&amp;</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">getInvalidArgs</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
        <span class="k">return</span>  <span class="p">(</span><span class="n">m_invalidArgs</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="c1">// end catch_test_spec.cpp</span>
<span class="c1">// start catch_test_spec_parser.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">TestSpecParser</span><span class="p">(</span> <span class="n">ITagAliasRegistry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tagAliases</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_tagAliases</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">tagAliases</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="n">TestSpecParser</span><span class="o">&amp;</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arg</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_mode</span> <span class="o">=</span> <span class="n">None</span><span class="p">;</span>
        <span class="n">m_exclusion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">m_arg</span> <span class="o">=</span> <span class="n">m_tagAliases</span><span class="o">-&gt;</span><span class="n">expandAliases</span><span class="p">(</span> <span class="n">arg</span> <span class="p">);</span>
        <span class="n">m_escapeChars</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">m_substring</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">m_arg</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="n">m_patternName</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">m_arg</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="n">m_realPatternPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span><span class="p">(</span> <span class="n">m_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m_pos</span> <span class="o">&lt;</span> <span class="n">m_arg</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">m_pos</span> <span class="p">)</span>
          <span class="c1">//if visitChar fails</span>
           <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">visitChar</span><span class="p">(</span> <span class="n">m_arg</span><span class="p">[</span><span class="n">m_pos</span><span class="p">]</span> <span class="p">)</span> <span class="p">){</span>
               <span class="n">m_testSpec</span><span class="p">.</span><span class="n">m_invalidArgs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
               <span class="k">break</span><span class="p">;</span>
           <span class="p">}</span>
        <span class="n">endMode</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">TestSpec</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">testSpec</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">addFilter</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">m_testSpec</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">visitChar</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">m_mode</span> <span class="o">!=</span> <span class="n">EscapedName</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\\&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">escape</span><span class="p">();</span>
            <span class="n">addCharToPattern</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">m_mode</span> <span class="o">!=</span> <span class="n">EscapedName</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="p">)</span>  <span class="p">{</span>
            <span class="k">return</span> <span class="nf">separate</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">switch</span><span class="p">(</span> <span class="n">m_mode</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">None</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">processNoneChar</span><span class="p">(</span> <span class="n">c</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">Name</span><span class="p">:</span>
            <span class="n">processNameChar</span><span class="p">(</span> <span class="n">c</span> <span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">EscapedName</span><span class="p">:</span>
            <span class="n">endMode</span><span class="p">();</span>
            <span class="n">addCharToPattern</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
        <span class="k">case</span> <span class="nl">Tag</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">QuotedName</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">processOtherChar</span><span class="p">(</span> <span class="n">c</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">m_substring</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">isControlChar</span><span class="p">(</span> <span class="n">c</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_patternName</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
            <span class="n">m_realPatternPos</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Two of the processing methods return true to signal the caller to return</span>
    <span class="c1">// without adding the given character to the current pattern strings</span>
    <span class="kt">bool</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">processNoneChar</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="sc">&#39; &#39;</span><span class="o">:</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39;~&#39;</span><span class="o">:</span>
            <span class="n">m_exclusion</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39;[&#39;</span><span class="o">:</span>
            <span class="n">startNewMode</span><span class="p">(</span> <span class="n">Tag</span> <span class="p">);</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39;&quot;&#39;</span><span class="o">:</span>
            <span class="n">startNewMode</span><span class="p">(</span> <span class="n">QuotedName</span> <span class="p">);</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">startNewMode</span><span class="p">(</span> <span class="n">Name</span> <span class="p">);</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">processNameChar</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;[&#39;</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_substring</span> <span class="o">==</span> <span class="s">&quot;exclude:&quot;</span> <span class="p">)</span>
                <span class="n">m_exclusion</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="nf">endMode</span><span class="p">();</span>
            <span class="n">startNewMode</span><span class="p">(</span> <span class="n">Tag</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">processOtherChar</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">isControlChar</span><span class="p">(</span> <span class="n">c</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">m_substring</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">endMode</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">startNewMode</span><span class="p">(</span> <span class="n">Mode</span> <span class="n">mode</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">endMode</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span> <span class="n">m_mode</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">Name</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">QuotedName</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">addNamePattern</span><span class="p">();</span>
        <span class="k">case</span> <span class="nl">Tag</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">addTagPattern</span><span class="p">();</span>
        <span class="k">case</span> <span class="nl">EscapedName</span><span class="p">:</span>
            <span class="n">revertBackToLastMode</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">None</span><span class="p">:</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="n">startNewMode</span><span class="p">(</span> <span class="n">None</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">escape</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">saveLastMode</span><span class="p">();</span>
        <span class="n">m_mode</span> <span class="o">=</span> <span class="n">EscapedName</span><span class="p">;</span>
        <span class="n">m_escapeChars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m_realPatternPos</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">isControlChar</span><span class="p">(</span> <span class="kt">char</span> <span class="n">c</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span> <span class="n">m_mode</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;~&#39;</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">Name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;[&#39;</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">EscapedName</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">QuotedName</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">Tag</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;[&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;]&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">addFilter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">m_currentFilter</span><span class="p">.</span><span class="n">m_patterns</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_testSpec</span><span class="p">.</span><span class="n">m_filters</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">m_currentFilter</span> <span class="p">);</span>
            <span class="n">m_currentFilter</span> <span class="o">=</span> <span class="n">TestSpec</span><span class="o">::</span><span class="n">Filter</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">saveLastMode</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">lastMode</span> <span class="o">=</span> <span class="n">m_mode</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">revertBackToLastMode</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">m_mode</span> <span class="o">=</span> <span class="n">lastMode</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">separate</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">m_mode</span><span class="o">==</span><span class="n">QuotedName</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">m_mode</span><span class="o">==</span><span class="n">Tag</span><span class="p">)</span> <span class="p">){</span>
         <span class="c1">//invalid argument, signal failure to previous scope.</span>
         <span class="n">m_mode</span> <span class="o">=</span> <span class="n">None</span><span class="p">;</span>
         <span class="n">m_pos</span> <span class="o">=</span> <span class="n">m_arg</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
         <span class="n">m_substring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
         <span class="n">m_patternName</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
         <span class="n">m_realPatternPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
         <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">endMode</span><span class="p">();</span>
      <span class="n">addFilter</span><span class="p">();</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">//success</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">preprocessPattern</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">token</span> <span class="o">=</span> <span class="n">m_patternName</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_escapeChars</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">token</span> <span class="o">=</span> <span class="n">token</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m_escapeChars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">token</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">m_escapeChars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">m_escapeChars</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">startsWith</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="s">&quot;exclude:&quot;</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">m_exclusion</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">token</span> <span class="o">=</span> <span class="n">token</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">m_patternName</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">m_realPatternPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">token</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">addNamePattern</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">token</span> <span class="o">=</span> <span class="n">preprocessPattern</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">token</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">TestSpec</span><span class="o">::</span><span class="n">PatternPtr</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">TestSpec</span><span class="o">::</span><span class="n">NamePattern</span><span class="o">&gt;</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">m_substring</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_exclusion</span><span class="p">)</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">TestSpec</span><span class="o">::</span><span class="n">ExcludedPattern</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span>
            <span class="n">m_currentFilter</span><span class="p">.</span><span class="n">m_patterns</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_substring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">m_exclusion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">m_mode</span> <span class="o">=</span> <span class="n">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TestSpecParser</span><span class="o">::</span><span class="n">addTagPattern</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">token</span> <span class="o">=</span> <span class="n">preprocessPattern</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">token</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// If the tag pattern is the &quot;hide and tag&quot; shorthand (e.g. [.foo])</span>
            <span class="c1">// we have to create a separate hide tag and shorten the real one</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">token</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
                <span class="n">TestSpec</span><span class="o">::</span><span class="n">PatternPtr</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">TestSpec</span><span class="o">::</span><span class="n">TagPattern</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="n">m_substring</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m_exclusion</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">pattern</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">TestSpec</span><span class="o">::</span><span class="n">ExcludedPattern</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">m_currentFilter</span><span class="p">.</span><span class="n">m_patterns</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">TestSpec</span><span class="o">::</span><span class="n">PatternPtr</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">TestSpec</span><span class="o">::</span><span class="n">TagPattern</span><span class="o">&gt;</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">m_substring</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">m_exclusion</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">TestSpec</span><span class="o">::</span><span class="n">ExcludedPattern</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">m_currentFilter</span><span class="p">.</span><span class="n">m_patterns</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_substring</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">m_exclusion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">m_mode</span> <span class="o">=</span> <span class="n">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">TestSpec</span> <span class="n">parseTestSpec</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">arg</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">TestSpecParser</span><span class="p">(</span> <span class="n">ITagAliasRegistry</span><span class="o">::</span><span class="n">get</span><span class="p">()</span> <span class="p">).</span><span class="n">parse</span><span class="p">(</span> <span class="n">arg</span> <span class="p">).</span><span class="n">testSpec</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_test_spec_parser.cpp</span>
<span class="c1">// start catch_timer.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">nanosecondsInSecond</span> <span class="o">=</span> <span class="mi">1000000000</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">auto</span> <span class="nf">getCurrentNanosecondsSinceEpoch</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">uint64_t</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">nanoseconds</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">().</span><span class="n">time_since_epoch</span><span class="p">()</span> <span class="p">).</span><span class="n">count</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">namespace</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="nf">estimateClockResolution</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">uint64_t</span> <span class="p">{</span>
            <span class="kt">uint64_t</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>

            <span class="k">auto</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">getCurrentNanosecondsSinceEpoch</span><span class="p">();</span>

            <span class="k">for</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>

                <span class="kt">uint64_t</span> <span class="n">ticks</span><span class="p">;</span>
                <span class="kt">uint64_t</span> <span class="n">baseTicks</span> <span class="o">=</span> <span class="n">getCurrentNanosecondsSinceEpoch</span><span class="p">();</span>
                <span class="k">do</span> <span class="p">{</span>
                    <span class="n">ticks</span> <span class="o">=</span> <span class="n">getCurrentNanosecondsSinceEpoch</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">ticks</span> <span class="o">==</span> <span class="n">baseTicks</span> <span class="p">);</span>

                <span class="k">auto</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">ticks</span> <span class="o">-</span> <span class="n">baseTicks</span><span class="p">;</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>

                <span class="c1">// If we have been calibrating for over 3 seconds -- the clock</span>
                <span class="c1">// is terrible and we should move on.</span>
                <span class="c1">// TBD: How to signal that the measured resolution is probably wrong?</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ticks</span> <span class="o">&gt;</span> <span class="n">startTime</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">nanosecondsInSecond</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">sum</span> <span class="o">/</span> <span class="p">(</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1u</span> <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// We&#39;re just taking the mean, here. To do better we could take the std. dev and exclude outliers</span>
            <span class="c1">// - and potentially do more iterations if there&#39;s a high variance.</span>
            <span class="k">return</span> <span class="n">sum</span><span class="o">/</span><span class="n">iterations</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">getEstimatedClockResolution</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">uint64_t</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">auto</span> <span class="n">s_resolution</span> <span class="o">=</span> <span class="n">estimateClockResolution</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">s_resolution</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Timer</span><span class="o">::</span><span class="n">start</span><span class="p">()</span> <span class="p">{</span>
       <span class="n">m_nanoseconds</span> <span class="o">=</span> <span class="n">getCurrentNanosecondsSinceEpoch</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">Timer</span><span class="o">::</span><span class="n">getElapsedNanoseconds</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">uint64_t</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getCurrentNanosecondsSinceEpoch</span><span class="p">()</span> <span class="o">-</span> <span class="n">m_nanoseconds</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">Timer</span><span class="o">::</span><span class="n">getElapsedMicroseconds</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">uint64_t</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getElapsedNanoseconds</span><span class="p">()</span><span class="o">/</span><span class="mi">1000</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">Timer</span><span class="o">::</span><span class="n">getElapsedMilliseconds</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">getElapsedMicroseconds</span><span class="p">()</span><span class="o">/</span><span class="mi">1000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">Timer</span><span class="o">::</span><span class="n">getElapsedSeconds</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">double</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">getElapsedMicroseconds</span><span class="p">()</span><span class="o">/</span><span class="mf">1000000.0</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Catch</span>
<span class="c1">// end catch_timer.cpp</span>
<span class="c1">// start catch_tostring.cpp</span>

<span class="cp">#if defined(__clang__)</span>
<span class="cp">#    pragma clang diagnostic push</span>
<span class="cp">#    pragma clang diagnostic ignored &quot;-Wexit-time-destructors&quot;</span>
<span class="cp">#    pragma clang diagnostic ignored &quot;-Wglobal-constructors&quot;</span>
<span class="cp">#endif</span>

<span class="c1">// Enable specific decls locally</span>
<span class="cp">#if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)</span>
<span class="cp">#define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER</span>
<span class="cp">#endif</span>

<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

<span class="k">namespace</span> <span class="n">Detail</span> <span class="p">{</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">unprintableString</span> <span class="o">=</span> <span class="s">&quot;{?}&quot;</span><span class="p">;</span>

    <span class="k">namespace</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">hexThreshold</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>

        <span class="k">struct</span> <span class="nc">Endianness</span> <span class="p">{</span>
            <span class="k">enum</span> <span class="nc">Arch</span> <span class="p">{</span> <span class="n">Big</span><span class="p">,</span> <span class="n">Little</span> <span class="p">};</span>

            <span class="k">static</span> <span class="n">Arch</span> <span class="n">which</span><span class="p">()</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="c1">// If the lowest byte we read is non-zero, we can assume</span>
                <span class="c1">// that little endian format is used.</span>
                <span class="k">auto</span> <span class="n">value</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">one</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">value</span> <span class="o">?</span> <span class="nl">Little</span> <span class="p">:</span> <span class="n">Big</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rawMemoryToString</span><span class="p">(</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Reverse order for little endian architectures</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">size</span> <span class="p">),</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">Endianness</span><span class="o">::</span><span class="n">which</span><span class="p">()</span> <span class="o">==</span> <span class="n">Endianness</span><span class="o">::</span><span class="n">Little</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">end</span><span class="mi">-1</span><span class="p">;</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">bytes</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
        <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
        <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;0x&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setfill</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">inc</span> <span class="p">)</span>
             <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bytes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
       <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fpToString</span><span class="p">(</span> <span class="n">T</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">precision</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Catch</span><span class="o">::</span><span class="n">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;nan&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span> <span class="n">precision</span> <span class="p">)</span>
        <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">fixed</span>
        <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">d</span> <span class="o">=</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">find_last_not_of</span><span class="p">(</span> <span class="sc">&#39;0&#39;</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">d</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="mi">-1</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="p">)</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//// ======================================================= ////</span>
<span class="c1">//</span>
<span class="c1">//   Out-of-line defs for full specialization of StringMaker</span>
<span class="c1">//</span>
<span class="c1">//// ======================================================= ////</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">getCurrentContext</span><span class="p">().</span><span class="n">getConfig</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">showInvisibles</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="sc">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">str</span> <span class="o">+</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="sc">&#39;\n&#39;</span><span class="o">:</span>
            <span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39;\t&#39;</span><span class="o">:</span>
            <span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">t&quot;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CATCH_CONFIG_CPP17_STRING_VIEW</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span> <span class="n">str</span> <span class="p">});</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span><span class="o">*&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span> <span class="n">str</span> <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">{</span> <span class="s">&quot;{null string}&quot;</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span> <span class="n">str</span> <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">{</span> <span class="s">&quot;{null string}&quot;</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CATCH_CONFIG_WCHAR</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&amp;</span> <span class="n">wstr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">wstr</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">wstr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;=</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">?</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="sc">&#39;?&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp"># ifdef CATCH_CONFIG_CPP17_STRING_VIEW</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">wstring_view</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">wstring_view</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp"># endif</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">wchar_t</span> <span class="k">const</span><span class="o">*&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">wchar_t</span> <span class="k">const</span> <span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="p">{</span> <span class="n">str</span> <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">{</span> <span class="s">&quot;{null string}&quot;</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">wchar_t</span> <span class="o">*&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">wstring</span><span class="p">{</span> <span class="n">str</span> <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">{</span> <span class="s">&quot;{null string}&quot;</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CATCH_CONFIG_CPP17_BYTE)</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp"></span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">to_integer</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// defined(CATCH_CONFIG_CPP17_BYTE)</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">long</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">Detail</span><span class="o">::</span><span class="n">hexThreshold</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; (0x&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">Detail</span><span class="o">::</span><span class="n">hexThreshold</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; (0x&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">?</span> <span class="s">&quot;true&quot;</span> <span class="o">:</span> <span class="s">&quot;false&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">signed</span> <span class="kt">char</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">char</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;&#39;</span><span class="se">\\</span><span class="s">r&#39;&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="sc">&#39;\f&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;&#39;</span><span class="se">\\</span><span class="s">f&#39;&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;&#39;</span><span class="se">\\</span><span class="s">n&#39;&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;&#39;</span><span class="se">\\</span><span class="s">t&#39;&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="sc">&#39;\0&#39;</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">chstr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;&#39; &#39;&quot;</span><span class="p">;</span>
        <span class="n">chstr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">chstr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">signed</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">::</span><span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">stringify</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nullptr_t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;nullptr&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">precision</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">float</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">fpToString</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span> <span class="o">+</span> <span class="sc">&#39;f&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">precision</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">StringMaker</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">convert</span><span class="p">(</span><span class="kt">double</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">fpToString</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">precision</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">atto</span><span class="o">&gt;::</span><span class="n">symbol</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;a&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">femto</span><span class="o">&gt;::</span><span class="n">symbol</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;f&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pico</span><span class="o">&gt;::</span><span class="n">symbol</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;p&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">nano</span><span class="o">&gt;::</span><span class="n">symbol</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;n&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">micro</span><span class="o">&gt;::</span><span class="n">symbol</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;u&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ratio_string</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;::</span><span class="n">symbol</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;m&quot;</span><span class="p">;</span> <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#if defined(__clang__)</span>
<span class="cp">#    pragma clang diagnostic pop</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_tostring.cpp</span>
<span class="c1">// start catch_totals.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">Counts</span> <span class="n">Counts</span><span class="o">::</span><span class="k">operator</span> <span class="o">-</span> <span class="p">(</span> <span class="n">Counts</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">Counts</span> <span class="n">diff</span><span class="p">;</span>
        <span class="n">diff</span><span class="p">.</span><span class="n">passed</span> <span class="o">=</span> <span class="n">passed</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">passed</span><span class="p">;</span>
        <span class="n">diff</span><span class="p">.</span><span class="n">failed</span> <span class="o">=</span> <span class="n">failed</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">failed</span><span class="p">;</span>
        <span class="n">diff</span><span class="p">.</span><span class="n">failedButOk</span> <span class="o">=</span> <span class="n">failedButOk</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">failedButOk</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">diff</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Counts</span><span class="o">&amp;</span> <span class="n">Counts</span><span class="o">::</span><span class="k">operator</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">Counts</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">passed</span> <span class="o">+=</span> <span class="n">other</span><span class="p">.</span><span class="n">passed</span><span class="p">;</span>
        <span class="n">failed</span> <span class="o">+=</span> <span class="n">other</span><span class="p">.</span><span class="n">failed</span><span class="p">;</span>
        <span class="n">failedButOk</span> <span class="o">+=</span> <span class="n">other</span><span class="p">.</span><span class="n">failedButOk</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">Counts</span><span class="o">::</span><span class="n">total</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">passed</span> <span class="o">+</span> <span class="n">failed</span> <span class="o">+</span> <span class="n">failedButOk</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Counts</span><span class="o">::</span><span class="n">allPassed</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">failed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">failedButOk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">Counts</span><span class="o">::</span><span class="n">allOk</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">failed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Totals</span> <span class="n">Totals</span><span class="o">::</span><span class="k">operator</span> <span class="o">-</span> <span class="p">(</span> <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">Totals</span> <span class="n">diff</span><span class="p">;</span>
        <span class="n">diff</span><span class="p">.</span><span class="n">assertions</span> <span class="o">=</span> <span class="n">assertions</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">assertions</span><span class="p">;</span>
        <span class="n">diff</span><span class="p">.</span><span class="n">testCases</span> <span class="o">=</span> <span class="n">testCases</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">testCases</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">diff</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Totals</span><span class="o">&amp;</span> <span class="n">Totals</span><span class="o">::</span><span class="k">operator</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">assertions</span> <span class="o">+=</span> <span class="n">other</span><span class="p">.</span><span class="n">assertions</span><span class="p">;</span>
        <span class="n">testCases</span> <span class="o">+=</span> <span class="n">other</span><span class="p">.</span><span class="n">testCases</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Totals</span> <span class="n">Totals</span><span class="o">::</span><span class="n">delta</span><span class="p">(</span> <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">prevTotals</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">Totals</span> <span class="n">diff</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span> <span class="o">-</span> <span class="n">prevTotals</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">diff</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="o">++</span><span class="n">diff</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span><span class="p">;</span>
        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">diff</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failedButOk</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="o">++</span><span class="n">diff</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failedButOk</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="o">++</span><span class="n">diff</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">passed</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">diff</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="c1">// end catch_totals.cpp</span>
<span class="c1">// start catch_uncaught_exceptions.cpp</span>

<span class="c1">// start catch_config_uncaught_exceptions.hpp</span>

<span class="c1">//              Copyright Catch2 Authors</span>
<span class="c1">// Distributed under the Boost Software License, Version 1.0.</span>
<span class="c1">//   (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="c1">//        https://www.boost.org/LICENSE_1_0.txt)</span>

<span class="c1">// SPDX-License-Identifier: BSL-1.0</span>

<span class="cp">#ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP</span>
<span class="cp">#define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#  if _MSC_VER &gt;= 1900 </span><span class="c1">// Visual Studio 2015 or newer</span>
<span class="cp">#    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS</span>
<span class="cp">#  endif</span>
<span class="cp">#endif</span>

<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp"></span>

<span class="cp">#if defined(__cpp_lib_uncaught_exceptions) \</span>
<span class="cp">    &amp;&amp; !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)</span>

<span class="cp">#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS</span>
<span class="cp">#endif </span><span class="c1">// __cpp_lib_uncaught_exceptions</span>

<span class="cp">#if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \</span>
<span class="cp">    &amp;&amp; !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \</span>
<span class="cp">    &amp;&amp; !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)</span>

<span class="cp">#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP</span>
<span class="c1">// end catch_config_uncaught_exceptions.hpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">uncaught_exceptions</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="cp">#elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">uncaught_exceptions</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#else</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">uncaught_exception</span><span class="p">();</span>
<span class="cp">#endif</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_uncaught_exceptions.cpp</span>
<span class="c1">// start catch_version.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;ostream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">Version</span><span class="o">::</span><span class="n">Version</span>
        <span class="p">(</span>   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_majorVersion</span><span class="p">,</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_minorVersion</span><span class="p">,</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_patchNumber</span><span class="p">,</span>
            <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">_branchName</span><span class="p">,</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_buildNumber</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">majorVersion</span><span class="p">(</span> <span class="n">_majorVersion</span> <span class="p">),</span>
        <span class="n">minorVersion</span><span class="p">(</span> <span class="n">_minorVersion</span> <span class="p">),</span>
        <span class="n">patchNumber</span><span class="p">(</span> <span class="n">_patchNumber</span> <span class="p">),</span>
        <span class="n">branchName</span><span class="p">(</span> <span class="n">_branchName</span> <span class="p">),</span>
        <span class="n">buildNumber</span><span class="p">(</span> <span class="n">_buildNumber</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">Version</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">version</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">os</span>  <span class="o">&lt;&lt;</span> <span class="n">version</span><span class="p">.</span><span class="n">majorVersion</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;.&#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">version</span><span class="p">.</span><span class="n">minorVersion</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;.&#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">version</span><span class="p">.</span><span class="n">patchNumber</span><span class="p">;</span>
        <span class="c1">// branchName is never null -&gt; 0th char is \0 if it is empty</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">version</span><span class="p">.</span><span class="n">branchName</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;-&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">version</span><span class="p">.</span><span class="n">branchName</span>
               <span class="o">&lt;&lt;</span> <span class="sc">&#39;.&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">version</span><span class="p">.</span><span class="n">buildNumber</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Version</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">libraryVersion</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">Version</span> <span class="n">version</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">version</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="c1">// end catch_version.cpp</span>
<span class="c1">// start catch_wildcard_pattern.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">WildcardPattern</span><span class="o">::</span><span class="n">WildcardPattern</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pattern</span><span class="p">,</span>
                                      <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">Choice</span> <span class="n">caseSensitivity</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_caseSensitivity</span><span class="p">(</span> <span class="n">caseSensitivity</span> <span class="p">),</span>
        <span class="n">m_pattern</span><span class="p">(</span> <span class="n">normaliseString</span><span class="p">(</span> <span class="n">pattern</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">startsWith</span><span class="p">(</span> <span class="n">m_pattern</span><span class="p">,</span> <span class="sc">&#39;*&#39;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_pattern</span> <span class="o">=</span> <span class="n">m_pattern</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
            <span class="n">m_wildcard</span> <span class="o">=</span> <span class="n">WildcardAtStart</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">endsWith</span><span class="p">(</span> <span class="n">m_pattern</span><span class="p">,</span> <span class="sc">&#39;*&#39;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_pattern</span> <span class="o">=</span> <span class="n">m_pattern</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m_pattern</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="mi">-1</span> <span class="p">);</span>
            <span class="n">m_wildcard</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">WildcardPosition</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">m_wildcard</span> <span class="o">|</span> <span class="n">WildcardAtEnd</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">WildcardPattern</span><span class="o">::</span><span class="n">matches</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span> <span class="n">m_wildcard</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nl">NoWildcard</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">m_pattern</span> <span class="o">==</span> <span class="n">normaliseString</span><span class="p">(</span> <span class="n">str</span> <span class="p">);</span>
            <span class="k">case</span> <span class="nl">WildcardAtStart</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">endsWith</span><span class="p">(</span> <span class="n">normaliseString</span><span class="p">(</span> <span class="n">str</span> <span class="p">),</span> <span class="n">m_pattern</span> <span class="p">);</span>
            <span class="k">case</span> <span class="nl">WildcardAtEnd</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">startsWith</span><span class="p">(</span> <span class="n">normaliseString</span><span class="p">(</span> <span class="n">str</span> <span class="p">),</span> <span class="n">m_pattern</span> <span class="p">);</span>
            <span class="k">case</span> <span class="nl">WildcardAtBothEnds</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">contains</span><span class="p">(</span> <span class="n">normaliseString</span><span class="p">(</span> <span class="n">str</span> <span class="p">),</span> <span class="n">m_pattern</span> <span class="p">);</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span> <span class="s">&quot;Unknown enum&quot;</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">WildcardPattern</span><span class="o">::</span><span class="n">normaliseString</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">trim</span><span class="p">(</span> <span class="n">m_caseSensitivity</span> <span class="o">==</span> <span class="n">CaseSensitive</span><span class="o">::</span><span class="n">No</span> <span class="o">?</span> <span class="n">toLower</span><span class="p">(</span> <span class="n">str</span> <span class="p">)</span> <span class="o">:</span> <span class="n">str</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// end catch_wildcard_pattern.cpp</span>
<span class="c1">// start catch_xmlwriter.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

<span class="k">namespace</span> <span class="p">{</span>

    <span class="kt">size_t</span> <span class="nf">trailingBytes</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0xF8</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span><span class="s">&quot;Invalid multibyte utf-8 start byte encountered&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">uint32_t</span> <span class="nf">headerValue</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0xF8</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">CATCH_INTERNAL_ERROR</span><span class="p">(</span><span class="s">&quot;Invalid multibyte utf-8 start byte encountered&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">hexEscapeChar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ios_base</span><span class="o">::</span><span class="n">fmtflags</span> <span class="n">f</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">flags</span><span class="p">());</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">x&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">uppercase</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setfill</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="n">os</span><span class="p">.</span><span class="n">flags</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">shouldNewline</span><span class="p">(</span><span class="n">XmlFormatting</span> <span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">XmlFormatting</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fmt</span> <span class="o">&amp;</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">shouldIndent</span><span class="p">(</span><span class="n">XmlFormatting</span> <span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">XmlFormatting</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fmt</span> <span class="o">&amp;</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Indent</span><span class="p">));</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// anonymous namespace</span>

    <span class="n">XmlFormatting</span> <span class="k">operator</span> <span class="o">|</span> <span class="p">(</span><span class="n">XmlFormatting</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">XmlFormatting</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">XmlFormatting</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">|</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">XmlFormatting</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">XmlFormatting</span> <span class="k">operator</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XmlFormatting</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">XmlFormatting</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">XmlFormatting</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">&amp;</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">XmlFormatting</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">XmlEncode</span><span class="o">::</span><span class="n">XmlEncode</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">ForWhat</span> <span class="n">forWhat</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_str</span><span class="p">(</span> <span class="n">str</span> <span class="p">),</span>
        <span class="n">m_forWhat</span><span class="p">(</span> <span class="n">forWhat</span> <span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">XmlEncode</span><span class="o">::</span><span class="n">encodeTo</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// Apostrophe escaping not necessary if we always use &quot; to write attributes</span>
        <span class="c1">// (see: http://www.w3.org/TR/xml/#syntax)</span>

        <span class="k">for</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">m_str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span> <span class="n">idx</span> <span class="p">)</span> <span class="p">{</span>
            <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">m_str</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="sc">&#39;&lt;&#39;</span><span class="o">:</span>   <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&amp;lt;&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="sc">&#39;&amp;&#39;</span><span class="o">:</span>   <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&amp;amp;&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="sc">&#39;&gt;&#39;</span><span class="o">:</span>
                <span class="c1">// See: http://www.w3.org/TR/xml/#syntax</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">m_str</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;]&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">m_str</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;]&#39;</span><span class="p">)</span>
                    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&amp;gt;&quot;</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="sc">&#39;\&quot;&#39;</span><span class="o">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m_forWhat</span> <span class="o">==</span> <span class="n">ForAttributes</span><span class="p">)</span>
                    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&amp;quot;&quot;</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">default</span><span class="o">:</span>
                <span class="c1">// Check for control characters and invalid utf-8</span>

                <span class="c1">// Escape control characters in standard ascii</span>
                <span class="c1">// see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mh">0x09</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mh">0x0D</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="mh">0x7F</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">hexEscapeChar</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">// Plain ASCII: Write it to stream</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mh">0x7F</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">// UTF-8 territory</span>
                <span class="c1">// Check if the encoding is valid and if it is not, hex escape bytes.</span>
                <span class="c1">// Important: We do not check the exact decoded values for validity, only the encoding format</span>
                <span class="c1">// First check that this bytes is a valid lead byte:</span>
                <span class="c1">// This means that it is not encoded as 1111 1XXX</span>
                <span class="c1">// Or as 10XX XXXX</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span>  <span class="mh">0xC0</span> <span class="o">||</span>
                    <span class="n">c</span> <span class="o">&gt;=</span> <span class="mh">0xF8</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">hexEscapeChar</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">auto</span> <span class="n">encBytes</span> <span class="o">=</span> <span class="n">trailingBytes</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="c1">// Are there enough bytes left to avoid accessing out-of-bounds memory?</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">encBytes</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">m_str</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">hexEscapeChar</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// The header is valid, check data</span>
                <span class="c1">// The next encBytes bytes must together be a valid utf-8</span>
                <span class="c1">// This means: bitpattern 10XX XXXX and the extracted value is sane (ish)</span>
                <span class="kt">bool</span> <span class="n">valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="kt">uint32_t</span> <span class="n">value</span> <span class="o">=</span> <span class="n">headerValue</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">encBytes</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">m_str</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="n">n</span><span class="p">];</span>
                    <span class="n">valid</span> <span class="o">&amp;=</span> <span class="p">((</span><span class="n">nc</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80</span><span class="p">);</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">nc</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="c1">// Wrong bit pattern of following bytes</span>
                    <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">)</span> <span class="o">||</span>
                    <span class="c1">// Overlong encodings</span>
                    <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="o">||</span>
                    <span class="p">(</span><span class="mh">0x80</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mh">0x800</span>   <span class="o">&amp;&amp;</span> <span class="n">encBytes</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span>
                    <span class="p">(</span><span class="mh">0x800</span> <span class="o">&lt;</span> <span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mh">0x10000</span> <span class="o">&amp;&amp;</span> <span class="n">encBytes</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span>
                    <span class="c1">// Encoded value out of range</span>
                    <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mh">0x110000</span><span class="p">)</span>
                    <span class="p">)</span> <span class="p">{</span>
                    <span class="n">hexEscapeChar</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">// If we got here, this is in fact a valid(ish) utf-8 sequence</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">encBytes</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">m_str</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="n">n</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="n">encBytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">XmlEncode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">xmlEncode</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">xmlEncode</span><span class="p">.</span><span class="n">encodeTo</span><span class="p">(</span> <span class="n">os</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span><span class="o">::</span><span class="n">ScopedElement</span><span class="p">(</span> <span class="n">XmlWriter</span><span class="o">*</span> <span class="n">writer</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_writer</span><span class="p">(</span> <span class="n">writer</span> <span class="p">),</span>
        <span class="n">m_fmt</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span><span class="o">::</span><span class="n">ScopedElement</span><span class="p">(</span> <span class="n">ScopedElement</span><span class="o">&amp;&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">noexcept</span>
    <span class="o">:</span>   <span class="n">m_writer</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">m_writer</span> <span class="p">),</span>
        <span class="n">m_fmt</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_fmt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">other</span><span class="p">.</span><span class="n">m_writer</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">m_fmt</span> <span class="o">=</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">None</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span><span class="o">&amp;</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">ScopedElement</span><span class="o">&amp;&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">m_writer</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_writer</span><span class="o">-&gt;</span><span class="n">endElement</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">m_writer</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_writer</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">m_writer</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">m_fmt</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_fmt</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">m_fmt</span> <span class="o">=</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">None</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span><span class="o">::~</span><span class="n">ScopedElement</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_writer</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_writer</span><span class="o">-&gt;</span><span class="n">endElement</span><span class="p">(</span><span class="n">m_fmt</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span><span class="o">&amp;</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span><span class="o">::</span><span class="n">writeText</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_writer</span><span class="o">-&gt;</span><span class="n">writeText</span><span class="p">(</span> <span class="n">text</span><span class="p">,</span> <span class="n">fmt</span> <span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">::</span><span class="n">XmlWriter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span> <span class="p">)</span> <span class="o">:</span> <span class="n">m_os</span><span class="p">(</span> <span class="n">os</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">writeDeclaration</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">::~</span><span class="n">XmlWriter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">m_tags</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">endElement</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">newlineIfNecessary</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">startElement</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ensureTagClosed</span><span class="p">();</span>
        <span class="n">newlineIfNecessary</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shouldIndent</span><span class="p">(</span><span class="n">fmt</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">m_indent</span><span class="p">;</span>
            <span class="n">m_indent</span> <span class="o">+=</span> <span class="s">&quot;  &quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;&lt;&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">m_tags</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">name</span> <span class="p">);</span>
        <span class="n">m_tagIsOpen</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">applyFormatting</span><span class="p">(</span><span class="n">fmt</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">scopedElement</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ScopedElement</span> <span class="nf">scoped</span><span class="p">(</span> <span class="k">this</span><span class="p">,</span> <span class="n">fmt</span> <span class="p">);</span>
        <span class="n">startElement</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span> <span class="n">fmt</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">scoped</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">endElement</span><span class="p">(</span><span class="n">XmlFormatting</span> <span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_indent</span> <span class="o">=</span> <span class="n">m_indent</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m_indent</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">m_tagIsOpen</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/&gt;&quot;</span><span class="p">;</span>
            <span class="n">m_tagIsOpen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">newlineIfNecessary</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">shouldIndent</span><span class="p">(</span><span class="n">fmt</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">m_indent</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;/&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_tags</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
        <span class="n">applyFormatting</span><span class="p">(</span><span class="n">fmt</span><span class="p">);</span>
        <span class="n">m_tags</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">attribute</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">name</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">attribute</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;=</span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">XmlEncode</span><span class="p">(</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">XmlEncode</span><span class="o">::</span><span class="n">ForAttributes</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">attribute</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;=</span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">attribute</span> <span class="o">?</span> <span class="s">&quot;true&quot;</span> <span class="o">:</span> <span class="s">&quot;false&quot;</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;&quot;&#39;</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">writeText</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">text</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">){</span>
            <span class="kt">bool</span> <span class="n">tagWasOpen</span> <span class="o">=</span> <span class="n">m_tagIsOpen</span><span class="p">;</span>
            <span class="n">ensureTagClosed</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tagWasOpen</span> <span class="o">&amp;&amp;</span> <span class="n">shouldIndent</span><span class="p">(</span><span class="n">fmt</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">m_indent</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">XmlEncode</span><span class="p">(</span> <span class="n">text</span> <span class="p">);</span>
            <span class="n">applyFormatting</span><span class="p">(</span><span class="n">fmt</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">writeComment</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">,</span> <span class="n">XmlFormatting</span> <span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ensureTagClosed</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shouldIndent</span><span class="p">(</span><span class="n">fmt</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">m_indent</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;!--&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">text</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;--&gt;&quot;</span><span class="p">;</span>
        <span class="n">applyFormatting</span><span class="p">(</span><span class="n">fmt</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">writeStylesheetRef</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">url</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;?xml-stylesheet type=</span><span class="se">\&quot;</span><span class="s">text/xsl</span><span class="se">\&quot;</span><span class="s"> href=</span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">url</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">?&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlWriter</span><span class="o">&amp;</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">writeBlankLine</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">ensureTagClosed</span><span class="p">();</span>
        <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ensureTagClosed</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_tagIsOpen</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;&gt;&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
            <span class="n">newlineIfNecessary</span><span class="p">();</span>
            <span class="n">m_tagIsOpen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">applyFormatting</span><span class="p">(</span><span class="n">XmlFormatting</span> <span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_needsNewline</span> <span class="o">=</span> <span class="n">shouldNewline</span><span class="p">(</span><span class="n">fmt</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">writeDeclaration</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;?xml version=</span><span class="se">\&quot;</span><span class="s">1.0</span><span class="se">\&quot;</span><span class="s"> encoding=</span><span class="se">\&quot;</span><span class="s">UTF-8</span><span class="se">\&quot;</span><span class="s">?&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlWriter</span><span class="o">::</span><span class="n">newlineIfNecessary</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_needsNewline</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="n">m_needsNewline</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// end catch_xmlwriter.cpp</span>
<span class="c1">// start catch_reporter_bases.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cfloat&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">prepareExpandedExpression</span><span class="p">(</span><span class="n">AssertionResult</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">getExpandedExpression</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Because formatting using c++ streams is stateful, drop down to C is required</span>
    <span class="c1">// Alternatively we could use stringstream, but its performance is... not good.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getFormattedDuration</span><span class="p">(</span> <span class="kt">double</span> <span class="n">duration</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Max exponent + 1 is required to represent the whole part</span>
        <span class="c1">// + 1 for decimal point</span>
        <span class="c1">// + 3 for the 3 decimal places</span>
        <span class="c1">// + 1 for null terminator</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">maxDoubleSize</span> <span class="o">=</span> <span class="n">DBL_MAX_10_EXP</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">maxDoubleSize</span><span class="p">];</span>

        <span class="c1">// Save previous errno, to prevent sprintf from overwriting it</span>
        <span class="n">ErrnoGuard</span> <span class="n">guard</span><span class="p">;</span>
<span class="cp">#ifdef _MSC_VER</span>
        <span class="n">sprintf_s</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%.3f&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">);</span>
<span class="cp">#else</span>
        <span class="n">std</span><span class="o">::</span><span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%.3f&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">);</span>
<span class="cp">#endif</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">shouldShowDuration</span><span class="p">(</span> <span class="n">IConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">,</span> <span class="kt">double</span> <span class="n">duration</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">showDurations</span><span class="p">()</span> <span class="o">==</span> <span class="n">ShowDurations</span><span class="o">::</span><span class="n">Always</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">showDurations</span><span class="p">()</span> <span class="o">==</span> <span class="n">ShowDurations</span><span class="o">::</span><span class="n">Never</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="n">min</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">minDuration</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">min</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">duration</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">serializeFilters</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">container</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ReusableStringStream</span> <span class="n">oss</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">filter</span> <span class="p">:</span> <span class="n">container</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
                <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

            <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">filter</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">TestEventListenerBase</span><span class="o">::</span><span class="n">TestEventListenerBase</span><span class="p">(</span><span class="n">ReporterConfig</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">_config</span><span class="p">)</span>
        <span class="o">:</span><span class="n">StreamingReporterBase</span><span class="p">(</span><span class="n">_config</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Verbosity</span><span class="o">&gt;</span> <span class="n">TestEventListenerBase</span><span class="o">::</span><span class="n">getSupportedVerbosities</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">Quiet</span><span class="p">,</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">Normal</span><span class="p">,</span> <span class="n">Verbosity</span><span class="o">::</span><span class="n">High</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">TestEventListenerBase</span><span class="o">::</span><span class="n">assertionStarting</span><span class="p">(</span><span class="n">AssertionInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">TestEventListenerBase</span><span class="o">::</span><span class="n">assertionEnded</span><span class="p">(</span><span class="n">AssertionStats</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_reporter_bases.cpp</span>
<span class="c1">// start catch_reporter_compact.cpp</span>

<span class="k">namespace</span> <span class="p">{</span>

<span class="cp">#ifdef CATCH_PLATFORM_MAC</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">failedString</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;FAILED&quot;</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">passedString</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;PASSED&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#else</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">failedString</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;failed&quot;</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">passedString</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;passed&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

    <span class="c1">// Colour::LightGrey</span>
    <span class="n">Catch</span><span class="o">::</span><span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="n">dimColour</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Colour</span><span class="o">::</span><span class="n">FileName</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">bothOrAll</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">()</span> <span class="o">:</span>
               <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="s">&quot;both &quot;</span> <span class="o">:</span> <span class="s">&quot;all &quot;</span> <span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// anon namespace</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>
<span class="c1">// Colour, message variants:</span>
<span class="c1">// - white: No tests ran.</span>
<span class="c1">// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.</span>
<span class="c1">// - white: Passed [both/all] N test cases (no assertions).</span>
<span class="c1">// -   red: Failed N tests cases, failed M assertions.</span>
<span class="c1">// - green: Passed [both/all] N tests cases with M assertions.</span>
<span class="kt">void</span> <span class="nf">printTotals</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Totals</span><span class="o">&amp;</span> <span class="n">totals</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">total</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No tests ran.&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span> <span class="o">==</span> <span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">total</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">Colour</span> <span class="n">colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">ResultError</span><span class="p">);</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">qualify_assertions_failed</span> <span class="o">=</span>
            <span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span> <span class="o">==</span> <span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">total</span><span class="p">()</span> <span class="o">?</span>
            <span class="n">bothOrAll</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="p">)</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">();</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span>
            <span class="s">&quot;Failed &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bothOrAll</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span><span class="p">,</span> <span class="s">&quot;test case&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span>
            <span class="s">&quot;failed &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">qualify_assertions_failed</span> <span class="o">&lt;&lt;</span>
            <span class="n">pluralise</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="p">,</span> <span class="s">&quot;assertion&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">total</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span>
            <span class="s">&quot;Passed &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bothOrAll</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">total</span><span class="p">())</span>
            <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">total</span><span class="p">(),</span> <span class="s">&quot;test case&quot;</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; (no assertions).&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Colour</span> <span class="n">colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">ResultError</span><span class="p">);</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span>
            <span class="s">&quot;Failed &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span><span class="p">,</span> <span class="s">&quot;test case&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span>
            <span class="s">&quot;failed &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="p">,</span> <span class="s">&quot;assertion&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">Colour</span> <span class="n">colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">ResultSuccess</span><span class="p">);</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span>
            <span class="s">&quot;Passed &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bothOrAll</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">passed</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">passed</span><span class="p">,</span> <span class="s">&quot;test case&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
            <span class="s">&quot; with &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">passed</span><span class="p">,</span> <span class="s">&quot;assertion&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;.&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Implementation of CompactReporter formatting</span>
<span class="k">class</span> <span class="nc">AssertionPrinter</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">AssertionPrinter</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="n">AssertionPrinter</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">AssertionPrinter</span><span class="p">(</span><span class="n">AssertionPrinter</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">AssertionPrinter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">_stream</span><span class="p">,</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_stats</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">_printInfoMessages</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">stream</span><span class="p">(</span><span class="n">_stream</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">result</span><span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">assertionResult</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">messages</span><span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">itMessage</span><span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span>
        <span class="p">,</span> <span class="n">printInfoMessages</span><span class="p">(</span><span class="n">_printInfoMessages</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">printSourceInfo</span><span class="p">();</span>

        <span class="n">itMessage</span> <span class="o">=</span> <span class="n">messages</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">getResultType</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Ok</span><span class="p">:</span>
            <span class="n">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">ResultSuccess</span><span class="p">,</span> <span class="n">passedString</span><span class="p">());</span>
            <span class="n">printOriginalExpression</span><span class="p">();</span>
            <span class="n">printReconstructedExpression</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">hasExpression</span><span class="p">())</span>
                <span class="n">printRemainingMessages</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">None</span><span class="p">);</span>
            <span class="k">else</span>
                <span class="nf">printRemainingMessages</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ExpressionFailed</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">isOk</span><span class="p">())</span>
                <span class="n">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">ResultSuccess</span><span class="p">,</span> <span class="n">failedString</span><span class="p">()</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot; - but was ok&quot;</span><span class="p">));</span>
            <span class="k">else</span>
                <span class="nf">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">,</span> <span class="n">failedString</span><span class="p">());</span>
            <span class="n">printOriginalExpression</span><span class="p">();</span>
            <span class="n">printReconstructedExpression</span><span class="p">();</span>
            <span class="n">printRemainingMessages</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ThrewException</span><span class="p">:</span>
            <span class="n">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">,</span> <span class="n">failedString</span><span class="p">());</span>
            <span class="n">printIssue</span><span class="p">(</span><span class="s">&quot;unexpected exception with message:&quot;</span><span class="p">);</span>
            <span class="n">printMessage</span><span class="p">();</span>
            <span class="n">printExpressionWas</span><span class="p">();</span>
            <span class="n">printRemainingMessages</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">FatalErrorCondition</span><span class="p">:</span>
            <span class="n">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">,</span> <span class="n">failedString</span><span class="p">());</span>
            <span class="n">printIssue</span><span class="p">(</span><span class="s">&quot;fatal error condition with message:&quot;</span><span class="p">);</span>
            <span class="n">printMessage</span><span class="p">();</span>
            <span class="n">printExpressionWas</span><span class="p">();</span>
            <span class="n">printRemainingMessages</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">DidntThrowException</span><span class="p">:</span>
            <span class="n">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">,</span> <span class="n">failedString</span><span class="p">());</span>
            <span class="n">printIssue</span><span class="p">(</span><span class="s">&quot;expected exception, got none&quot;</span><span class="p">);</span>
            <span class="n">printExpressionWas</span><span class="p">();</span>
            <span class="n">printRemainingMessages</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Info</span><span class="p">:</span>
            <span class="n">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">None</span><span class="p">,</span> <span class="s">&quot;info&quot;</span><span class="p">);</span>
            <span class="n">printMessage</span><span class="p">();</span>
            <span class="n">printRemainingMessages</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Warning</span><span class="p">:</span>
            <span class="n">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">None</span><span class="p">,</span> <span class="s">&quot;warning&quot;</span><span class="p">);</span>
            <span class="n">printMessage</span><span class="p">();</span>
            <span class="n">printRemainingMessages</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ExplicitFailure</span><span class="p">:</span>
            <span class="n">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">,</span> <span class="n">failedString</span><span class="p">());</span>
            <span class="n">printIssue</span><span class="p">(</span><span class="s">&quot;explicitly&quot;</span><span class="p">);</span>
            <span class="n">printRemainingMessages</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">None</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
            <span class="c1">// These cases are here to prevent compiler warnings</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Unknown</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">FailureBit</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Exception</span><span class="p">:</span>
            <span class="n">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">,</span> <span class="s">&quot;** internal error **&quot;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">printSourceInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">FileName</span><span class="p">);</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">getSourceInfo</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">printResultType</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="n">colour</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">passOrFail</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passOrFail</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="p">{</span>
                <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">colour</span><span class="p">);</span>
                <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">passOrFail</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">printIssue</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">issue</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">issue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">printExpressionWas</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">hasExpression</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;;&#39;</span><span class="p">;</span>
            <span class="p">{</span>
                <span class="n">Colour</span> <span class="nf">colour</span><span class="p">(</span><span class="n">dimColour</span><span class="p">());</span>
                <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; expression was:&quot;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">printOriginalExpression</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">printOriginalExpression</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">hasExpression</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">getExpression</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">printReconstructedExpression</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">hasExpandedExpression</span><span class="p">())</span> <span class="p">{</span>
            <span class="p">{</span>
                <span class="n">Colour</span> <span class="nf">colour</span><span class="p">(</span><span class="n">dimColour</span><span class="p">());</span>
                <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; for: &quot;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">getExpandedExpression</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">printMessage</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">itMessage</span> <span class="o">!=</span> <span class="n">messages</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">itMessage</span><span class="o">-&gt;</span><span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\&#39;&#39;</span><span class="p">;</span>
            <span class="o">++</span><span class="n">itMessage</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">printRemainingMessages</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="n">colour</span> <span class="o">=</span> <span class="n">dimColour</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">itMessage</span> <span class="o">==</span> <span class="n">messages</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="k">const</span> <span class="k">auto</span> <span class="n">itEnd</span> <span class="o">=</span> <span class="n">messages</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">N</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">itMessage</span><span class="p">,</span> <span class="n">itEnd</span><span class="p">));</span>

        <span class="p">{</span>
            <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">colour</span><span class="p">);</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; with &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">itMessage</span> <span class="o">!=</span> <span class="n">itEnd</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If this assertion is a warning ignore any INFO messages</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">printInfoMessages</span> <span class="o">||</span> <span class="n">itMessage</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Info</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printMessage</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">itMessage</span> <span class="o">!=</span> <span class="n">itEnd</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">dimColour</span><span class="p">());</span>
                    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; and&quot;</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="o">++</span><span class="n">itMessage</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">;</span>
    <span class="n">AssertionResult</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MessageInfo</span><span class="o">&gt;</span> <span class="n">messages</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MessageInfo</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">itMessage</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">printInfoMessages</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// anon namespace</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">CompactReporter</span><span class="o">::</span><span class="n">getDescription</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;Reports test results on a single line, suitable for IDEs&quot;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">CompactReporter</span><span class="o">::</span><span class="n">noMatchingTestCases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">spec</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No test cases matched &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">spec</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">CompactReporter</span><span class="o">::</span><span class="n">assertionStarting</span><span class="p">(</span> <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">{}</span>

        <span class="kt">bool</span> <span class="n">CompactReporter</span><span class="o">::</span><span class="n">assertionEnded</span><span class="p">(</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_assertionStats</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">AssertionResult</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">_assertionStats</span><span class="p">.</span><span class="n">assertionResult</span><span class="p">;</span>

            <span class="kt">bool</span> <span class="n">printInfoMessages</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

            <span class="c1">// Drop out if result was successful and we&#39;re not printing those</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">includeSuccessfulResults</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">.</span><span class="n">isOk</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getResultType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Warning</span> <span class="p">)</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="n">printInfoMessages</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">AssertionPrinter</span> <span class="n">printer</span><span class="p">(</span> <span class="n">stream</span><span class="p">,</span> <span class="n">_assertionStats</span><span class="p">,</span> <span class="n">printInfoMessages</span> <span class="p">);</span>
            <span class="n">printer</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>

            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">CompactReporter</span><span class="o">::</span><span class="n">sectionEnded</span><span class="p">(</span><span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_sectionStats</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">dur</span> <span class="o">=</span> <span class="n">_sectionStats</span><span class="p">.</span><span class="n">durationInSeconds</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">shouldShowDuration</span><span class="p">(</span> <span class="o">*</span><span class="n">m_config</span><span class="p">,</span> <span class="n">dur</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">getFormattedDuration</span><span class="p">(</span> <span class="n">dur</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">_sectionStats</span><span class="p">.</span><span class="n">sectionInfo</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">CompactReporter</span><span class="o">::</span><span class="n">testRunEnded</span><span class="p">(</span> <span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testRunStats</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">printTotals</span><span class="p">(</span> <span class="n">stream</span><span class="p">,</span> <span class="n">_testRunStats</span><span class="p">.</span><span class="n">totals</span> <span class="p">);</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testRunEnded</span><span class="p">(</span> <span class="n">_testRunStats</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">CompactReporter</span><span class="o">::~</span><span class="n">CompactReporter</span><span class="p">()</span> <span class="p">{}</span>

    <span class="n">CATCH_REGISTER_REPORTER</span><span class="p">(</span> <span class="s">&quot;compact&quot;</span><span class="p">,</span> <span class="n">CompactReporter</span> <span class="p">)</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_reporter_compact.cpp</span>
<span class="c1">// start catch_reporter_console.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cfloat&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#pragma warning(push)</span>
<span class="cp">#pragma warning(disable:4061) </span><span class="c1">// Not all labels are EXPLICITLY handled in switch</span>
 <span class="c1">// Note that 4062 (not all labels are handled and default is missing) is enabled</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(__clang__)</span>
<span class="cp">#  pragma clang diagnostic push</span>
<span class="c1">// For simplicity, benchmarking-only helpers are always enabled</span>
<span class="cp">#  pragma clang diagnostic ignored &quot;-Wunused-function&quot;</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

<span class="k">namespace</span> <span class="p">{</span>

<span class="c1">// Formatter impl for ConsoleReporter</span>
<span class="k">class</span> <span class="nc">ConsoleAssertionPrinter</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ConsoleAssertionPrinter</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="n">ConsoleAssertionPrinter</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">ConsoleAssertionPrinter</span><span class="p">(</span><span class="n">ConsoleAssertionPrinter</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">ConsoleAssertionPrinter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">_stream</span><span class="p">,</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_stats</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">_printInfoMessages</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">stream</span><span class="p">(</span><span class="n">_stream</span><span class="p">),</span>
        <span class="n">stats</span><span class="p">(</span><span class="n">_stats</span><span class="p">),</span>
        <span class="n">result</span><span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">assertionResult</span><span class="p">),</span>
        <span class="n">colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">None</span><span class="p">),</span>
        <span class="n">message</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">getMessage</span><span class="p">()),</span>
        <span class="n">messages</span><span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">),</span>
        <span class="n">printInfoMessages</span><span class="p">(</span><span class="n">_printInfoMessages</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">getResultType</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Ok</span><span class="p">:</span>
            <span class="n">colour</span> <span class="o">=</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
            <span class="n">passOrFail</span> <span class="o">=</span> <span class="s">&quot;PASSED&quot;</span><span class="p">;</span>
            <span class="c1">//if( result.hasMessage() )</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;with message&quot;</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;with messages&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ExpressionFailed</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">isOk</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">colour</span> <span class="o">=</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
                <span class="n">passOrFail</span> <span class="o">=</span> <span class="s">&quot;FAILED - but was ok&quot;</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">colour</span> <span class="o">=</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span>
                <span class="n">passOrFail</span> <span class="o">=</span> <span class="s">&quot;FAILED&quot;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;with message&quot;</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;with messages&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ThrewException</span><span class="p">:</span>
            <span class="n">colour</span> <span class="o">=</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span>
            <span class="n">passOrFail</span> <span class="o">=</span> <span class="s">&quot;FAILED&quot;</span><span class="p">;</span>
            <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;due to unexpected exception with &quot;</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">messageLabel</span> <span class="o">+=</span> <span class="s">&quot;message&quot;</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">messageLabel</span> <span class="o">+=</span> <span class="s">&quot;messages&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">FatalErrorCondition</span><span class="p">:</span>
            <span class="n">colour</span> <span class="o">=</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span>
            <span class="n">passOrFail</span> <span class="o">=</span> <span class="s">&quot;FAILED&quot;</span><span class="p">;</span>
            <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;due to a fatal error condition&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">DidntThrowException</span><span class="p">:</span>
            <span class="n">colour</span> <span class="o">=</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span>
            <span class="n">passOrFail</span> <span class="o">=</span> <span class="s">&quot;FAILED&quot;</span><span class="p">;</span>
            <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;because no exception was thrown where one was expected&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Info</span><span class="p">:</span>
            <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;info&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Warning</span><span class="p">:</span>
            <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;warning&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ExplicitFailure</span><span class="p">:</span>
            <span class="n">passOrFail</span> <span class="o">=</span> <span class="s">&quot;FAILED&quot;</span><span class="p">;</span>
            <span class="n">colour</span> <span class="o">=</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;explicitly with message&quot;</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_stats</span><span class="p">.</span><span class="n">infoMessages</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">messageLabel</span> <span class="o">=</span> <span class="s">&quot;explicitly with messages&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
            <span class="c1">// These cases are here to prevent compiler warnings</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Unknown</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">FailureBit</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Exception</span><span class="p">:</span>
            <span class="n">passOrFail</span> <span class="o">=</span> <span class="s">&quot;** internal error **&quot;</span><span class="p">;</span>
            <span class="n">colour</span> <span class="o">=</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">printSourceInfo</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">total</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printResultType</span><span class="p">();</span>
            <span class="n">printOriginalExpression</span><span class="p">();</span>
            <span class="n">printReconstructedExpression</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printMessage</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">printResultType</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">passOrFail</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">colour</span><span class="p">);</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">passOrFail</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">printOriginalExpression</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">hasExpression</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">OriginalExpression</span><span class="p">);</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span><span class="p">;</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">getExpressionInMacro</span><span class="p">();</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">printReconstructedExpression</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">hasExpandedExpression</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;with expansion:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
            <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">ReconstructedExpression</span><span class="p">);</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">getExpandedExpression</span><span class="p">()).</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">printMessage</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">messageLabel</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">messageLabel</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">msg</span> <span class="p">:</span> <span class="n">messages</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If this assertion is a warning ignore any INFO messages</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">printInfoMessages</span> <span class="o">||</span> <span class="n">msg</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Info</span><span class="p">)</span>
                <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">message</span><span class="p">).</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">printSourceInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">FileName</span><span class="p">);</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">getSourceInfo</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">;</span>
    <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stats</span><span class="p">;</span>
    <span class="n">AssertionResult</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="n">colour</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">passOrFail</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">messageLabel</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MessageInfo</span><span class="o">&gt;</span> <span class="n">messages</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">printInfoMessages</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">makeRatio</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">number</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">total</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">ratio</span> <span class="o">=</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span> <span class="o">*</span> <span class="n">number</span> <span class="o">/</span> <span class="nl">total</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ratio</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">ratio</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">findMax</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">j</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">ColumnInfo</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="nc">Justification</span> <span class="p">{</span> <span class="n">Left</span><span class="p">,</span> <span class="n">Right</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">Justification</span> <span class="n">justification</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">ColumnBreak</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nc">RowBreak</span> <span class="p">{};</span>

<span class="k">class</span> <span class="nc">Duration</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">Unit</span> <span class="p">{</span>
        <span class="n">Auto</span><span class="p">,</span>
        <span class="n">Nanoseconds</span><span class="p">,</span>
        <span class="n">Microseconds</span><span class="p">,</span>
        <span class="n">Milliseconds</span><span class="p">,</span>
        <span class="n">Seconds</span><span class="p">,</span>
        <span class="n">Minutes</span>
    <span class="p">};</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">s_nanosecondsInAMicrosecond</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">s_nanosecondsInAMillisecond</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">s_nanosecondsInAMicrosecond</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">s_nanosecondsInASecond</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">s_nanosecondsInAMillisecond</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">s_nanosecondsInAMinute</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">s_nanosecondsInASecond</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">m_inNanoseconds</span><span class="p">;</span>
    <span class="n">Unit</span> <span class="n">m_units</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Duration</span><span class="p">(</span><span class="kt">double</span> <span class="n">inNanoseconds</span><span class="p">,</span> <span class="n">Unit</span> <span class="n">units</span> <span class="o">=</span> <span class="n">Unit</span><span class="o">::</span><span class="n">Auto</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">m_inNanoseconds</span><span class="p">(</span><span class="n">inNanoseconds</span><span class="p">),</span>
        <span class="n">m_units</span><span class="p">(</span><span class="n">units</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_units</span> <span class="o">==</span> <span class="n">Unit</span><span class="o">::</span><span class="n">Auto</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_inNanoseconds</span> <span class="o">&lt;</span> <span class="n">s_nanosecondsInAMicrosecond</span><span class="p">)</span>
                <span class="n">m_units</span> <span class="o">=</span> <span class="n">Unit</span><span class="o">::</span><span class="n">Nanoseconds</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">m_inNanoseconds</span> <span class="o">&lt;</span> <span class="n">s_nanosecondsInAMillisecond</span><span class="p">)</span>
                <span class="n">m_units</span> <span class="o">=</span> <span class="n">Unit</span><span class="o">::</span><span class="n">Microseconds</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">m_inNanoseconds</span> <span class="o">&lt;</span> <span class="n">s_nanosecondsInASecond</span><span class="p">)</span>
                <span class="n">m_units</span> <span class="o">=</span> <span class="n">Unit</span><span class="o">::</span><span class="n">Milliseconds</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">m_inNanoseconds</span> <span class="o">&lt;</span> <span class="n">s_nanosecondsInAMinute</span><span class="p">)</span>
                <span class="n">m_units</span> <span class="o">=</span> <span class="n">Unit</span><span class="o">::</span><span class="n">Seconds</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">m_units</span> <span class="o">=</span> <span class="n">Unit</span><span class="o">::</span><span class="n">Minutes</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">double</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">m_units</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">Unit</span><span class="o">::</span><span class="nl">Microseconds</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m_inNanoseconds</span> <span class="o">/</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s_nanosecondsInAMicrosecond</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">Unit</span><span class="o">::</span><span class="nl">Milliseconds</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m_inNanoseconds</span> <span class="o">/</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s_nanosecondsInAMillisecond</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">Unit</span><span class="o">::</span><span class="nl">Seconds</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m_inNanoseconds</span> <span class="o">/</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s_nanosecondsInASecond</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">Unit</span><span class="o">::</span><span class="nl">Minutes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m_inNanoseconds</span> <span class="o">/</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s_nanosecondsInAMinute</span><span class="p">);</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="n">m_inNanoseconds</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">unitsAsString</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">m_units</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">Unit</span><span class="o">::</span><span class="nl">Nanoseconds</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;ns&quot;</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">Unit</span><span class="o">::</span><span class="nl">Microseconds</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;us&quot;</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">Unit</span><span class="o">::</span><span class="nl">Milliseconds</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;ms&quot;</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">Unit</span><span class="o">::</span><span class="nl">Seconds</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;s&quot;</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">Unit</span><span class="o">::</span><span class="nl">Minutes</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;m&quot;</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="s">&quot;** internal error **&quot;</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>
    <span class="k">friend</span> <span class="k">auto</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">Duration</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">duration</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span><span class="p">.</span><span class="n">unitsAsString</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// end anon namespace</span>

<span class="k">class</span> <span class="nc">TablePrinter</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">m_os</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ColumnInfo</span><span class="o">&gt;</span> <span class="n">m_columnInfos</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">m_oss</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_currentColumn</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">m_isOpen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">TablePrinter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ColumnInfo</span><span class="o">&gt;</span> <span class="n">columnInfos</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">m_os</span><span class="p">(</span> <span class="n">os</span> <span class="p">),</span>
        <span class="n">m_columnInfos</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">columnInfos</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="k">auto</span> <span class="n">columnInfos</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ColumnInfo</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_columnInfos</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">open</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_isOpen</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_isOpen</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="o">*</span><span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="n">RowBreak</span><span class="p">();</span>

			<span class="n">Columns</span> <span class="n">headerCols</span><span class="p">;</span>
			<span class="n">Spacer</span> <span class="nf">spacer</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">info</span> <span class="p">:</span> <span class="n">m_columnInfos</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">headerCols</span> <span class="o">+=</span> <span class="n">Column</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">name</span><span class="p">).</span><span class="n">width</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
				<span class="n">headerCols</span> <span class="o">+=</span> <span class="n">spacer</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">headerCols</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

            <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">Catch</span><span class="o">::</span><span class="n">getLineOfChars</span><span class="o">&lt;</span><span class="sc">&#39;-&#39;</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">close</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_isOpen</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="k">this</span> <span class="o">&lt;&lt;</span> <span class="n">RowBreak</span><span class="p">();</span>
            <span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="n">m_isOpen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">friend</span> <span class="n">TablePrinter</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">TablePrinter</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tp</span><span class="p">.</span><span class="n">m_oss</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">tp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">friend</span> <span class="n">TablePrinter</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">TablePrinter</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">,</span> <span class="n">ColumnBreak</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">colStr</span> <span class="o">=</span> <span class="n">tp</span><span class="p">.</span><span class="n">m_oss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">strSize</span> <span class="o">=</span> <span class="n">colStr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">tp</span><span class="p">.</span><span class="n">m_oss</span><span class="p">.</span><span class="n">str</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
        <span class="n">tp</span><span class="p">.</span><span class="n">open</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="p">.</span><span class="n">m_currentColumn</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tp</span><span class="p">.</span><span class="n">m_columnInfos</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">tp</span><span class="p">.</span><span class="n">m_currentColumn</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
            <span class="n">tp</span><span class="p">.</span><span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">tp</span><span class="p">.</span><span class="n">m_currentColumn</span><span class="o">++</span><span class="p">;</span>

        <span class="k">auto</span> <span class="n">colInfo</span> <span class="o">=</span> <span class="n">tp</span><span class="p">.</span><span class="n">m_columnInfos</span><span class="p">[</span><span class="n">tp</span><span class="p">.</span><span class="n">m_currentColumn</span><span class="p">];</span>
        <span class="k">auto</span> <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">strSize</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">colInfo</span><span class="p">.</span><span class="n">width</span><span class="p">))</span>
            <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">colInfo</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="p">(</span><span class="n">strSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">colInfo</span><span class="p">.</span><span class="n">justification</span> <span class="o">==</span> <span class="n">ColumnInfo</span><span class="o">::</span><span class="n">Left</span><span class="p">)</span>
            <span class="n">tp</span><span class="p">.</span><span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">colStr</span> <span class="o">&lt;&lt;</span> <span class="n">padding</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">tp</span><span class="p">.</span><span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="n">padding</span> <span class="o">&lt;&lt;</span> <span class="n">colStr</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">tp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">friend</span> <span class="n">TablePrinter</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">TablePrinter</span><span class="o">&amp;</span> <span class="n">tp</span><span class="p">,</span> <span class="n">RowBreak</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="p">.</span><span class="n">m_currentColumn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tp</span><span class="p">.</span><span class="n">m_os</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
            <span class="n">tp</span><span class="p">.</span><span class="n">m_currentColumn</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">tp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">ConsoleReporter</span><span class="p">(</span><span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">StreamingReporterBase</span><span class="p">(</span><span class="n">config</span><span class="p">),</span>
    <span class="n">m_tablePrinter</span><span class="p">(</span><span class="k">new</span> <span class="n">TablePrinter</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">stream</span><span class="p">(),</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="n">config</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ColumnInfo</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">fullConfig</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">benchmarkNoAnalysis</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span><span class="p">{</span>
                <span class="p">{</span> <span class="s">&quot;benchmark name&quot;</span><span class="p">,</span> <span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span> <span class="o">-</span> <span class="mi">43</span><span class="p">,</span> <span class="n">ColumnInfo</span><span class="o">::</span><span class="n">Left</span> <span class="p">},</span>
                <span class="p">{</span> <span class="s">&quot;     samples&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="n">ColumnInfo</span><span class="o">::</span><span class="n">Right</span> <span class="p">},</span>
                <span class="p">{</span> <span class="s">&quot;  iterations&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="n">ColumnInfo</span><span class="o">::</span><span class="n">Right</span> <span class="p">},</span>
                <span class="p">{</span> <span class="s">&quot;        mean&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="n">ColumnInfo</span><span class="o">::</span><span class="n">Right</span> <span class="p">}</span>
            <span class="p">};</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">return</span><span class="p">{</span>
                <span class="p">{</span> <span class="s">&quot;benchmark name&quot;</span><span class="p">,</span> <span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span> <span class="o">-</span> <span class="mi">43</span><span class="p">,</span> <span class="n">ColumnInfo</span><span class="o">::</span><span class="n">Left</span> <span class="p">},</span>
                <span class="p">{</span> <span class="s">&quot;samples      mean       std dev&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="n">ColumnInfo</span><span class="o">::</span><span class="n">Right</span> <span class="p">},</span>
                <span class="p">{</span> <span class="s">&quot;iterations   low mean   low std dev&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="n">ColumnInfo</span><span class="o">::</span><span class="n">Right</span> <span class="p">},</span>
                <span class="p">{</span> <span class="s">&quot;estimated    high mean  high std dev&quot;</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="n">ColumnInfo</span><span class="o">::</span><span class="n">Right</span> <span class="p">}</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">}()))</span> <span class="p">{}</span>
<span class="n">ConsoleReporter</span><span class="o">::~</span><span class="n">ConsoleReporter</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">getDescription</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Reports test results as plain lines of text&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">noMatchingTestCases</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">spec</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No test cases matched &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">spec</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">reportInvalidArguments</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">){</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Invalid Filter: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">assertionStarting</span><span class="p">(</span><span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">bool</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">assertionEnded</span><span class="p">(</span><span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_assertionStats</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AssertionResult</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">_assertionStats</span><span class="p">.</span><span class="n">assertionResult</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">includeResults</span> <span class="o">=</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">includeSuccessfulResults</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">isOk</span><span class="p">();</span>

    <span class="c1">// Drop out if result was successful but we&#39;re not printing them.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">includeResults</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">.</span><span class="n">getResultType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Warning</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">lazyPrint</span><span class="p">();</span>

    <span class="n">ConsoleAssertionPrinter</span> <span class="nf">printer</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">_assertionStats</span><span class="p">,</span> <span class="n">includeResults</span><span class="p">);</span>
    <span class="n">printer</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">sectionStarting</span><span class="p">(</span><span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_sectionInfo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_tablePrinter</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>
    <span class="n">m_headerPrinted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">sectionStarting</span><span class="p">(</span><span class="n">_sectionInfo</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">sectionEnded</span><span class="p">(</span><span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_sectionStats</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_tablePrinter</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_sectionStats</span><span class="p">.</span><span class="n">missingAssertions</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lazyPrint</span><span class="p">();</span>
        <span class="n">Colour</span> <span class="nf">colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">ResultError</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_sectionStack</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">No assertions in section&quot;</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">No assertions in test case&quot;</span><span class="p">;</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">_sectionStats</span><span class="p">.</span><span class="n">sectionInfo</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">double</span> <span class="n">dur</span> <span class="o">=</span> <span class="n">_sectionStats</span><span class="p">.</span><span class="n">durationInSeconds</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shouldShowDuration</span><span class="p">(</span><span class="o">*</span><span class="n">m_config</span><span class="p">,</span> <span class="n">dur</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">getFormattedDuration</span><span class="p">(</span><span class="n">dur</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">_sectionStats</span><span class="p">.</span><span class="n">sectionInfo</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_headerPrinted</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_headerPrinted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">sectionEnded</span><span class="p">(</span><span class="n">_sectionStats</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">benchmarkPreparing</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">lazyPrintWithoutClosingBenchmarkTable</span><span class="p">();</span>

	<span class="k">auto</span> <span class="n">nameCol</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="p">).</span><span class="n">width</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_tablePrinter</span><span class="o">-&gt;</span><span class="n">columnInfos</span><span class="p">()[</span><span class="mi">0</span><span class="p">].</span><span class="n">width</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>

	<span class="kt">bool</span> <span class="n">firstLine</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">line</span> <span class="p">:</span> <span class="n">nameCol</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firstLine</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">m_tablePrinter</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">firstLine</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="p">(</span><span class="o">*</span><span class="n">m_tablePrinter</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">line</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">benchmarkStarting</span><span class="p">(</span><span class="n">BenchmarkInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">*</span><span class="n">m_tablePrinter</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">samples</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span>
        <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">iterations</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">benchmarkNoAnalysis</span><span class="p">())</span>
        <span class="p">(</span><span class="o">*</span><span class="n">m_tablePrinter</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">Duration</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">estimatedDuration</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">benchmarkEnded</span><span class="p">(</span><span class="n">BenchmarkStats</span><span class="o">&lt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stats</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">benchmarkNoAnalysis</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">m_tablePrinter</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">Duration</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">mean</span><span class="p">.</span><span class="n">point</span><span class="p">.</span><span class="n">count</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">m_tablePrinter</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">Duration</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">mean</span><span class="p">.</span><span class="n">point</span><span class="p">.</span><span class="n">count</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">Duration</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">mean</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">.</span><span class="n">count</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">Duration</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">mean</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">.</span><span class="n">count</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">Duration</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">standardDeviation</span><span class="p">.</span><span class="n">point</span><span class="p">.</span><span class="n">count</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">Duration</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">standardDeviation</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">.</span><span class="n">count</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">Duration</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">standardDeviation</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">.</span><span class="n">count</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">benchmarkFailed</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Colour</span> <span class="nf">colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Red</span><span class="p">);</span>
    <span class="p">(</span><span class="o">*</span><span class="n">m_tablePrinter</span><span class="p">)</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;Benchmark failed (&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">error</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span>
        <span class="o">&lt;&lt;</span> <span class="n">ColumnBreak</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">RowBreak</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">testCaseEnded</span><span class="p">(</span><span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testCaseStats</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_tablePrinter</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>
    <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testCaseEnded</span><span class="p">(</span><span class="n">_testCaseStats</span><span class="p">);</span>
    <span class="n">m_headerPrinted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">testGroupEnded</span><span class="p">(</span><span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testGroupStats</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currentGroupInfo</span><span class="p">.</span><span class="n">used</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printSummaryDivider</span><span class="p">();</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Summary for group &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">_testGroupStats</span><span class="p">.</span><span class="n">groupInfo</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">printTotals</span><span class="p">(</span><span class="n">_testGroupStats</span><span class="p">.</span><span class="n">totals</span><span class="p">);</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testGroupEnded</span><span class="p">(</span><span class="n">_testGroupStats</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">testRunEnded</span><span class="p">(</span><span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testRunStats</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printTotalsDivider</span><span class="p">(</span><span class="n">_testRunStats</span><span class="p">.</span><span class="n">totals</span><span class="p">);</span>
    <span class="n">printTotals</span><span class="p">(</span><span class="n">_testRunStats</span><span class="p">.</span><span class="n">totals</span><span class="p">);</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testRunEnded</span><span class="p">(</span><span class="n">_testRunStats</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">testRunStarting</span><span class="p">(</span><span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_testInfo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testRunStarting</span><span class="p">(</span><span class="n">_testInfo</span><span class="p">);</span>
    <span class="n">printTestFilters</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">lazyPrint</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">m_tablePrinter</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>
    <span class="n">lazyPrintWithoutClosingBenchmarkTable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">lazyPrintWithoutClosingBenchmarkTable</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">currentTestRunInfo</span><span class="p">.</span><span class="n">used</span><span class="p">)</span>
        <span class="n">lazyPrintRunInfo</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">currentGroupInfo</span><span class="p">.</span><span class="n">used</span><span class="p">)</span>
        <span class="n">lazyPrintGroupInfo</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_headerPrinted</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printTestCaseAndSectionHeader</span><span class="p">();</span>
        <span class="n">m_headerPrinted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">lazyPrintRunInfo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">getLineOfChars</span><span class="o">&lt;</span><span class="sc">&#39;~&#39;</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">Colour</span> <span class="nf">colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">SecondaryText</span><span class="p">);</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">currentTestRunInfo</span><span class="o">-&gt;</span><span class="n">name</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot; is a Catch v&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">libraryVersion</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; host application.</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;Run with -? for options</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">rngSeed</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Randomness seeded to: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">rngSeed</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>

    <span class="n">currentTestRunInfo</span><span class="p">.</span><span class="n">used</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">lazyPrintGroupInfo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">currentGroupInfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">currentGroupInfo</span><span class="o">-&gt;</span><span class="n">groupsCounts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printClosedHeader</span><span class="p">(</span><span class="s">&quot;Group: &quot;</span> <span class="o">+</span> <span class="n">currentGroupInfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
        <span class="n">currentGroupInfo</span><span class="p">.</span><span class="n">used</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">printTestCaseAndSectionHeader</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_sectionStack</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
    <span class="n">printOpenHeader</span><span class="p">(</span><span class="n">currentTestCaseInfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m_sectionStack</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Headers</span><span class="p">);</span>

        <span class="k">auto</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">m_sectionStack</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// Skip first section (test case)</span>
            <span class="n">itEnd</span> <span class="o">=</span> <span class="n">m_sectionStack</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">itEnd</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
            <span class="n">printHeaderString</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">SourceLineInfo</span> <span class="n">lineInfo</span> <span class="o">=</span> <span class="n">m_sectionStack</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">lineInfo</span><span class="p">;</span>

    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">getLineOfChars</span><span class="o">&lt;</span><span class="sc">&#39;-&#39;</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">FileName</span><span class="p">);</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">lineInfo</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">getLineOfChars</span><span class="o">&lt;</span><span class="sc">&#39;.&#39;</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">printClosedHeader</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printOpenHeader</span><span class="p">(</span><span class="n">_name</span><span class="p">);</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">getLineOfChars</span><span class="o">&lt;</span><span class="sc">&#39;.&#39;</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">printOpenHeader</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">getLineOfChars</span><span class="o">&lt;</span><span class="sc">&#39;-&#39;</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">Colour</span> <span class="nf">colourGuard</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Headers</span><span class="p">);</span>
        <span class="n">printHeaderString</span><span class="p">(</span><span class="n">_name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// if string has a : in first line will set indent to follow it on</span>
<span class="c1">// subsequent lines</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">printHeaderString</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">indent</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_string</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;: &quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span><span class="n">_string</span><span class="p">).</span><span class="n">indent</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="n">i</span><span class="p">).</span><span class="n">initialIndent</span><span class="p">(</span><span class="n">indent</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">SummaryColumn</span> <span class="p">{</span>

    <span class="n">SummaryColumn</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_label</span><span class="p">,</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="n">_colour</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">label</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">_label</span> <span class="p">)</span> <span class="p">),</span>
        <span class="n">colour</span><span class="p">(</span> <span class="n">_colour</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="n">SummaryColumn</span> <span class="n">addRow</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
        <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">count</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">row</span> <span class="o">=</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">oldRow</span> <span class="p">:</span> <span class="n">rows</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">oldRow</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                <span class="n">oldRow</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span> <span class="o">+</span> <span class="n">oldRow</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">oldRow</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">row</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                <span class="n">row</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span> <span class="o">+</span> <span class="n">row</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">rows</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">row</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">label</span><span class="p">;</span>
    <span class="n">Colour</span><span class="o">::</span><span class="n">Code</span> <span class="n">colour</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">rows</span><span class="p">;</span>

<span class="p">};</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">printTotals</span><span class="p">(</span> <span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">totals</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">total</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Warning</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No tests ran</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">total</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">allPassed</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">ResultSuccess</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;All tests passed&quot;</span><span class="p">;</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; (&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">passed</span><span class="p">,</span> <span class="s">&quot;assertion&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; in &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">pluralise</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">passed</span><span class="p">,</span> <span class="s">&quot;test case&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span>
            <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SummaryColumn</span><span class="o">&gt;</span> <span class="n">columns</span><span class="p">;</span>
        <span class="n">columns</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SummaryColumn</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">Colour</span><span class="o">::</span><span class="n">None</span><span class="p">)</span>
                          <span class="p">.</span><span class="n">addRow</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">total</span><span class="p">())</span>
                          <span class="p">.</span><span class="n">addRow</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">total</span><span class="p">()));</span>
        <span class="n">columns</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SummaryColumn</span><span class="p">(</span><span class="s">&quot;passed&quot;</span><span class="p">,</span> <span class="n">Colour</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span>
                          <span class="p">.</span><span class="n">addRow</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">passed</span><span class="p">)</span>
                          <span class="p">.</span><span class="n">addRow</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">passed</span><span class="p">));</span>
        <span class="n">columns</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SummaryColumn</span><span class="p">(</span><span class="s">&quot;failed&quot;</span><span class="p">,</span> <span class="n">Colour</span><span class="o">::</span><span class="n">ResultError</span><span class="p">)</span>
                          <span class="p">.</span><span class="n">addRow</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span><span class="p">)</span>
                          <span class="p">.</span><span class="n">addRow</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="p">));</span>
        <span class="n">columns</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SummaryColumn</span><span class="p">(</span><span class="s">&quot;failed as expected&quot;</span><span class="p">,</span> <span class="n">Colour</span><span class="o">::</span><span class="n">ResultExpectedFailure</span><span class="p">)</span>
                          <span class="p">.</span><span class="n">addRow</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failedButOk</span><span class="p">)</span>
                          <span class="p">.</span><span class="n">addRow</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failedButOk</span><span class="p">));</span>

        <span class="n">printSummaryRow</span><span class="p">(</span><span class="s">&quot;test cases&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">printSummaryRow</span><span class="p">(</span><span class="s">&quot;assertions&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">printSummaryRow</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">label</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SummaryColumn</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">cols</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">col</span> <span class="p">:</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span> <span class="o">=</span> <span class="n">col</span><span class="p">.</span><span class="n">rows</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">label</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="s">&quot;0&quot;</span><span class="p">)</span>
                <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Warning</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;- none -&quot;</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="s">&quot;0&quot;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">LightGrey</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; | &quot;</span><span class="p">;</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">colour</span><span class="p">)</span>
                <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">col</span><span class="p">.</span><span class="n">label</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">printTotalsDivider</span><span class="p">(</span><span class="n">Totals</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">totals</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">total</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">failedRatio</span> <span class="o">=</span> <span class="n">makeRatio</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span><span class="p">,</span> <span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">total</span><span class="p">());</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">failedButOkRatio</span> <span class="o">=</span> <span class="n">makeRatio</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failedButOk</span><span class="p">,</span> <span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">total</span><span class="p">());</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">passedRatio</span> <span class="o">=</span> <span class="n">makeRatio</span><span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">passed</span><span class="p">,</span> <span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">total</span><span class="p">());</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">failedRatio</span> <span class="o">+</span> <span class="n">failedButOkRatio</span> <span class="o">+</span> <span class="n">passedRatio</span> <span class="o">&lt;</span> <span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">findMax</span><span class="p">(</span><span class="n">failedRatio</span><span class="p">,</span> <span class="n">failedButOkRatio</span><span class="p">,</span> <span class="n">passedRatio</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">failedRatio</span> <span class="o">+</span> <span class="n">failedButOkRatio</span> <span class="o">+</span> <span class="n">passedRatio</span> <span class="o">&gt;</span> <span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">findMax</span><span class="p">(</span><span class="n">failedRatio</span><span class="p">,</span> <span class="n">failedButOkRatio</span><span class="p">,</span> <span class="n">passedRatio</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>

        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Error</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">failedRatio</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">ResultExpectedFailure</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">failedButOkRatio</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">allPassed</span><span class="p">())</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">ResultSuccess</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">passedRatio</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Success</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">passedRatio</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">Colour</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">Warning</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">CATCH_CONFIG_CONSOLE_WIDTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">printSummaryDivider</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="n">getLineOfChars</span><span class="o">&lt;</span><span class="sc">&#39;-&#39;</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConsoleReporter</span><span class="o">::</span><span class="n">printTestFilters</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">testSpec</span><span class="p">().</span><span class="n">hasFilters</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">Colour</span> <span class="nf">guard</span><span class="p">(</span><span class="n">Colour</span><span class="o">::</span><span class="n">BrightYellow</span><span class="p">);</span>
        <span class="n">stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Filters: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">serializeFilters</span><span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">getTestsOrTags</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">CATCH_REGISTER_REPORTER</span><span class="p">(</span><span class="s">&quot;console&quot;</span><span class="p">,</span> <span class="n">ConsoleReporter</span><span class="p">)</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#pragma warning(pop)</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(__clang__)</span>
<span class="cp">#  pragma clang diagnostic pop</span>
<span class="cp">#endif</span>
<span class="c1">// end catch_reporter_console.cpp</span>
<span class="c1">// start catch_reporter_junit.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="k">namespace</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getCurrentTimestamp</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// Beware, this is not reentrant because of backward compatibility issues</span>
            <span class="c1">// Also, UTC only, again because of backward compatibility (%z is C++11)</span>
            <span class="kt">time_t</span> <span class="n">rawtime</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rawtime</span><span class="p">);</span>
            <span class="k">auto</span> <span class="k">const</span> <span class="n">timeStampSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;2017-01-16T17:06:45Z&quot;</span><span class="p">);</span>

<span class="cp">#ifdef _MSC_VER</span>
            <span class="n">std</span><span class="o">::</span><span class="n">tm</span> <span class="n">timeInfo</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">gmtime_s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rawtime</span><span class="p">);</span>
<span class="cp">#else</span>
            <span class="n">std</span><span class="o">::</span><span class="n">tm</span><span class="o">*</span> <span class="n">timeInfo</span><span class="p">;</span>
            <span class="n">timeInfo</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">gmtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rawtime</span><span class="p">);</span>
<span class="cp">#endif</span>

            <span class="kt">char</span> <span class="n">timeStamp</span><span class="p">[</span><span class="n">timeStampSize</span><span class="p">];</span>
            <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">fmt</span> <span class="o">=</span> <span class="s">&quot;%Y-%m-%dT%H:%M:%SZ&quot;</span><span class="p">;</span>

<span class="cp">#ifdef _MSC_VER</span>
            <span class="n">std</span><span class="o">::</span><span class="n">strftime</span><span class="p">(</span><span class="n">timeStamp</span><span class="p">,</span> <span class="n">timeStampSize</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeInfo</span><span class="p">);</span>
<span class="cp">#else</span>
            <span class="n">std</span><span class="o">::</span><span class="n">strftime</span><span class="p">(</span><span class="n">timeStamp</span><span class="p">,</span> <span class="n">timeStampSize</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">timeInfo</span><span class="p">);</span>
<span class="cp">#endif</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">timeStamp</span><span class="p">,</span> <span class="n">timeStampSize</span><span class="mi">-1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fileNameTag</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">tags</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">tags</span><span class="p">),</span>
                                   <span class="n">end</span><span class="p">(</span><span class="n">tags</span><span class="p">),</span>
                                   <span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">tag</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">tag</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">;</span> <span class="p">});</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">tags</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// Formats the duration in seconds to 3 decimal places.</span>
        <span class="c1">// This is done because some genius defined Maven Surefire schema</span>
        <span class="c1">// in a way that only accepts 3 decimal places, and tools like</span>
        <span class="c1">// Jenkins use that schema for validation JUnit reporter output.</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">formatDuration</span><span class="p">(</span> <span class="kt">double</span> <span class="n">seconds</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">fixed</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">seconds</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="c1">// anonymous namespace</span>

    <span class="n">JunitReporter</span><span class="o">::</span><span class="n">JunitReporter</span><span class="p">(</span> <span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_config</span> <span class="p">)</span>
        <span class="o">:</span>   <span class="n">CumulativeReporterBase</span><span class="p">(</span> <span class="n">_config</span> <span class="p">),</span>
            <span class="n">xml</span><span class="p">(</span> <span class="n">_config</span><span class="p">.</span><span class="n">stream</span><span class="p">()</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">m_reporterPrefs</span><span class="p">.</span><span class="n">shouldRedirectStdOut</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">m_reporterPrefs</span><span class="p">.</span><span class="n">shouldReportAllAssertions</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="n">JunitReporter</span><span class="o">::~</span><span class="n">JunitReporter</span><span class="p">()</span> <span class="p">{}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">getDescription</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;Reports test results in an XML format that looks like Ant&#39;s junitreport target&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">noMatchingTestCases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="cm">/*spec*/</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">testRunStarting</span><span class="p">(</span> <span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">runInfo</span> <span class="p">)</span>  <span class="p">{</span>
        <span class="n">CumulativeReporterBase</span><span class="o">::</span><span class="n">testRunStarting</span><span class="p">(</span> <span class="n">runInfo</span> <span class="p">);</span>
        <span class="n">xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span> <span class="s">&quot;testsuites&quot;</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">testGroupStarting</span><span class="p">(</span> <span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">groupInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">suiteTimer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
        <span class="n">stdOutForSuite</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">stdErrForSuite</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">unexpectedExceptions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">CumulativeReporterBase</span><span class="o">::</span><span class="n">testGroupStarting</span><span class="p">(</span> <span class="n">groupInfo</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">testCaseStarting</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_okToFail</span> <span class="o">=</span> <span class="n">testCaseInfo</span><span class="p">.</span><span class="n">okToFail</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">assertionEnded</span><span class="p">(</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">assertionStats</span><span class="p">.</span><span class="n">assertionResult</span><span class="p">.</span><span class="n">getResultType</span><span class="p">()</span> <span class="o">==</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">ThrewException</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">m_okToFail</span> <span class="p">)</span>
            <span class="n">unexpectedExceptions</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">CumulativeReporterBase</span><span class="o">::</span><span class="n">assertionEnded</span><span class="p">(</span> <span class="n">assertionStats</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">testCaseEnded</span><span class="p">(</span> <span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">stdOutForSuite</span> <span class="o">+=</span> <span class="n">testCaseStats</span><span class="p">.</span><span class="n">stdOut</span><span class="p">;</span>
        <span class="n">stdErrForSuite</span> <span class="o">+=</span> <span class="n">testCaseStats</span><span class="p">.</span><span class="n">stdErr</span><span class="p">;</span>
        <span class="n">CumulativeReporterBase</span><span class="o">::</span><span class="n">testCaseEnded</span><span class="p">(</span> <span class="n">testCaseStats</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">testGroupEnded</span><span class="p">(</span> <span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testGroupStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">suiteTime</span> <span class="o">=</span> <span class="n">suiteTimer</span><span class="p">.</span><span class="n">getElapsedSeconds</span><span class="p">();</span>
        <span class="n">CumulativeReporterBase</span><span class="o">::</span><span class="n">testGroupEnded</span><span class="p">(</span> <span class="n">testGroupStats</span> <span class="p">);</span>
        <span class="n">writeGroup</span><span class="p">(</span> <span class="o">*</span><span class="n">m_testGroups</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">suiteTime</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">testRunEndedCumulative</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">writeGroup</span><span class="p">(</span> <span class="n">TestGroupNode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">groupNode</span><span class="p">,</span> <span class="kt">double</span> <span class="n">suiteTime</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span> <span class="n">e</span> <span class="o">=</span> <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;testsuite&quot;</span> <span class="p">);</span>

        <span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">groupNode</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
        <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">groupInfo</span><span class="p">.</span><span class="n">name</span> <span class="p">);</span>
        <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;errors&quot;</span><span class="p">,</span> <span class="n">unexpectedExceptions</span> <span class="p">);</span>
        <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;failures&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span><span class="o">-</span><span class="n">unexpectedExceptions</span> <span class="p">);</span>
        <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;tests&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">total</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;hostname&quot;</span><span class="p">,</span> <span class="s">&quot;tbd&quot;</span> <span class="p">);</span> <span class="c1">// !TBD</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">showDurations</span><span class="p">()</span> <span class="o">==</span> <span class="n">ShowDurations</span><span class="o">::</span><span class="n">Never</span> <span class="p">)</span>
            <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;time&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span> <span class="p">);</span>
        <span class="k">else</span>
            <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;time&quot;</span><span class="p">,</span> <span class="n">formatDuration</span><span class="p">(</span> <span class="n">suiteTime</span> <span class="p">)</span> <span class="p">);</span>
        <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;timestamp&quot;</span><span class="p">,</span> <span class="n">getCurrentTimestamp</span><span class="p">()</span> <span class="p">);</span>

        <span class="c1">// Write properties if there are any</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">hasTestFilters</span><span class="p">()</span> <span class="o">||</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">rngSeed</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span><span class="s">&quot;properties&quot;</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">hasTestFilters</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span><span class="s">&quot;property&quot;</span><span class="p">)</span>
                    <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;filters&quot;</span><span class="p">)</span>
                    <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">serializeFilters</span><span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">getTestsOrTags</span><span class="p">()));</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">rngSeed</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span><span class="s">&quot;property&quot;</span><span class="p">)</span>
                    <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;random-seed&quot;</span><span class="p">)</span>
                    <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">rngSeed</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Write test cases</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">child</span> <span class="p">:</span> <span class="n">groupNode</span><span class="p">.</span><span class="n">children</span> <span class="p">)</span>
            <span class="n">writeTestCase</span><span class="p">(</span> <span class="o">*</span><span class="n">child</span> <span class="p">);</span>

        <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;system-out&quot;</span> <span class="p">).</span><span class="n">writeText</span><span class="p">(</span> <span class="n">trim</span><span class="p">(</span> <span class="n">stdOutForSuite</span> <span class="p">),</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="p">);</span>
        <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;system-err&quot;</span> <span class="p">).</span><span class="n">writeText</span><span class="p">(</span> <span class="n">trim</span><span class="p">(</span> <span class="n">stdErrForSuite</span> <span class="p">),</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">writeTestCase</span><span class="p">(</span> <span class="n">TestCaseNode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseNode</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">testCaseNode</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

        <span class="c1">// All test cases have exactly one section - which represents the</span>
        <span class="c1">// test case itself. That section may have 0-n nested sections</span>
        <span class="n">assert</span><span class="p">(</span> <span class="n">testCaseNode</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">);</span>
        <span class="n">SectionNode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rootSection</span> <span class="o">=</span> <span class="o">*</span><span class="n">testCaseNode</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">className</span> <span class="o">=</span> <span class="n">stats</span><span class="p">.</span><span class="n">testInfo</span><span class="p">.</span><span class="n">className</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">className</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">className</span> <span class="o">=</span> <span class="n">fileNameTag</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">testInfo</span><span class="p">.</span><span class="n">tags</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">className</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">className</span> <span class="o">=</span> <span class="s">&quot;global&quot;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">className</span> <span class="o">=</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">className</span><span class="p">;</span>

        <span class="n">writeSection</span><span class="p">(</span> <span class="n">className</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">rootSection</span><span class="p">,</span> <span class="n">stats</span><span class="p">.</span><span class="n">testInfo</span><span class="p">.</span><span class="n">okToFail</span><span class="p">()</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">writeSection</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">className</span><span class="p">,</span>
                                      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">rootName</span><span class="p">,</span>
                                      <span class="n">SectionNode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionNode</span><span class="p">,</span>
                                      <span class="kt">bool</span> <span class="n">testOkToFail</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="n">trim</span><span class="p">(</span> <span class="n">sectionNode</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">sectionInfo</span><span class="p">.</span><span class="n">name</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">rootName</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">rootName</span> <span class="o">+</span> <span class="sc">&#39;/&#39;</span> <span class="o">+</span> <span class="n">name</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">sectionNode</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span>
            <span class="o">!</span><span class="n">sectionNode</span><span class="p">.</span><span class="n">stdOut</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span>
            <span class="o">!</span><span class="n">sectionNode</span><span class="p">.</span><span class="n">stdErr</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span> <span class="n">e</span> <span class="o">=</span> <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;testcase&quot;</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">className</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;classname&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="p">);</span>
                <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;root&quot;</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;classname&quot;</span><span class="p">,</span> <span class="n">className</span> <span class="p">);</span>
                <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="p">);</span>
            <span class="p">}</span>
            <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;time&quot;</span><span class="p">,</span> <span class="n">formatDuration</span><span class="p">(</span> <span class="n">sectionNode</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">durationInSeconds</span> <span class="p">)</span> <span class="p">);</span>
            <span class="c1">// This is not ideal, but it should be enough to mimic gtest&#39;s</span>
            <span class="c1">// junit output.</span>
            <span class="c1">// Ideally the JUnit reporter would also handle `skipTest`</span>
            <span class="c1">// events and write those out appropriately.</span>
            <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;status&quot;</span><span class="p">,</span> <span class="s">&quot;run&quot;</span> <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">sectionNode</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failedButOk</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span><span class="s">&quot;skipped&quot;</span><span class="p">)</span>
                    <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;message&quot;</span><span class="p">,</span> <span class="s">&quot;TEST_CASE tagged with !mayfail&quot;</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">writeAssertions</span><span class="p">(</span> <span class="n">sectionNode</span> <span class="p">);</span>

            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">sectionNode</span><span class="p">.</span><span class="n">stdOut</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;system-out&quot;</span> <span class="p">).</span><span class="n">writeText</span><span class="p">(</span> <span class="n">trim</span><span class="p">(</span> <span class="n">sectionNode</span><span class="p">.</span><span class="n">stdOut</span> <span class="p">),</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">sectionNode</span><span class="p">.</span><span class="n">stdErr</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;system-err&quot;</span> <span class="p">).</span><span class="n">writeText</span><span class="p">(</span> <span class="n">trim</span><span class="p">(</span> <span class="n">sectionNode</span><span class="p">.</span><span class="n">stdErr</span> <span class="p">),</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">childNode</span> <span class="p">:</span> <span class="n">sectionNode</span><span class="p">.</span><span class="n">childSections</span> <span class="p">)</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">className</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">writeSection</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">childNode</span><span class="p">,</span> <span class="n">testOkToFail</span> <span class="p">);</span>
            <span class="k">else</span>
                <span class="nf">writeSection</span><span class="p">(</span> <span class="n">className</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">childNode</span><span class="p">,</span> <span class="n">testOkToFail</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">writeAssertions</span><span class="p">(</span> <span class="n">SectionNode</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionNode</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">assertion</span> <span class="p">:</span> <span class="n">sectionNode</span><span class="p">.</span><span class="n">assertions</span> <span class="p">)</span>
            <span class="n">writeAssertion</span><span class="p">(</span> <span class="n">assertion</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">JunitReporter</span><span class="o">::</span><span class="n">writeAssertion</span><span class="p">(</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">stats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">AssertionResult</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stats</span><span class="p">.</span><span class="n">assertionResult</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">isOk</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">elementName</span><span class="p">;</span>
            <span class="k">switch</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getResultType</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ThrewException</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">FatalErrorCondition</span><span class="p">:</span>
                    <span class="n">elementName</span> <span class="o">=</span> <span class="s">&quot;error&quot;</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ExplicitFailure</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ExpressionFailed</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">DidntThrowException</span><span class="p">:</span>
                    <span class="n">elementName</span> <span class="o">=</span> <span class="s">&quot;failure&quot;</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="c1">// We should never see these here:</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Info</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Warning</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Ok</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Unknown</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">FailureBit</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Exception</span><span class="p">:</span>
                    <span class="n">elementName</span> <span class="o">=</span> <span class="s">&quot;internalError&quot;</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span> <span class="n">e</span> <span class="o">=</span> <span class="n">xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="n">elementName</span> <span class="p">);</span>

            <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;message&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">getExpression</span><span class="p">()</span> <span class="p">);</span>
            <span class="n">xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;type&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">getTestMacroName</span><span class="p">()</span> <span class="p">);</span>

            <span class="n">ReusableStringStream</span> <span class="n">rss</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">total</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;FAILED&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">hasExpression</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span><span class="p">;</span>
                    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">getExpressionInMacro</span><span class="p">();</span>
                    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">hasExpandedExpression</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;with expansion:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
                    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">Column</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">getExpandedExpression</span><span class="p">()).</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">getMessage</span><span class="p">().</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">getMessage</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">msg</span> <span class="p">:</span> <span class="n">stats</span><span class="p">.</span><span class="n">infoMessages</span> <span class="p">)</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">msg</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Info</span> <span class="p">)</span>
                    <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span><span class="p">.</span><span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

            <span class="n">rss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;at &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">getSourceInfo</span><span class="p">();</span>
            <span class="n">xml</span><span class="p">.</span><span class="n">writeText</span><span class="p">(</span> <span class="n">rss</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">CATCH_REGISTER_REPORTER</span><span class="p">(</span> <span class="s">&quot;junit&quot;</span><span class="p">,</span> <span class="n">JunitReporter</span> <span class="p">)</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_reporter_junit.cpp</span>
<span class="c1">// start catch_reporter_listening.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>

    <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">ListeningReporter</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// We will assume that listeners will always want all assertions</span>
        <span class="n">m_preferences</span><span class="p">.</span><span class="n">shouldReportAllAssertions</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">addListener</span><span class="p">(</span> <span class="n">IStreamingReporterPtr</span><span class="o">&amp;&amp;</span> <span class="n">listener</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_listeners</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">listener</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">addReporter</span><span class="p">(</span><span class="n">IStreamingReporterPtr</span><span class="o">&amp;&amp;</span> <span class="n">reporter</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_reporter</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Listening reporter can wrap only 1 real reporter&quot;</span><span class="p">);</span>
        <span class="n">m_reporter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">reporter</span> <span class="p">);</span>
        <span class="n">m_preferences</span><span class="p">.</span><span class="n">shouldRedirectStdOut</span> <span class="o">=</span> <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">getPreferences</span><span class="p">().</span><span class="n">shouldRedirectStdOut</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ReporterPreferences</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">getPreferences</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_preferences</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Verbosity</span><span class="o">&gt;</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">getSupportedVerbosities</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Verbosity</span><span class="o">&gt;</span><span class="p">{</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">noMatchingTestCases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">spec</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">noMatchingTestCases</span><span class="p">(</span> <span class="n">spec</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">noMatchingTestCases</span><span class="p">(</span> <span class="n">spec</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">reportInvalidArguments</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">){</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">reportInvalidArguments</span><span class="p">(</span> <span class="n">arg</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">reportInvalidArguments</span><span class="p">(</span> <span class="n">arg</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">benchmarkPreparing</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">listener</span><span class="o">-&gt;</span><span class="n">benchmarkPreparing</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">benchmarkPreparing</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">benchmarkStarting</span><span class="p">(</span> <span class="n">BenchmarkInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">benchmarkInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">benchmarkStarting</span><span class="p">(</span> <span class="n">benchmarkInfo</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">benchmarkStarting</span><span class="p">(</span> <span class="n">benchmarkInfo</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">benchmarkEnded</span><span class="p">(</span> <span class="n">BenchmarkStats</span><span class="o">&lt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">benchmarkStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">benchmarkEnded</span><span class="p">(</span> <span class="n">benchmarkStats</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">benchmarkEnded</span><span class="p">(</span> <span class="n">benchmarkStats</span> <span class="p">);</span>
    <span class="p">}</span>

	<span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">benchmarkFailed</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">error</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">listener</span><span class="o">-&gt;</span><span class="n">benchmarkFailed</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">benchmarkFailed</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">testRunStarting</span><span class="p">(</span> <span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testRunInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">testRunStarting</span><span class="p">(</span> <span class="n">testRunInfo</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testRunStarting</span><span class="p">(</span> <span class="n">testRunInfo</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">testGroupStarting</span><span class="p">(</span> <span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">groupInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">testGroupStarting</span><span class="p">(</span> <span class="n">groupInfo</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testGroupStarting</span><span class="p">(</span> <span class="n">groupInfo</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">testCaseStarting</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">testCaseStarting</span><span class="p">(</span> <span class="n">testInfo</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testCaseStarting</span><span class="p">(</span> <span class="n">testInfo</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">sectionStarting</span><span class="p">(</span> <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">sectionStarting</span><span class="p">(</span> <span class="n">sectionInfo</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">sectionStarting</span><span class="p">(</span> <span class="n">sectionInfo</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">assertionStarting</span><span class="p">(</span> <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">assertionStarting</span><span class="p">(</span> <span class="n">assertionInfo</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">assertionStarting</span><span class="p">(</span> <span class="n">assertionInfo</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// The return value indicates if the messages buffer should be cleared:</span>
    <span class="kt">bool</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">assertionEnded</span><span class="p">(</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">listener</span><span class="o">-&gt;</span><span class="n">assertionEnded</span><span class="p">(</span> <span class="n">assertionStats</span> <span class="p">)</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">assertionEnded</span><span class="p">(</span> <span class="n">assertionStats</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">sectionEnded</span><span class="p">(</span> <span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">sectionEnded</span><span class="p">(</span> <span class="n">sectionStats</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">sectionEnded</span><span class="p">(</span> <span class="n">sectionStats</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">testCaseEnded</span><span class="p">(</span> <span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">testCaseEnded</span><span class="p">(</span> <span class="n">testCaseStats</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testCaseEnded</span><span class="p">(</span> <span class="n">testCaseStats</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">testGroupEnded</span><span class="p">(</span> <span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testGroupStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">testGroupEnded</span><span class="p">(</span> <span class="n">testGroupStats</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testGroupEnded</span><span class="p">(</span> <span class="n">testGroupStats</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">testRunEnded</span><span class="p">(</span> <span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testRunStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">testRunEnded</span><span class="p">(</span> <span class="n">testRunStats</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">testRunEnded</span><span class="p">(</span> <span class="n">testRunStats</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">skipTest</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">listener</span> <span class="p">:</span> <span class="n">m_listeners</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">listener</span><span class="o">-&gt;</span><span class="n">skipTest</span><span class="p">(</span> <span class="n">testInfo</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">m_reporter</span><span class="o">-&gt;</span><span class="n">skipTest</span><span class="p">(</span> <span class="n">testInfo</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">ListeningReporter</span><span class="o">::</span><span class="n">isMulti</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>
<span class="c1">// end catch_reporter_listening.cpp</span>
<span class="c1">// start catch_reporter_xml.cpp</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#pragma warning(push)</span>
<span class="cp">#pragma warning(disable:4061) </span><span class="c1">// Not all labels are EXPLICITLY handled in switch</span>
                              <span class="c1">// Note that 4062 (not all labels are handled</span>
                              <span class="c1">// and default is missing) is enabled</span>
<span class="cp">#endif</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">XmlReporter</span><span class="o">::</span><span class="n">XmlReporter</span><span class="p">(</span> <span class="n">ReporterConfig</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">_config</span> <span class="p">)</span>
    <span class="o">:</span>   <span class="n">StreamingReporterBase</span><span class="p">(</span> <span class="n">_config</span> <span class="p">),</span>
        <span class="n">m_xml</span><span class="p">(</span><span class="n">_config</span><span class="p">.</span><span class="n">stream</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">m_reporterPrefs</span><span class="p">.</span><span class="n">shouldRedirectStdOut</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">m_reporterPrefs</span><span class="p">.</span><span class="n">shouldReportAllAssertions</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">XmlReporter</span><span class="o">::~</span><span class="n">XmlReporter</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">getDescription</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;Reports test results as an XML document&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">getStylesheetRef</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">writeSourceInfo</span><span class="p">(</span> <span class="n">SourceLineInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sourceInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">m_xml</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;filename&quot;</span><span class="p">,</span> <span class="n">sourceInfo</span><span class="p">.</span><span class="n">file</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;line&quot;</span><span class="p">,</span> <span class="n">sourceInfo</span><span class="p">.</span><span class="n">line</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">noMatchingTestCases</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">noMatchingTestCases</span><span class="p">(</span> <span class="n">s</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">testRunStarting</span><span class="p">(</span> <span class="n">TestRunInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testRunStarting</span><span class="p">(</span> <span class="n">testInfo</span> <span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">stylesheetRef</span> <span class="o">=</span> <span class="n">getStylesheetRef</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">stylesheetRef</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">writeStylesheetRef</span><span class="p">(</span> <span class="n">stylesheetRef</span> <span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span> <span class="s">&quot;Catch&quot;</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_config</span><span class="o">-&gt;</span><span class="n">testSpec</span><span class="p">().</span><span class="n">hasFilters</span><span class="p">())</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;filters&quot;</span><span class="p">,</span> <span class="n">serializeFilters</span><span class="p">(</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">getTestsOrTags</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">rngSeed</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;Randomness&quot;</span> <span class="p">)</span>
                <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;seed&quot;</span><span class="p">,</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">rngSeed</span><span class="p">()</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">testGroupStarting</span><span class="p">(</span> <span class="n">GroupInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">groupInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testGroupStarting</span><span class="p">(</span> <span class="n">groupInfo</span> <span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span> <span class="s">&quot;Group&quot;</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">groupInfo</span><span class="p">.</span><span class="n">name</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">testCaseStarting</span><span class="p">(</span> <span class="n">TestCaseInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testCaseStarting</span><span class="p">(</span><span class="n">testInfo</span><span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span> <span class="s">&quot;TestCase&quot;</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">trim</span><span class="p">(</span> <span class="n">testInfo</span><span class="p">.</span><span class="n">name</span> <span class="p">)</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;description&quot;</span><span class="p">,</span> <span class="n">testInfo</span><span class="p">.</span><span class="n">description</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;tags&quot;</span><span class="p">,</span> <span class="n">testInfo</span><span class="p">.</span><span class="n">tagsAsString</span><span class="p">()</span> <span class="p">);</span>

        <span class="n">writeSourceInfo</span><span class="p">(</span> <span class="n">testInfo</span><span class="p">.</span><span class="n">lineInfo</span> <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">showDurations</span><span class="p">()</span> <span class="o">==</span> <span class="n">ShowDurations</span><span class="o">::</span><span class="n">Always</span> <span class="p">)</span>
            <span class="n">m_testCaseTimer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">ensureTagClosed</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">sectionStarting</span><span class="p">(</span> <span class="n">SectionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionInfo</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">sectionStarting</span><span class="p">(</span> <span class="n">sectionInfo</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">m_sectionDepth</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span> <span class="s">&quot;Section&quot;</span> <span class="p">)</span>
                <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">trim</span><span class="p">(</span> <span class="n">sectionInfo</span><span class="p">.</span><span class="n">name</span> <span class="p">)</span> <span class="p">);</span>
            <span class="n">writeSourceInfo</span><span class="p">(</span> <span class="n">sectionInfo</span><span class="p">.</span><span class="n">lineInfo</span> <span class="p">);</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">ensureTagClosed</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">assertionStarting</span><span class="p">(</span> <span class="n">AssertionInfo</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">assertionEnded</span><span class="p">(</span> <span class="n">AssertionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">assertionStats</span> <span class="p">)</span> <span class="p">{</span>

        <span class="n">AssertionResult</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">assertionStats</span><span class="p">.</span><span class="n">assertionResult</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="n">includeResults</span> <span class="o">=</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">includeSuccessfulResults</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">isOk</span><span class="p">();</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">includeResults</span> <span class="o">||</span> <span class="n">result</span><span class="p">.</span><span class="n">getResultType</span><span class="p">()</span> <span class="o">==</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Warning</span> <span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Print any info messages in &lt;Info&gt; tags.</span>
            <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">msg</span> <span class="p">:</span> <span class="n">assertionStats</span><span class="p">.</span><span class="n">infoMessages</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">msg</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Info</span> <span class="o">&amp;&amp;</span> <span class="n">includeResults</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;Info&quot;</span> <span class="p">)</span>
                            <span class="p">.</span><span class="n">writeText</span><span class="p">(</span> <span class="n">msg</span><span class="p">.</span><span class="n">message</span> <span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">msg</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Warning</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;Warning&quot;</span> <span class="p">)</span>
                            <span class="p">.</span><span class="n">writeText</span><span class="p">(</span> <span class="n">msg</span><span class="p">.</span><span class="n">message</span> <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Drop out if result was successful but we&#39;re not printing them.</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">includeResults</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">.</span><span class="n">getResultType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ResultWas</span><span class="o">::</span><span class="n">Warning</span> <span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="c1">// Print the expression if there is one.</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">hasExpression</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span> <span class="s">&quot;Expression&quot;</span> <span class="p">)</span>
                <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;success&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">succeeded</span><span class="p">()</span> <span class="p">)</span>
                <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;type&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">getTestMacroName</span><span class="p">()</span> <span class="p">);</span>

            <span class="n">writeSourceInfo</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getSourceInfo</span><span class="p">()</span> <span class="p">);</span>

            <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;Original&quot;</span> <span class="p">)</span>
                <span class="p">.</span><span class="n">writeText</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getExpression</span><span class="p">()</span> <span class="p">);</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;Expanded&quot;</span> <span class="p">)</span>
                <span class="p">.</span><span class="n">writeText</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getExpandedExpression</span><span class="p">()</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// And... Print a result applicable to each result type.</span>
        <span class="k">switch</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getResultType</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ThrewException</span><span class="p">:</span>
                <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span> <span class="s">&quot;Exception&quot;</span> <span class="p">);</span>
                <span class="n">writeSourceInfo</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getSourceInfo</span><span class="p">()</span> <span class="p">);</span>
                <span class="n">m_xml</span><span class="p">.</span><span class="n">writeText</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getMessage</span><span class="p">()</span> <span class="p">);</span>
                <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">FatalErrorCondition</span><span class="p">:</span>
                <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span> <span class="s">&quot;FatalErrorCondition&quot;</span> <span class="p">);</span>
                <span class="n">writeSourceInfo</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getSourceInfo</span><span class="p">()</span> <span class="p">);</span>
                <span class="n">m_xml</span><span class="p">.</span><span class="n">writeText</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getMessage</span><span class="p">()</span> <span class="p">);</span>
                <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Info</span><span class="p">:</span>
                <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;Info&quot;</span> <span class="p">)</span>
                    <span class="p">.</span><span class="n">writeText</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getMessage</span><span class="p">()</span> <span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">Warning</span><span class="p">:</span>
                <span class="c1">// Warning will already have been written</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">ResultWas</span><span class="o">::</span><span class="nl">ExplicitFailure</span><span class="p">:</span>
                <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span> <span class="s">&quot;Failure&quot;</span> <span class="p">);</span>
                <span class="n">writeSourceInfo</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getSourceInfo</span><span class="p">()</span> <span class="p">);</span>
                <span class="n">m_xml</span><span class="p">.</span><span class="n">writeText</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">getMessage</span><span class="p">()</span> <span class="p">);</span>
                <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">hasExpression</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">sectionEnded</span><span class="p">(</span> <span class="n">SectionStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sectionStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">sectionEnded</span><span class="p">(</span> <span class="n">sectionStats</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">--</span><span class="n">m_sectionDepth</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span> <span class="n">e</span> <span class="o">=</span> <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;OverallResults&quot;</span> <span class="p">);</span>
            <span class="n">e</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;successes&quot;</span><span class="p">,</span> <span class="n">sectionStats</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">passed</span> <span class="p">);</span>
            <span class="n">e</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;failures&quot;</span><span class="p">,</span> <span class="n">sectionStats</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span> <span class="p">);</span>
            <span class="n">e</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;expectedFailures&quot;</span><span class="p">,</span> <span class="n">sectionStats</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failedButOk</span> <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">showDurations</span><span class="p">()</span> <span class="o">==</span> <span class="n">ShowDurations</span><span class="o">::</span><span class="n">Always</span> <span class="p">)</span>
                <span class="n">e</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;durationInSeconds&quot;</span><span class="p">,</span> <span class="n">sectionStats</span><span class="p">.</span><span class="n">durationInSeconds</span> <span class="p">);</span>

            <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">testCaseEnded</span><span class="p">(</span> <span class="n">TestCaseStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testCaseStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testCaseEnded</span><span class="p">(</span> <span class="n">testCaseStats</span> <span class="p">);</span>
        <span class="n">XmlWriter</span><span class="o">::</span><span class="n">ScopedElement</span> <span class="n">e</span> <span class="o">=</span> <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;OverallResult&quot;</span> <span class="p">);</span>
        <span class="n">e</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;success&quot;</span><span class="p">,</span> <span class="n">testCaseStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">allOk</span><span class="p">()</span> <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">m_config</span><span class="o">-&gt;</span><span class="n">showDurations</span><span class="p">()</span> <span class="o">==</span> <span class="n">ShowDurations</span><span class="o">::</span><span class="n">Always</span> <span class="p">)</span>
            <span class="n">e</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;durationInSeconds&quot;</span><span class="p">,</span> <span class="n">m_testCaseTimer</span><span class="p">.</span><span class="n">getElapsedSeconds</span><span class="p">()</span> <span class="p">);</span>

        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">testCaseStats</span><span class="p">.</span><span class="n">stdOut</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;StdOut&quot;</span> <span class="p">).</span><span class="n">writeText</span><span class="p">(</span> <span class="n">trim</span><span class="p">(</span> <span class="n">testCaseStats</span><span class="p">.</span><span class="n">stdOut</span> <span class="p">),</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">testCaseStats</span><span class="p">.</span><span class="n">stdErr</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;StdErr&quot;</span> <span class="p">).</span><span class="n">writeText</span><span class="p">(</span> <span class="n">trim</span><span class="p">(</span> <span class="n">testCaseStats</span><span class="p">.</span><span class="n">stdErr</span> <span class="p">),</span> <span class="n">XmlFormatting</span><span class="o">::</span><span class="n">Newline</span> <span class="p">);</span>

        <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">testGroupEnded</span><span class="p">(</span> <span class="n">TestGroupStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testGroupStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testGroupEnded</span><span class="p">(</span> <span class="n">testGroupStats</span> <span class="p">);</span>
        <span class="c1">// TODO: Check testGroupStats.aborting and act accordingly.</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;OverallResults&quot;</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;successes&quot;</span><span class="p">,</span> <span class="n">testGroupStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">passed</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;failures&quot;</span><span class="p">,</span> <span class="n">testGroupStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;expectedFailures&quot;</span><span class="p">,</span> <span class="n">testGroupStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failedButOk</span> <span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;OverallResultsCases&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;successes&quot;</span><span class="p">,</span> <span class="n">testGroupStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">passed</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;failures&quot;</span><span class="p">,</span> <span class="n">testGroupStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;expectedFailures&quot;</span><span class="p">,</span> <span class="n">testGroupStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failedButOk</span> <span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">testRunEnded</span><span class="p">(</span> <span class="n">TestRunStats</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">testRunStats</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">StreamingReporterBase</span><span class="o">::</span><span class="n">testRunEnded</span><span class="p">(</span> <span class="n">testRunStats</span> <span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;OverallResults&quot;</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;successes&quot;</span><span class="p">,</span> <span class="n">testRunStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">passed</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;failures&quot;</span><span class="p">,</span> <span class="n">testRunStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failed</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;expectedFailures&quot;</span><span class="p">,</span> <span class="n">testRunStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">assertions</span><span class="p">.</span><span class="n">failedButOk</span> <span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span> <span class="s">&quot;OverallResultsCases&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;successes&quot;</span><span class="p">,</span> <span class="n">testRunStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">passed</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;failures&quot;</span><span class="p">,</span> <span class="n">testRunStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failed</span> <span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span> <span class="s">&quot;expectedFailures&quot;</span><span class="p">,</span> <span class="n">testRunStats</span><span class="p">.</span><span class="n">totals</span><span class="p">.</span><span class="n">testCases</span><span class="p">.</span><span class="n">failedButOk</span> <span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
    <span class="p">}</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">benchmarkPreparing</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span><span class="s">&quot;BenchmarkResults&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">benchmarkStarting</span><span class="p">(</span><span class="n">BenchmarkInfo</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;samples&quot;</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">samples</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;resamples&quot;</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">resamples</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;iterations&quot;</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">iterations</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;clockResolution&quot;</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">clockResolution</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;estimatedDuration&quot;</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">estimatedDuration</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeComment</span><span class="p">(</span><span class="s">&quot;All values in nano seconds&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">benchmarkEnded</span><span class="p">(</span><span class="n">BenchmarkStats</span><span class="o">&lt;&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">benchmarkStats</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span><span class="s">&quot;mean&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">mean</span><span class="p">.</span><span class="n">point</span><span class="p">.</span><span class="n">count</span><span class="p">())</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;lowerBound&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">mean</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">.</span><span class="n">count</span><span class="p">())</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;upperBound&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">mean</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">.</span><span class="n">count</span><span class="p">())</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;ci&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">mean</span><span class="p">.</span><span class="n">confidence_interval</span><span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span><span class="s">&quot;standardDeviation&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">standardDeviation</span><span class="p">.</span><span class="n">point</span><span class="p">.</span><span class="n">count</span><span class="p">())</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;lowerBound&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">standardDeviation</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">.</span><span class="n">count</span><span class="p">())</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;upperBound&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">standardDeviation</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">.</span><span class="n">count</span><span class="p">())</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;ci&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">standardDeviation</span><span class="p">.</span><span class="n">confidence_interval</span><span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">startElement</span><span class="p">(</span><span class="s">&quot;outliers&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;variance&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">outlierVariance</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;lowMild&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">outliers</span><span class="p">.</span><span class="n">low_mild</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;lowSevere&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">outliers</span><span class="p">.</span><span class="n">low_severe</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;highMild&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">outliers</span><span class="p">.</span><span class="n">high_mild</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;highSevere&quot;</span><span class="p">,</span> <span class="n">benchmarkStats</span><span class="p">.</span><span class="n">outliers</span><span class="p">.</span><span class="n">high_severe</span><span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">XmlReporter</span><span class="o">::</span><span class="n">benchmarkFailed</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">scopedElement</span><span class="p">(</span><span class="s">&quot;failed&quot;</span><span class="p">).</span>
            <span class="n">writeAttribute</span><span class="p">(</span><span class="s">&quot;message&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="n">m_xml</span><span class="p">.</span><span class="n">endElement</span><span class="p">();</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

    <span class="n">CATCH_REGISTER_REPORTER</span><span class="p">(</span> <span class="s">&quot;xml&quot;</span><span class="p">,</span> <span class="n">XmlReporter</span> <span class="p">)</span>

<span class="p">}</span> <span class="c1">// end namespace Catch</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#pragma warning(pop)</span>
<span class="cp">#endif</span>
<span class="c1">// end catch_reporter_xml.cpp</span>

<span class="k">namespace</span> <span class="n">Catch</span> <span class="p">{</span>
    <span class="n">LeakDetector</span> <span class="n">leakDetector</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __clang__</span>
<span class="cp">#pragma clang diagnostic pop</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_impl.hpp</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CATCH_CONFIG_MAIN</span>
<span class="c1">// start catch_default_main.hpp</span>

<span class="cp">#ifndef __OBJC__</span>

<span class="cp">#if defined(CATCH_CONFIG_WCHAR) &amp;&amp; defined(CATCH_PLATFORM_WINDOWS) &amp;&amp; defined(_UNICODE) &amp;&amp; !defined(DO_NOT_USE_WMAIN)</span>
<span class="c1">// Standard C/C++ Win32 Unicode wmain entry point</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">wmain</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[],</span> <span class="kt">wchar_t</span> <span class="o">*</span> <span class="p">[])</span> <span class="p">{</span>
<span class="cp">#else</span>
<span class="c1">// Standard C/C++ main entry point</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#endif</span>

    <span class="k">return</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Session</span><span class="p">().</span><span class="n">run</span><span class="p">(</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="c1">// __OBJC__</span>

<span class="c1">// Objective-C entry point</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="cp">#if !CATCH_ARC_ENABLED</span>
    <span class="n">NSAutoreleasePool</span> <span class="o">*</span> <span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="cp">#endif</span>

    <span class="n">Catch</span><span class="o">::</span><span class="n">registerTestMethods</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Session</span><span class="p">().</span><span class="n">run</span><span class="p">(</span> <span class="n">argc</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">argv</span> <span class="p">);</span>

<span class="cp">#if !CATCH_ARC_ENABLED</span>
    <span class="p">[</span><span class="n">pool</span> <span class="n">drain</span><span class="p">];</span>
<span class="cp">#endif</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="c1">// __OBJC__</span>

<span class="c1">// end catch_default_main.hpp</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(CATCH_CONFIG_IMPL_ONLY)</span>

<span class="cp">#ifdef CLARA_CONFIG_MAIN_NOT_DEFINED</span>
<span class="cp">#  undef CLARA_CONFIG_MAIN</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(CATCH_CONFIG_DISABLE)</span>
<span class="c1">//////</span>
<span class="c1">// If this config identifier is defined then all CATCH macros are prefixed with CATCH_</span>
<span class="cp">#ifdef CATCH_CONFIG_PREFIX_ALL</span>

<span class="cp">#define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_REQUIRE&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_REQUIRE_FALSE&quot;, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )</span>

<span class="cp">#define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( &quot;CATCH_REQUIRE_THROWS&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CATCH_REQUIRE_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::Normal, expr )</span>
<span class="cp">#define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )</span>
<span class="cp">#endif</span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>
<span class="cp">#define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CATCH_REQUIRE_NOTHROW&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )</span>

<span class="cp">#define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK_FALSE&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( &quot;CATCH_CHECKED_IF&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( &quot;CATCH_CHECKED_ELSE&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( &quot;CATCH_CHECK_NOFAIL&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )</span>

<span class="cp">#define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( &quot;CATCH_CHECK_THROWS&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CATCH_CHECK_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )</span>
<span class="cp">#define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CATCH_CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CATCH_CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>
<span class="cp">#define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CATCH_CHECK_NOTHROW&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>

<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )</span>

<span class="cp">#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CATCH_REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>

<span class="cp">#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( &quot;CATCH_INFO&quot;, msg )</span>
<span class="cp">#define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( &quot;CATCH_UNSCOPED_INFO&quot;, msg )</span>
<span class="cp">#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( &quot;CATCH_WARN&quot;, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )</span>
<span class="cp">#define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), &quot;CATCH_CAPTURE&quot;,__VA_ARGS__ )</span>

<span class="cp">#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_FAIL&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_FAIL_CHECK&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( &quot;CATCH_SUCCEED&quot;, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>

<span class="cp">#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )</span>
<span class="cp">#else</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)</span>
<span class="cp">#define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )</span>
<span class="cp">#define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; ); CATCH_SUCCEED( #__VA_ARGS__ )</span>
<span class="cp">#else</span>
<span class="cp">#define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )</span>
<span class="cp">#endif</span>

<span class="c1">// &quot;BDD-style&quot; convenience wrappers</span>
<span class="cp">#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( &quot;Scenario: &quot; __VA_ARGS__ )</span>
<span class="cp">#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, &quot;Scenario: &quot; __VA_ARGS__ )</span>
<span class="cp">#define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( &quot;    Given: &quot; &lt;&lt; desc )</span>
<span class="cp">#define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( &quot;And given: &quot; &lt;&lt; desc )</span>
<span class="cp">#define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     When: &quot; &lt;&lt; desc )</span>
<span class="cp">#define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot; And when: &quot; &lt;&lt; desc )</span>
<span class="cp">#define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     Then: &quot; &lt;&lt; desc )</span>
<span class="cp">#define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot;      And: &quot; &lt;&lt; desc )</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
<span class="cp">#define CATCH_BENCHMARK(...) \</span>
<span class="cp">    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))</span>
<span class="cp">#define CATCH_BENCHMARK_ADVANCED(name) \</span>
<span class="cp">    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

<span class="c1">// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required</span>
<span class="cp">#else</span>

<span class="cp">#define REQUIRE( ... ) INTERNAL_CATCH_TEST( &quot;REQUIRE&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__  )</span>
<span class="cp">#define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;REQUIRE_FALSE&quot;, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )</span>

<span class="cp">#define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( &quot;REQUIRE_THROWS&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )</span>
<span class="cp">#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;REQUIRE_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::Normal, expr )</span>
<span class="cp">#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;REQUIRE_THROWS_WITH&quot;, Catch::ResultDisposition::Normal, matcher, expr )</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;REQUIRE_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>
<span class="cp">#define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;REQUIRE_NOTHROW&quot;, Catch::ResultDisposition::Normal, __VA_ARGS__ )</span>

<span class="cp">#define CHECK( ... ) INTERNAL_CATCH_TEST( &quot;CHECK&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( &quot;CHECK_FALSE&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )</span>
<span class="cp">#define CHECKED_IF( ... ) INTERNAL_CATCH_IF( &quot;CHECKED_IF&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( &quot;CHECKED_ELSE&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( &quot;CHECK_NOFAIL&quot;, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )</span>

<span class="cp">#define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( &quot;CHECK_THROWS&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( &quot;CHECK_THROWS_AS&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )</span>
<span class="cp">#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( &quot;CHECK_THROWS_WITH&quot;, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( &quot;CHECK_THROWS_MATCHES&quot;, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>
<span class="cp">#define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( &quot;CHECK_NOTHROW&quot;, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>

<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;CHECK_THAT&quot;, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )</span>

<span class="cp">#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( &quot;REQUIRE_THAT&quot;, matcher, Catch::ResultDisposition::Normal, arg )</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>

<span class="cp">#define INFO( msg ) INTERNAL_CATCH_INFO( &quot;INFO&quot;, msg )</span>
<span class="cp">#define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( &quot;UNSCOPED_INFO&quot;, msg )</span>
<span class="cp">#define WARN( msg ) INTERNAL_CATCH_MSG( &quot;WARN&quot;, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )</span>
<span class="cp">#define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), &quot;CAPTURE&quot;,__VA_ARGS__ )</span>

<span class="cp">#define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )</span>
<span class="cp">#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )</span>
<span class="cp">#define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )</span>
<span class="cp">#define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )</span>
<span class="cp">#define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )</span>
<span class="cp">#define FAIL( ... ) INTERNAL_CATCH_MSG( &quot;FAIL&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )</span>
<span class="cp">#define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( &quot;FAIL_CHECK&quot;, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define SUCCEED( ... ) INTERNAL_CATCH_MSG( &quot;SUCCEED&quot;, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )</span>
<span class="cp">#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
<span class="cp">#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)</span>
<span class="cp">#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#else</span>
<span class="cp">#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)</span>
<span class="cp">#define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )</span>
<span class="cp">#define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; ); SUCCEED( &quot;!(&quot; #__VA_ARGS__ &quot;)&quot; )</span>
<span class="cp">#else</span>
<span class="cp">#define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )</span>
<span class="cp">#define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

<span class="cp">#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )</span>

<span class="c1">// &quot;BDD-style&quot; convenience wrappers</span>
<span class="cp">#define SCENARIO( ... ) TEST_CASE( &quot;Scenario: &quot; __VA_ARGS__ )</span>
<span class="cp">#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, &quot;Scenario: &quot; __VA_ARGS__ )</span>

<span class="cp">#define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( &quot;    Given: &quot; &lt;&lt; desc )</span>
<span class="cp">#define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( &quot;And given: &quot; &lt;&lt; desc )</span>
<span class="cp">#define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     When: &quot; &lt;&lt; desc )</span>
<span class="cp">#define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot; And when: &quot; &lt;&lt; desc )</span>
<span class="cp">#define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( &quot;     Then: &quot; &lt;&lt; desc )</span>
<span class="cp">#define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( &quot;      And: &quot; &lt;&lt; desc )</span>

<span class="cp">#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)</span>
<span class="cp">#define BENCHMARK(...) \</span>
<span class="cp">    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))</span>
<span class="cp">#define BENCHMARK_ADVANCED(name) \</span>
<span class="cp">    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_ENABLE_BENCHMARKING</span>

<span class="k">using</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span><span class="p">;</span>

<span class="cp">#else </span><span class="c1">// CATCH_CONFIG_DISABLE</span>

<span class="c1">//////</span>
<span class="c1">// If this config identifier is defined then all CATCH macros are prefixed with CATCH_</span>
<span class="cp">#ifdef CATCH_CONFIG_PREFIX_ALL</span>

<span class="cp">#define CATCH_REQUIRE( ... )        (void)(0)</span>
<span class="cp">#define CATCH_REQUIRE_FALSE( ... )  (void)(0)</span>

<span class="cp">#define CATCH_REQUIRE_THROWS( ... ) (void)(0)</span>
<span class="cp">#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)</span>
<span class="cp">#define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)</span>
<span class="cp">#endif</span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>
<span class="cp">#define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)</span>

<span class="cp">#define CATCH_CHECK( ... )         (void)(0)</span>
<span class="cp">#define CATCH_CHECK_FALSE( ... )   (void)(0)</span>
<span class="cp">#define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)</span>
<span class="cp">#define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))</span>
<span class="cp">#define CATCH_CHECK_NOFAIL( ... )  (void)(0)</span>

<span class="cp">#define CATCH_CHECK_THROWS( ... )  (void)(0)</span>
<span class="cp">#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)</span>
<span class="cp">#define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>
<span class="cp">#define CATCH_CHECK_NOTHROW( ... ) (void)(0)</span>

<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define CATCH_CHECK_THAT( arg, matcher )   (void)(0)</span>

<span class="cp">#define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>

<span class="cp">#define CATCH_INFO( msg )          (void)(0)</span>
<span class="cp">#define CATCH_UNSCOPED_INFO( msg ) (void)(0)</span>
<span class="cp">#define CATCH_WARN( msg )          (void)(0)</span>
<span class="cp">#define CATCH_CAPTURE( msg )       (void)(0)</span>

<span class="cp">#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))</span>
<span class="cp">#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))</span>
<span class="cp">#define CATCH_METHOD_AS_TEST_CASE( method, ... )</span>
<span class="cp">#define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)</span>
<span class="cp">#define CATCH_SECTION( ... )</span>
<span class="cp">#define CATCH_DYNAMIC_SECTION( ... )</span>
<span class="cp">#define CATCH_FAIL( ... ) (void)(0)</span>
<span class="cp">#define CATCH_FAIL_CHECK( ... ) (void)(0)</span>
<span class="cp">#define CATCH_SUCCEED( ... ) (void)(0)</span>

<span class="cp">#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#else</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )</span>
<span class="cp">#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#endif</span>

<span class="c1">// &quot;BDD-style&quot; convenience wrappers</span>
<span class="cp">#define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))</span>
<span class="cp">#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )</span>
<span class="cp">#define CATCH_GIVEN( desc )</span>
<span class="cp">#define CATCH_AND_GIVEN( desc )</span>
<span class="cp">#define CATCH_WHEN( desc )</span>
<span class="cp">#define CATCH_AND_WHEN( desc )</span>
<span class="cp">#define CATCH_THEN( desc )</span>
<span class="cp">#define CATCH_AND_THEN( desc )</span>

<span class="cp">#define CATCH_STATIC_REQUIRE( ... )       (void)(0)</span>
<span class="cp">#define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)</span>

<span class="c1">// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required</span>
<span class="cp">#else</span>

<span class="cp">#define REQUIRE( ... )       (void)(0)</span>
<span class="cp">#define REQUIRE_FALSE( ... ) (void)(0)</span>

<span class="cp">#define REQUIRE_THROWS( ... ) (void)(0)</span>
<span class="cp">#define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)</span>
<span class="cp">#define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>
<span class="cp">#define REQUIRE_NOTHROW( ... ) (void)(0)</span>

<span class="cp">#define CHECK( ... ) (void)(0)</span>
<span class="cp">#define CHECK_FALSE( ... ) (void)(0)</span>
<span class="cp">#define CHECKED_IF( ... ) if (__VA_ARGS__)</span>
<span class="cp">#define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))</span>
<span class="cp">#define CHECK_NOFAIL( ... ) (void)(0)</span>

<span class="cp">#define CHECK_THROWS( ... )  (void)(0)</span>
<span class="cp">#define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)</span>
<span class="cp">#define CHECK_THROWS_WITH( expr, matcher ) (void)(0)</span>
<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>
<span class="cp">#define CHECK_NOTHROW( ... ) (void)(0)</span>

<span class="cp">#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)</span>
<span class="cp">#define CHECK_THAT( arg, matcher ) (void)(0)</span>

<span class="cp">#define REQUIRE_THAT( arg, matcher ) (void)(0)</span>
<span class="cp">#endif </span><span class="c1">// CATCH_CONFIG_DISABLE_MATCHERS</span>

<span class="cp">#define INFO( msg ) (void)(0)</span>
<span class="cp">#define UNSCOPED_INFO( msg ) (void)(0)</span>
<span class="cp">#define WARN( msg ) (void)(0)</span>
<span class="cp">#define CAPTURE( msg ) (void)(0)</span>

<span class="cp">#define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))</span>
<span class="cp">#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))</span>
<span class="cp">#define METHOD_AS_TEST_CASE( method, ... )</span>
<span class="cp">#define REGISTER_TEST_CASE( Function, ... ) (void)(0)</span>
<span class="cp">#define SECTION( ... )</span>
<span class="cp">#define DYNAMIC_SECTION( ... )</span>
<span class="cp">#define FAIL( ... ) (void)(0)</span>
<span class="cp">#define FAIL_CHECK( ... ) (void)(0)</span>
<span class="cp">#define SUCCEED( ... ) (void)(0)</span>
<span class="cp">#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))</span>

<span class="cp">#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR</span>
<span class="cp">#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)</span>
<span class="cp">#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)</span>
<span class="cp">#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)</span>
<span class="cp">#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#else</span>
<span class="cp">#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )</span>
<span class="cp">#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )</span>
<span class="cp">#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )</span>
<span class="cp">#endif</span>

<span class="cp">#define STATIC_REQUIRE( ... )       (void)(0)</span>
<span class="cp">#define STATIC_REQUIRE_FALSE( ... ) (void)(0)</span>

<span class="cp">#endif</span>

<span class="cp">#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )</span>

<span class="c1">// &quot;BDD-style&quot; convenience wrappers</span>
<span class="cp">#define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )</span>
<span class="cp">#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )</span>

<span class="cp">#define GIVEN( desc )</span>
<span class="cp">#define AND_GIVEN( desc )</span>
<span class="cp">#define WHEN( desc )</span>
<span class="cp">#define AND_WHEN( desc )</span>
<span class="cp">#define THEN( desc )</span>
<span class="cp">#define AND_THEN( desc )</span>

<span class="k">using</span> <span class="n">Catch</span><span class="o">::</span><span class="n">Detail</span><span class="o">::</span><span class="n">Approx</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="c1">// ! CATCH_CONFIG_IMPL_ONLY</span>

<span class="c1">// start catch_reenable_warnings.h</span>


<span class="cp">#ifdef __clang__</span>
<span class="cp">#    ifdef __ICC </span><span class="c1">// icpc defines the __clang__ macro</span>
<span class="cp">#        pragma warning(pop)</span>
<span class="cp">#    else</span>
<span class="cp">#        pragma clang diagnostic pop</span>
<span class="cp">#    endif</span>
<span class="cp">#elif defined __GNUC__</span>
<span class="cp">#    pragma GCC diagnostic pop</span>
<span class="cp">#endif</span>

<span class="c1">// end catch_reenable_warnings.h</span>
<span class="c1">// end catch.hpp</span>
<span class="cp">#endif </span><span class="c1">// TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED</span>
</pre></div>
</body>
</html>
